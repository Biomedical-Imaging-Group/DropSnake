/* * Tools for ImageAccess in relation to ImageJ. * * @author 	Swiss Federal Institute of Technology Lausanne *			Biomedical Imaging Group *			Daniel Sage * * @version 1.0 * */ package dropsnake;import ij.*;import ij.process.*;import ij.gui.*;public class ImageAccessTools extends Object{/**/static public ImageAccess[] createArray(int nx, int ny, int type, int number){	ImageAccess image[] = new ImageAccess[number];	for (int i=0; i < number; i++)		image[i] = new ImageAccess(nx, ny, type);	return image;}/**/static public void show(ImagePlus imp, String title, ImageAccess image){	if (imp == null) {		imp = new ImagePlus(title, image.getImageProcessor());	}	else {		imp.setProcessor(title, image.getImageProcessor());	}	imp.show();	imp.updateAndDraw();}/***/static public void showScale(ImagePlus imp, String title, ImageAccess image){	image.getImageProcessor().resetMinAndMax();	if (imp == null) {		imp = new ImagePlus(title, image.getImageProcessor());	}	else {		imp.setProcessor(title, image.getImageProcessor());	}	imp.show();	imp.updateAndDraw();}/***/static public void show(String title, ImageAccess image){	ImagePlus imp = new ImagePlus(title, image.getImageProcessor());	imp.show();	imp.updateAndDraw();}/***/static public void show(String title, ImageAccess image[]){	int nx = image[0].getWidth();	int ny = image[0].getHeight();	ImagePlus imp;	switch(image[0].getType()) {		case ImageAccess.BYTE:  	  			imp = NewImage.createByteImage("", nx, ny, 1, NewImage.FILL_BLACK); 			break;		case ImageAccess.SHORT:    			imp = NewImage.createShortImage("", nx, ny, 1, NewImage.FILL_BLACK); 			break;		case ImageAccess.FLOAT:    			imp = NewImage.createFloatImage("", nx, ny, 1, NewImage.FILL_BLACK); 			break;		default:			throw new ArrayStoreException("Unexpected image type");	}	ImageStack stack = imp.createEmptyStack();	for (int i=0; i<image.length; i++) {		stack.addSlice("", image[i].getImageProcessor());	}		ImagePlus imp1 = new ImagePlus(title, stack);	imp1.show();	imp1.updateAndDraw();}/**/static public void showScale(String title, ImageAccess image[]){	int nx = image[0].getWidth();	int ny = image[0].getHeight();	ImagePlus imp;	switch(image[0].getType()) {		case ImageAccess.BYTE:  	  			imp = NewImage.createByteImage("", nx, ny, 1, NewImage.FILL_BLACK); 			break;		case ImageAccess.SHORT:    			imp = NewImage.createShortImage("", nx, ny, 1, NewImage.FILL_BLACK); 			break;		case ImageAccess.FLOAT:    			imp = NewImage.createFloatImage("", nx, ny, 1, NewImage.FILL_BLACK); 			break;		default:			throw new ArrayStoreException("Unexpected image type");	}	ImageStack stack = imp.createEmptyStack();	for (int i=0; i<image.length; i++) {		image[i].getImageProcessor().resetMinAndMax();		stack.addSlice("", image[i].getImageProcessor());	}		ImagePlus imp1 = new ImagePlus(title, stack);	imp1.show();	imp1.updateAndDraw();}/**/static public void showScale(String title, ImageAccess image){	image.getImageProcessor().resetMinAndMax();	ImagePlus imp = new ImagePlus(title, image.getImageProcessor());	imp.show();	imp.updateAndDraw();}/***/static public ImageAccess[] createColorArray(ColorProcessor ipc, int type){	int nx = ipc.getWidth();	int ny = ipc.getHeight();		ImageAccess[] image = new ImageAccess[3];	image[0] = new ImageAccess(nx, ny, type); 	image[1] = new ImageAccess(nx, ny, type); 	image[2] = new ImageAccess(nx, ny, type); 		int[] pixels = (int[])ipc.getPixels();	int size = nx*ny;		switch(type) {		case ImageAccess.BYTE:			byte bytePixR[] = (byte [])image[0].getPixelsByte();			byte bytePixG[] = (byte [])image[1].getPixelsByte();			byte bytePixB[] = (byte [])image[2].getPixelsByte();			for ( int i = 0; i < size; i++) {				bytePixR[i] = (byte)((pixels[i]&0xff0000)>>16);				bytePixG[i] = (byte)((pixels[i]&0xff00)>>8);				bytePixB[i] = (byte)(pixels[i]&0xff);			}			break;		case ImageAccess.SHORT:			short shortPixR[] = (short [])image[0].getPixelsShort();			short shortPixG[] = (short [])image[1].getPixelsShort();			short shortPixB[] = (short [])image[2].getPixelsShort();			for ( int i = 0; i < size; i++) {				shortPixR[i] = (short)((pixels[i]&0xff0000)>>16);				shortPixG[i] = (short)((pixels[i]&0xff00)>>8);				shortPixB[i] = (short)(pixels[i]&0xff);			}			break;		case ImageAccess.FLOAT:			float floatPixR[] = (float [])image[0].getPixelsFloat();			float floatPixG[] = (float [])image[1].getPixelsFloat();			float floatPixB[] = (float [])image[2].getPixelsFloat();			for ( int i = 0; i < size; i++) {				floatPixR[i] = (float)((pixels[i]&0xff0000)>>16);				floatPixG[i] = (float)((pixels[i]&0xff00)>>8);				floatPixB[i] = (float)(pixels[i]&0xff);			}			break;		case ImageAccess.DOUBLE:			double doublePixR[] = (double [])image[0].getPixelsDouble();			double doublePixG[] = (double [])image[1].getPixelsDouble();			double doublePixB[] = (double [])image[2].getPixelsDouble();			for ( int i = 0; i < size; i++) {				doublePixR[i] = (double)((pixels[i]&0xff0000)>>16);				doublePixG[i] = (double)((pixels[i]&0xff00)>>8);				doublePixB[i] = (double)(pixels[i]&0xff);			}			break;		default:			throw new ArrayStoreException("Unexpected image type.");	}	return image;}static public ColorProcessor createColorProcessor(ImageAccess image[]){		if (image.length != 3) {		throw new ArrayStoreException("Unexpected image type.");	}	int nx = image[0].getWidth();	int ny = image[0].getHeight();		ColorProcessor ipc = new ColorProcessor(nx, ny);	int size = nx*ny;		int[] pix = (int[])ipc.getPixels();	byte b0 = (byte)0;	byte b1 = (byte)255;	int r, g, b;	switch(image[0].getType()) {		case ImageAccess.BYTE:			byte bR[] = image[0].getPixelsByte();			byte bG[] = image[1].getPixelsByte();			byte bB[] = image[2].getPixelsByte();			for (int i=0; i < size; i++) {				r = ((bR[i]<0)?(b0):((bR[i]>255)?(b1):(bR[i])))&0xff;				g = ((bG[i]<0)?(b0):((bG[i]>255)?(b1):(bG[i])))&0xff;				b = ((bB[i]<0)?(b0):((bB[i]>255)?(b1):(bB[i])))&0xff;				pix[i] = 0xff000000 | (r<<16) | (g<<8) | b;			}			break;		case ImageAccess.SHORT:			short sR[] = image[0].getPixelsShort();			short sG[] = image[1].getPixelsShort();			short sB[] = image[2].getPixelsShort();			for (int i=0; i < size; i++) {				r = ((sR[i]<0)?(b0):((sR[i]>255)?(b1):((byte)sR[i])))&0xff;				g = ((sG[i]<0)?(b0):((sG[i]>255)?(b1):((byte)sG[i])))&0xff;				b = ((sB[i]<0)?(b0):((sB[i]>255)?(b1):((byte)sB[i])))&0xff;				pix[i] = 0xff000000 | (r<<16) | (g<<8) | b;			}			break;		case ImageAccess.FLOAT:			float fR[] = image[0].getPixelsFloat();			float fG[] = image[1].getPixelsFloat();			float fB[] = image[2].getPixelsFloat();			for (int i=0; i < nx*ny; i++) {				r = ((fR[i]<0.0)?(b0):((fR[i]>255.0)?(b1):((byte)fR[i])))&0xff;				g = ((fG[i]<0.0)?(b0):((fG[i]>255.0)?(b1):((byte)fG[i])))&0xff;				b = ((fB[i]<0.0)?(b0):((fB[i]>255.0)?(b1):((byte)fB[i])))&0xff;				pix[i] = 0xff000000 | (r<<16) | (g<<8) | b;			}			break;		case ImageAccess.DOUBLE:			double dR[] = image[0].getPixelsDouble();			double dG[] = image[1].getPixelsDouble();			double dB[] = image[2].getPixelsDouble();			for (int i=0; i < size; i++) {				r = ((dR[i]<0.0)?(b0):((dR[i]>255.0)?(b1):((byte)dR[i])))&0xff;				g = ((dG[i]<0.0)?(b0):((dG[i]>255.0)?(b1):((byte)dG[i])))&0xff;				b = ((dB[i]<0.0)?(b0):((dB[i]>255.0)?(b1):((byte)dB[i])))&0xff;				pix[i] = 0xff000000 | (r<<16) | (g<<8) | b;			}			break;		default:			throw new ArrayStoreException("Unexpected image type.");	}		return ipc;}} // end of class
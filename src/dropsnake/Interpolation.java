package dropsnake;import java.awt.Point;import ij.*;/** * Affine Transformation Session plugin * * @author 	Swiss Federal Institute of Technology Lausanne *			Biomedical Imaging Group *			Daniel sage, Aurélien Stalder */public class Interpolation{	/**	* Returns a interpolated Gradient divergence pixel using cubic interpolation.	*/	static public double getSampleCubicSplineDiff2(double x, double y, double neighbor[][]) {		double vd2x[]=getCubicSplineDiff2(x);		double vd2y[]=getCubicSplineDiff2(y);		double vx[]=getCubicSpline(x);		double vy[]=getCubicSpline(y);				double sum = 0.0;		for (int j=0; j<4; j++) {			for (int i=0; i<4; i++) {				sum = sum + neighbor[i][j] * (vd2x[i] * vy[j] + vd2y[j] * vx[i]);			}		}		return sum;			}	/**	* Returns a interpolated Horizontal 2nd Gradient pixel using cubic interpolation.	*/	static public double getSampleCubicSplineDiff2X(double x, double y, double neighbor[][]) {		double vx[]=getCubicSplineDiff2(x);		double vy[]=getCubicSpline(y);				double sum = 0.0;		for (int j=0; j<4; j++) {			for (int i=0; i<4; i++) {				sum = sum + neighbor[i][j] * vx[i] * vy[j];			}		}		return sum;			}					/**	* Returns a interpolated Vertical 2nd Gradient pixel using cubic interpolation.	*/	static public double getSampleCubicSplineDiff2Y(double x, double y, double neighbor[][]) {		double vx[]=getCubicSpline(x);		double vy[]=getCubicSplineDiff2(y);				double sum = 0.0;		for (int j=0; j<4; j++) {			for (int i=0; i<4; i++) {				sum = sum + neighbor[i][j] * vx[i] * vy[j];			}		}		return sum;	}						   	/**	* Computes the cubic spline 2nd differentiation basis function at a position t.	*	* @param	t argument between 0 and 1.	* @return	4 sampled values of the cubic B-spline differentiator 	*			(dB3[t+1], dB3[t], dB3[t-1], dB3[t-2]).	*/		static private double[] getCubicSplineDiff2(double t) {		double v[] = new double[4];				if (t < 0.0 || t > 1.0) {			throw new ArrayStoreException(				"Argument t for differential cubic B-spline outside of expected range."); 		}				double t3 = 3.0*t;				v[0] = -t + 1.0;		v[1] = t3 - 2.0;		v[2] = -t3 + 1.0;		v[3] = t ;		return v;	}						/**	* Returns a interpolated Horizontal Gradient pixel using cubic interpolation.	*/	static public double getSampleCubicSplineDiffX(double x, double y, double neighbor[][]) {		double vx[]=getCubicSplineDiff(x);		double vy[]=getCubicSpline(y);				double sum = 0.0;		for (int j=0; j<4; j++) {			for (int i=0; i<4; i++) {				sum = sum + neighbor[i][j] * vx[i] * vy[j];			}		}		return sum;			}	static public double getSampleCubicSplineDiffX(double x, double y, float neighbor[][]) {		double vx[]=getCubicSplineDiff(x);		double vy[]=getCubicSpline(y);				float sum = 0;		for (int j=0; j<4; j++) {			for (int i=0; i<4; i++) {				sum = sum + neighbor[i][j] * (float)vx[i] * (float)vy[j];			}		}		return sum;	}				/**	* Returns a interpolated Vertical Gradient pixel using cubic interpolation.	*/	static public double getSampleCubicSplineDiffY(double x, double y, double neighbor[][]) {		double vx[]=getCubicSpline(x);		double vy[]=getCubicSplineDiff(y);				double sum = 0.0;		for (int j=0; j<4; j++) {			for (int i=0; i<4; i++) {				sum = sum + neighbor[i][j] * vx[i] * vy[j];			}		}		return sum;	}		static public double getSampleCubicSplineDiffY(double x, double y, float neighbor[][]) {		double vx[]=getCubicSpline(x);		double vy[]=getCubicSplineDiff(y);				float sum = 0;		for (int j=0; j<4; j++) {			for (int i=0; i<4; i++) {				sum = sum + neighbor[i][j] * (float)vx[i] * (float)vy[j];			}		}		return sum;	}							   	/**	* Computes the cubic spline differentiation basis function at a position t.	*	* @param	t argument between 0 and 1.	* @return	4 sampled values of the cubic B-spline differentiator 	*			(dB3[t+1], dB3[t], dB3[t-1], dB3[t-2]).	*/		static private double[] getCubicSplineDiff(double t) {		double v[] = new double[4];				if (t < 0.0 || t > 1.0) {			throw new ArrayStoreException(				"Argument t for differential cubic B-spline outside of expected range."); 		}				double t1 = t - 1.0;		double t2 = t * t;		v[0] = -0.5 * t1 * t1;		v[1] = 1.5 * t2 - 2.0 * t;		v[2] = -0.5 * t1 * (3.0 * t + 1.0);		v[3] = - v[2] - v[1] - v[0];		return v;	}		/**	* Perform an affine transformation of an image.	*	* @return output	an ImageAccess object containing the output image.	* @param input    	an ImageAccess object containing the input image.	* @param interpolation  a string containing the kind of interpolation.	* @param angle  	the angle of rotation in degrees in trigonometric sense.	* @param scaling  	the scaling factor (< 1 means reduce the size).	* @param bx  		the translation vector in the X direction.	* @param by  		the translation vector in the Y direction.	*//*	static public ImageAccess affine(				ImageAccess input, 				String interpolation, 				double angle, double scaling, double bx, double by) {		int nx = input.getWidth();		int ny = input.getHeight();				int x0 = (nx-1)/2;	// Center of the image		int y0 = (ny-1)/2;	// Center of the image		double angleRadian = angle * Math.PI / 180.0; // Angle in radian		double a00 = Math.cos(angleRadian)/scaling; // To complete		double a01 = Math.sin(angleRadian)/scaling; // To complete		double a10 = -Math.sin(angleRadian)/scaling; // To complete		double a11 = Math.cos(angleRadian)/scaling; // To complete		double d0  = -a00*(x0+bx)-a01*(y0+by)+x0; // To complete		double d1  = -a10*(x0+bx)-a11*(y0+by)+y0; // To complete				// Call this method below if your routine doesn't work:		// double[] s = AffineTransformSolution.parameters(x0, y0, angle, scaling, bx, by);		// a00=s[0]; a01=s[1]; a10=s[2]; a11=s[3]; d0=s[4]; d1=s[5];				ImageAccess output = new ImageAccess(nx, ny);		if (interpolation == "Nearest-Neighbor") {			output = affineNearestNeighbor(input, a00, a01, a10, a11, d0, d1);		}		else if (interpolation == "Linear B-Spline") {			output = affineLinearSpline(input, a00, a01, a10, a11, d0, d1);		}		else if (interpolation == "Cubic B-Spline") {			output = affineCubicSpline(input, a00, a01, a10, a11, d0, d1);		}		return output;	}*/	/**	* Performs an affine transformation of an image based on a couple of	* two points to match 2 images	*	* @return output	an ImageAccess object containing the output image.	* @param input    	an ImageAccess object containing the input image.	* @param u1			First point of the source image.	* @param v1			Second point of the source image.	* @param u2			First point of the target image.	* @param u2			Second point of the target image.	*//*	static public ImageAccess match(				ImageAccess input1, 				Point u1, Point v1,  				Point u2, Point v2) {		int nx = input1.getWidth();		int ny = input1.getHeight();				ImageAccess output = new ImageAccess(nx, ny);				double x0 = (nx-1)/2;	// Center of the image		double y0 = (ny-1)/2;	// Center of the image				double alpha = Math.atan2((v2.y-u2.y),(v2.x-u2.x))-Math.atan2((v1.y-u1.y),(v1.x-u1.x));					double scaling = Math.sqrt(((u2.y-v2.y)*(u2.y-v2.y)+(u2.x-v2.x)*(u2.x-v2.x)))/Math.sqrt(((u1.y-v1.y)*(u1.y-v1.y)+(u1.x-v1.x)*(u1.x-v1.x)));				double bx = u2.x-x0 - scaling*(Math.cos(alpha)*(u1.x-x0)-Math.sin(alpha)*(u1.y-y0));				double by = u2.y-y0 - scaling*(Math.sin(alpha)*(u1.x-x0)+Math.cos(alpha)*(u1.y-y0));				alpha=alpha*180/Math.PI;		IJ.write("scaling " +scaling +" alpha " +alpha +" bx " +bx  +" by " +by); 								output=affine(input1,"Cubic B-Spline",alpha, scaling, bx, by);		//		// Add your code here		//				// How to write a message ---> IJ.write("Scaling : " + scaling);		return output;	}*/	/**	* Performs an sequential affine transformation of an image to create 	* an animated sequence of images.	*	* @return output	an ImageAccess object containing the output image.	* @param input    	an ImageAccess object containing the input image.	*//*	static public ImageAccess[] animate(ImageAccess input) {		int nx = input.getWidth();		int ny = input.getHeight();		int nb = 30;		ImageAccess output[] = new ImageAccess[nb];				for (int i=0; i<nb; i++) {			output[i] = new ImageAccess(nx, ny);			//			// Add your code here			//		}				return output;	}*/	/**	* Perform an affine transformation of an image using 	* the nearest-neighbor interpolation.	*//*	static private ImageAccess affineNearestNeighbor(				ImageAccess input, 				double a00, double a01,				double a10, double a11,				double d0, double d1) {		int nx = input.getWidth();		int ny = input.getHeight();		ImageAccess output = new ImageAccess(nx, ny);				double x0, x1, xa, ya, v;		int i, j;		double arr;		for (int xo=0; xo<nx; xo++) {			x0 = a00 * xo + d0;			x1 = a10 * xo + d1;			for (int yo=0; yo<ny; yo++) {				xa = x0 + a01 * yo;				ya = x1 + a11 * yo;				i = (int)Math.round(xa);				j = (int)Math.round(ya);				arr=input.getPixel(i, j);				output.putPixel(xo, yo, arr);					}			}				return output;	}*/	/**	* Perform an affine transformation of an image using the linear spline interpolation.	*//*	static private ImageAccess affineLinearSpline(				ImageAccess input, 				double a00, double a01,				double a10, double a11,				double d0, double d1) {					int nx = input.getWidth();		int ny = input.getHeight();		ImageAccess output = new ImageAccess(nx, ny);				double x0, x1, xa, ya, v;		int i, j;		double arr[][] = new double[2][2];		for (int xo=0; xo<nx; xo++) {			x0 = a00 * xo + d0;			x1 = a10 * xo + d1;			for (int yo=0; yo<ny; yo++) {				xa = x0 + a01 * yo;				ya = x1 + a11 * yo;				i = (int)Math.floor(xa);				j = (int)Math.floor(ya);				input.getNeighborhood(i, j, arr);				v = getSampleLinearSpline(xa-i, ya-j, arr);				output.putPixel(xo, yo, v);					}			}		return output;	}*/	/**	* Returns a interpolated pixel using linear interpolation.	*	* Textbook version of 2D linear spline interpolator. 	* Note: this routine can be coded more efficiently.	*/	static private double getSampleLinearSpline(double x, double y, double neighbor[][]) {		double xw[] = getLinearSpline(x);		double yw[] = getLinearSpline(y);				double sum = 0.0;		for (int j=0; j<2; j++) {			for (int i=0; i<2; i++) {				sum = sum + neighbor[i][j] * yw[j] * xw[i];			}		}		return sum;	}	/**	* Computes the linear spline basis function at a position t.	*	* @param	t argument between 0 and 1.	* @return	2 sampled values of the linear B-spline (B1[t], B1[t-1]).	*/	static private double[] getLinearSpline(double t) {		double v[] = new double[2];				if (t < 0.0 || t > 1.0) {			throw new ArrayStoreException(				"Argument t for linear B-spline outside of expected range."); 		}				v[0] = 1.0 - t;		v[1] = t;		return v;	}	/**	* Perform an affine transformation of an image using 	* the cubic spline interpolation.	*//*	static private ImageAccess affineCubicSpline(				ImageAccess input, 				double a00, double a01,				double a10, double a11,				double d0, double d1) {					int nx = input.getWidth();		int ny = input.getHeight();		ImageAccess output = new ImageAccess(nx, ny);					ImageAccess coef = new ImageAccess(nx, ny);		coef = computeCubicSplineCoeffients(input);				double x0, x1, xa, ya, v;		int i, j;		double arr[][] = new double[4][4];		for (int xo=0; xo<nx; xo++) {			x0 = a00 * xo + d0;			x1 = a10 * xo + d1;			for (int yo=0; yo<ny; yo++) {				xa = x0 + a01 * yo;				ya = x1 + a11 * yo;								i = (int)Math.floor(xa);				j = (int)Math.floor(ya);				coef.getNeighborhood(i, j, arr);				v = getSampleCubicSpline(xa-i, ya-j, arr);								output.putPixel(xo, yo, v);			}		}						//		//	Add your code here		// 						return output;	}	*/	/**	* Returns a interpolated pixel using cubic interpolation.	*/	static public double getSampleCubicSpline(double x, double y, double neighbor[][]) {		double vx[]=getCubicSpline(x);		double vy[]=getCubicSpline(y);				double sum = 0.0;		for (int j=0; j<4; j++) {			for (int i=0; i<4; i++) {				sum = sum + neighbor[i][j] * vx[i] * vy[j];			}		}		return sum;	}	static public double getSampleCubicSpline(double x, double y, float neighbor[][]) {		double vx[]=getCubicSpline(x);		double vy[]=getCubicSpline(y);				float sum = 0;		for (int j=0; j<4; j++) {			for (int i=0; i<4; i++) {				sum = sum + neighbor[i][j] * (float)vx[i] * (float)vy[j];			}		}		return sum;	}	/**	* Computes the cubic spline basis function at a position t.	*	* @param	t argument between 0 and 1.	* @return	4 sampled values of the cubic B-spline 	*			(B3[t+1], B3[t], B3[t-1], B3[t-2]).	*/		static private double[] getCubicSpline(double t) {		double v[] = new double[4];				if (t < 0.0 || t > 1.0) {			throw new ArrayStoreException(				"Argument t for cubic B-spline outside of expected range."); 		}				double t1 = 1.0 - t;		double t2 = t * t;		v[0] = (t1 * t1 * t1) / 6.0;		v[1] = (2.0 / 3.0) + 0.5 * t2 * (t-2.0);		v[3] = (t2 * t) / 6.0;		v[2] = 1.0 - v[3] - v[1] - v[0];		return v;	}	/**	* Computes cubic spline coefficients of an image.	*/	static public ImageAccess computeCubicSplineCoeffients(ImageAccess input) {		int nx = input.getWidth();		int ny = input.getHeight();				ImageAccess output = new ImageAccess(nx,ny,ImageAccess.FLOAT);		double	c0 = 6.0;		double	a = Math.sqrt(3.0) - 2.0;				double rowin[]  = new double[nx];		double rowout[]  = new double[nx];		for (int y=0; y<ny; y++) {			input.getRow(y, rowin);			doSymmetricalExponentialFilter(rowin, rowout, c0, a);			output.putRow(y, rowout);		}		double colin[]  = new double[ny];		double colout[]  = new double[ny];		for (int x=0; x<nx; x++) {			output.getColumn(x, colin);			doSymmetricalExponentialFilter(colin, colout, c0, a);			output.putColumn(x, colout);		}		return output;	}		/**	* Computes quadratic spline coefficients of an image.	*//*	static public ImageAccess computeQuadraticSplineCoeffients(ImageAccess input) {		int nx = input.getWidth();		int ny = input.getHeight();				ImageAccess output = new ImageAccess(nx, ny);		double	c0 = 8.0;		double	a = 2*Math.sqrt(2.0) - 3.0;				double rowin[]  = new double[nx];		double rowout[]  = new double[nx];		for (int y=0; y<ny; y++) {			input.getRow(y, rowin);			doSymmetricalExponentialFilter(rowin, rowout, c0, a);			output.putRow(y, rowout);		}		double colin[]  = new double[ny];		double colout[]  = new double[ny];		for (int x=0; x<nx; x++) {			output.getColumn(x, colin);			doSymmetricalExponentialFilter(colin, colout, c0, a);			output.putColumn(x, colout);		}		return output;	}*/	/**	* Performs the 1D symmetrical exponential filtering.	*/	static private void doSymmetricalExponentialFilter(		double s[], double c[], double c0, double a) {		int n = s.length;		double cn[]  = new double[n];		double cp[]  = new double[n];				// causal		cp[0] = computeInitialValueCausal(s, a);				for(int k=1;k<n;k++){			cp[k]=s[k]+a*cp[k-1];		}		// 		// Add your code here		//					// anticausal		cn[n-1] = computeInitialValueAntiCausal(cp, a);		for(int k=n-2;k>=0;k--){			cn[k]=a*(-cp[k]+cn[k+1]);		}				for(int k=0;k<n;k++){			c[k]=cn[k]*c0;		}				// 		// Add your code here		//	}	/**	* Returns the initial value for the causal filter 	* using the mirror boundary conditions.	*/	static private double computeInitialValueCausal(		double signal[], double a) {		double epsilon = 1e-6; // desired level of precision		int k0 = (int)Math.ceil(Math.log(epsilon) / Math.log(Math.abs(a)));		double polek = a;		double v = signal[0];				for (int k=1; k<k0; k++) {			v = v + polek * signal[k];			polek = polek * a;		}		return v;	}	/**	* Returns the initial value for the anti-causal filter using 	* the mirror boundary conditions.	*/	static private double computeInitialValueAntiCausal(double signal[], double a) {		int n = signal.length;		double v = (a / (a * a - 1.0)) * (signal[n-1] + a * signal[n-2]);		return v;	}					} // end of class
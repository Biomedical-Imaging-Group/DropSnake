/*====================================================================| DropSnake Version: March 22, 2005\===================================================================*//*====================================================================| EPFL/STI/IOA/BIG| Aurï¿½lien Stalder| aurelien.stalder@gmail.com|\===================================================================*/// Based on the plugin SplineSnake by Mathews Jacob; Version: March 1, 2003// This class is responsible for the spline representing the drop.// It is based on a cubic spline with phantoms border conditions.// Extension by symmetry is made in order to correspond to reflected drop profilepackage dropsnake;import ij.plugin.PlugIn;import ij.process.*;import java.awt.*;import java.awt.event.*;import java.io.*;import java.util.*;import java.lang.*;import ij.*;public class Curve extends Object{			public int   Npoints;				// number of input points	public int   npoints;				// number of input points	public int   nknots;				// number of knots		public int   Nsamples;				// number of samples between two input points	public int   Degree;				// order of the B-Spline to use for the curve		public int   NCurvepts;				// number of points in the curve		public boolean   Curvelooping;		// is the curve looping		public double CoeffX[];				// X coefficients	public double CoeffY[];				// Y coefficients		private double CoeffXtemp[]=new double[5];				// X coefficients	private double CoeffYtemp[]=new double[5];				// Y coefficients	public double CoeffXsym[];  	//without reflection	public double CoeffYsym[];	public double CurveX[];				// X points of the curve	public double CurveY[];				// Y points of the curve	public double CurveDiffX[];	public double CurveDiffY[];	public double CurveDDiffX[];	public double CurveDDiffY[];		public double CurveXup[];				// X points of the curve	public double CurveYup[];				// Y points of the curve	public double CurveDiffXup[];	public double CurveDiffYup[];	public double CurveDDiffXup[];	public double CurveDDiffYup[];		public double CurveXdown[];				// X points of the curve	public double CurveYdown[];				// Y points of the curve	public double CurveDiffXdown[];	public double CurveDiffYdown[];	public double CurveDDiffXdown[];	public double CurveDDiffYdown[];		public double Area;					// the area in the curve	public double integralInCurve;		// the integral in the curve	public int signarea;	public double Length;		public double Xpoints[];			// array with the X coord of the input points	public double Ypoints[];			// array with the Y coord of the input points		public double SplineValues[];	public double SplineDifferentials[];	public double SplineDDifferentials[];	private BsplineTransform bspline = new BsplineTransform(BsplineTransform.ANTIMIRRORONBOUNDS);		public double xa,ya,xb,yb,nx,ny;	//AS	private double a;		boolean reflection;	public double CArad[] = new double[2];	public double CA[] = new double[2];	public int ncurvepts;	public double lengthNormal;	public double surface,rc;			public double alpha;	private double radToDeg = 180.0/Math.PI;	double[] Kernel = {0 ,-1.3888889e-03 ,-7.7777778e-02 ,-3.4027778e-01  ,1.1102230e-16 , 3.4027778e-01 ,  7.7777778e-02  , 1.3888889e-03  , 0};		public double yapex, xapex;	public int iapex;	public int kmin,kmax;		//correspond to the coefficient following the smallest and biggest interknot interval	boolean Laplace=false;	int Origin = 4;	public int imax, imin;	public double distInterface;	/* ---------------------------------------------------------------------------------------- *//*	Constructor                                                                         	*//*	Purpose:	Initializes the Curve parameters											*//* 																							*//*  @arguments:	npoints			 - the number of input points								*//*				nsamples	  	 - number of samples between two input points				*//*				xpoints, ypoints - arrays with the x and y coordinates of the input points	*//*				degree			 - the order of the splines to use							*//* ---------------------------------------------------------------------------------------- */public  Curve(int nknots,int nsamples, double[] xpoints, double[] ypoints, int degree, boolean firstcurve) 	{		int i,j;		String n;		String x;		String y;		this.npoints=nknots+2;		//	IJ.write("npoints" +npoints);		Nsamples = nsamples;		Degree = degree;		updateN();				Xpoints = new double[nknots];		Ypoints = new double[nknots];				CoeffX  = new double[npoints];		CoeffY  = new double[npoints];		CoeffXsym  = new double[npoints];		CoeffYsym  = new double[npoints];								SplineValues = new double[4*Nsamples+1];		SplineDifferentials = new double[4*Nsamples+1];		SplineDDifferentials = new double[4*Nsamples+1];									/* Loading with the Spline values, increasing Sequence.*//*-----------------------------------------------------*/	j = 0;		for (i=-2*Nsamples;i<=2*Nsamples;i++)			{			  SplineValues[j++] = BSpline((double)i/(double)Nsamples,degree);		}						/* Loading with the Spline Differential values, increasing Sequence.*//*------------------------------------------------------------------*/			j= 0;			for (i=-2*Nsamples;i<=2*Nsamples;i++)				{				SplineDifferentials[j] 	   = BSpline(((double)i/(double)Nsamples)+0.5,degree-1);				SplineDifferentials[j]    -= BSpline(((double)i/(double)Nsamples)-0.5,degree-1);				j++;			}						/* Loading with the Spline 2nd differential values, increasing Sequence.*/	/*----------------------------------------------------------------------*/		j= 0;		for (i=-2*Nsamples;i<=2*Nsamples;i++)				{				SplineDDifferentials[j]    = BSpline(((double)i/(double)Nsamples)+1.0,degree-2);				SplineDDifferentials[j]   -= 2*BSpline((double)i/(double)Nsamples,degree-2);				SplineDDifferentials[j]  += BSpline(((double)i/(double)Nsamples)-1.0,degree-2);				j++;			}	/* Finding the Interpolation Coefficients.*/	/*----------------------------------------*/		for (i = 0; i < nknots; i++)			{				Xpoints[i] = xpoints[i];				Ypoints[i] = ypoints[i];			}		if(firstcurve){						GetInterpolation();		}								for (i=0;i<nknots;i++)				{				CoeffX[i+1] = Xpoints[i];				CoeffY[i+1] = Ypoints[i];			}				CoeffX[0] = 2*CoeffX[1]-CoeffX[2];		CoeffY[0] = 2*CoeffY[1]-CoeffY[2];		CoeffX[npoints-1] = 2*CoeffX[npoints-2]-CoeffX[npoints-3];		CoeffY[npoints-1] = 2*CoeffY[npoints-2]-CoeffY[npoints-3];							ComputeAll();										}/* ------------------------------------------------------------------------------------	*//*	Function:	updateCurve During optimisation																*//*	Purpose:	update the curve with the new coefficients								*//* ------------------------------------------------------------------------------------	*/public void updateCurve(double[] CX, double[] CY) 	{		int i;			for (i=1;i<npoints-1;i++)				{				CoeffX[i] = CX[i];				CoeffY[i] = CY[i];			}		CoeffX[0] = 2*CoeffX[1]-CoeffX[2];;		CoeffY[0] = 2*CoeffY[1]-CoeffY[2];		CoeffX[npoints-1] = 2*CoeffX[npoints-2]-CoeffX[npoints-3];		CoeffY[npoints-1] = 2*CoeffY[npoints-2]-CoeffY[npoints-3];				//impose horizontal symmetricity!!!!!	//	CoeffYtemp[0] = 0.5*(CY[0]+CY[npoints-1]);	//	CoeffYtemp[npoints-1] = 0.5*(CY[0]+CY[npoints-1]);					ComputeAll();	}/* ------------------------------------------------------------------------------------	*//*	Function:	BSpline																	*//*	Purpose:	calculates B-Spline polynomial											*//* ------------------------------------------------------------------------------------	*/public double BSpline(double x, int degree) 	{			double	BSplineValue;		x = Math.abs(x);		if (degree == 0)			{				if(x<0.5)	BSplineValue=1.0;				else	BSplineValue=(double)(0.0);			}		else if (degree==1)			{				if(x<1.0)	BSplineValue=1.0-Math.abs(x);				else 	BSplineValue=(double)(0.0);			}		else if (degree==2)			{				if(x<0.5 )				BSplineValue=(3.0/4.0)-x*x;				else if(x<1.5) 			{ x -= 1.5; BSplineValue=x*x/2.0; }				else 					BSplineValue=0.0;			}			else if (degree==3)			{				if(x<1.0)					BSplineValue=(x*x*(x-2.0)*(1.0/2.0)+2.0/3.0);				else if(x<2.0) 				{ x -= 2; BSplineValue=(x*x*x*(-1.0/6.0)); }					else 						BSplineValue=0.0;			}		else 			{				BSplineValue = 0.0;				IJ.error("Bspline with this order not supported: Sorry");			}		return(BSplineValue);	}public void ComputeAll (){		initSymmetry();	symmetryTransform();		CurveX  = new double[NCurvepts];	CurveY  = new double[NCurvepts];	CurveDiffX  = new double[NCurvepts];	CurveDiffY  = new double[NCurvepts];	CurveDDiffX  = new double[NCurvepts];	CurveDDiffY  = new double[NCurvepts];		CurveXup  = new double[ncurvepts];	CurveYup  = new double[ncurvepts];	CurveDiffXup  = new double[ncurvepts];	CurveDiffYup  = new double[ncurvepts];	CurveDDiffXup  = new double[ncurvepts];	CurveDDiffYup  = new double[ncurvepts];		CurveXdown  = new double[ncurvepts];	CurveYdown  = new double[ncurvepts];	CurveDiffXdown  = new double[ncurvepts];	CurveDiffYdown  = new double[ncurvepts];	CurveDDiffXdown  = new double[ncurvepts];	CurveDDiffYdown  = new double[ncurvepts];		ComputeCurve (SplineValues, CurveXup, CurveYup, CoeffX, CoeffY);	ComputeCurve (SplineDifferentials, CurveDiffXup, CurveDiffYup, CoeffX, CoeffY);	ComputeCurve (SplineDDifferentials, CurveDDiffXup, CurveDDiffYup, CoeffX, CoeffY);		ComputeCurve (SplineValues, CurveXdown, CurveYdown, CoeffXsym, CoeffYsym);	ComputeCurve (SplineDifferentials, CurveDiffXdown, CurveDiffYdown, CoeffXsym, CoeffYsym);	ComputeCurve (SplineDDifferentials, CurveDDiffXdown, CurveDDiffYdown, CoeffXsym, CoeffYsym);		CurveX = new double[NCurvepts];	CurveY = new double[NCurvepts];		for(int i=0 ; i<ncurvepts; i++){		CurveX[i]= CurveXup[i];		CurveX[i+ncurvepts]= CurveXdown[i];		CurveY[i]= CurveYup[i];		CurveY[i+ncurvepts]= CurveYdown[i];				CurveDiffX[i]= CurveDiffXup[i];		CurveDiffX[i+ncurvepts]= CurveDiffXdown[i];		CurveDiffY[i]= CurveDiffYup[i];		CurveDiffY[i+ncurvepts]= CurveDiffYdown[i];		CurveDDiffX[i]= CurveDDiffXup[i];		CurveDDiffX[i+ncurvepts]= CurveDDiffXdown[i];		CurveDDiffY[i]= CurveDDiffYup[i];		CurveDDiffY[i+ncurvepts]= CurveDDiffYdown[i];					}			ComputeCA();	ComputeArea();		Curvelooping = Check_for_Curve_looping();	distInterface();		}/* ------------------------------------------------------------------------------------	*//*	Function:	ComputeCurve															*//*	Purpose:	calculates the Curve with the give the cubic spline coefficients		*//*  Inputs : Coeff - Spline coefficients												*//*			 Splinevalues - Values of spline functions 									*//*			 Nsamples	  - Resampling rate												*//* ------------------------------------------------------------------------------------	*/public void ComputeCurve (double[] Splinebuffer,double[] Curvex, double[] Curvey, double[] Cx,double[] Cy){ int a; int i; int j; double temp;	a = -1;	/*********************************************//* Evaluating the Curve						 *//*********************************************/				for(i=0; i < ncurvepts;i++)		{			Curvex[i] = 0.0;				Curvey[i] = 0.0;			if((i%Nsamples)==0L) a+= 1;			for(j=-1;j<3;j+=1)				{					temp = Splinebuffer[i-(a+j)*Nsamples + 2*Nsamples];					Curvex[i]+=Cx[a+j+1]*temp;					Curvey[i]+=Cy[a+j+1]*temp;					}					}}	// ------------------------------------------------------------------------------------	//	Function:	addKnot													//	Purpose:	Adds a knot in the longest interval									// ------------------------------------------------------------------------------------	// DOESN'T WORK FINE, NOT USED!!public void addKnotReparametrize(){		double intervallength;	int currentsample=0;	int longest_interval=0;			longest_interval=imax-1;				// Adding the knot	Xpoints = new double[nknots+1];	Ypoints = new double[nknots+1];		int Nsnew = (int) (Nsamples * (double)nknots / (double)(nknots+1) +0.5);	for(int i = 0; i<nknots;i++)		{			currentsample = (i)*Nsnew;			Xpoints[i] = CurveX[currentsample];			Ypoints[i] = CurveY[currentsample];		}	Xpoints[nknots] = CurveX[ncurvepts];	Ypoints[nknots] = CurveY[ncurvepts];	//	IJ.write("new add: " );//	for(int i=0; i<npoints; i++) IJ.write(" CoeffX[i] " +CoeffX[i] +" " +CoeffY[i] +" i " +i);//	IJ.write("point added: " +longest_interval);	npoints++;	updateN();		GetInterpolation();				CoeffX  = new double[npoints];	CoeffY  = new double[npoints];				for (int i=0;i<nknots;i++)			{			CoeffX[i+1] = Xpoints[i];			CoeffY[i+1] = Ypoints[i];		}	CoeffX[0] = 2*CoeffX[1]-CoeffX[2];	CoeffY[0] = 2*CoeffY[1]-CoeffY[2];	CoeffX[npoints-1] = 2*CoeffX[npoints-2]-CoeffX[npoints-3];	CoeffY[npoints-1] = 2*CoeffY[npoints-2]-CoeffY[npoints-3];//	for(int i=0; i<npoints; i++) IJ.write(" CoeffX[i] " +CoeffX[i] +" " +CoeffY[i] +" i " +i);		ComputeAll();		//IJ.error("one knot added");}public void addKnot(){		double intervallength;	int currentsample=0;	int longest_interval=0;			longest_interval=imax-1;				// Adding the knot	Xpoints = new double[nknots+1];	Ypoints = new double[nknots+1];		for(int i = 0; i<=longest_interval;i++)		{			currentsample = (i)*Nsamples;			Xpoints[i] = CurveX[currentsample];			Ypoints[i] = CurveY[currentsample];		}	currentsample = (longest_interval)*Nsamples +Nsamples/2;	Xpoints[longest_interval+1]= CurveX[currentsample];	Ypoints[longest_interval+1]= CurveY[currentsample];			for(int i = longest_interval+1; i<nknots;i++)		{			currentsample = (i)*Nsamples;			Xpoints[i+1] = CurveX[currentsample];			Ypoints[i+1] = CurveY[currentsample];		}	//	IJ.write("new add: " );//	for(int i=0; i<npoints; i++) IJ.write(" CoeffX[i] " +CoeffX[i] +" " +CoeffY[i] +" i " +i);//	IJ.write("point added: " +longest_interval);	npoints++;	updateN();		GetInterpolation();				CoeffX  = new double[npoints];	CoeffY  = new double[npoints];				for (int i=0;i<nknots;i++)			{			CoeffX[i+1] = Xpoints[i];			CoeffY[i+1] = Ypoints[i];		}	CoeffX[0] = 2*CoeffX[1]-CoeffX[2];	CoeffY[0] = 2*CoeffY[1]-CoeffY[2];	CoeffX[npoints-1] = 2*CoeffX[npoints-2]-CoeffX[npoints-3];	CoeffY[npoints-1] = 2*CoeffY[npoints-2]-CoeffY[npoints-3];//	for(int i=0; i<npoints; i++) IJ.write(" CoeffX[i] " +CoeffX[i] +" " +CoeffY[i] +" i " +i);		ComputeAll();		//IJ.error("one knot added");}// ------------------------------------------------------------------------------------	//	Function:	addKnot													//	Purpose:	Adds a knot in the longest interval									// ------------------------------------------------------------------------------------	public void deleteKnot(){		double intervallength;	int currentsample=0;	int shortest_interval=0;	double shortest_length=1000000.0;		double[] length = new double[Npoints];			shortest_interval=imin;		//if(shortest_interval == npoints-3) shortest_interval = npoints-4;	if(shortest_interval == 1) shortest_interval = 2;	CoeffXtemp = new double[npoints];	CoeffYtemp  = new double[npoints];		for (int i=0;i<npoints;i++)				{				CoeffXtemp[i] = CoeffX[i];				CoeffYtemp[i] = CoeffY[i];			}	CoeffX  = new double[npoints-1];	CoeffY  = new double[npoints-1];	for(int i = 0; i<=shortest_interval-1;i++)		{			CoeffX[i] = CoeffXtemp[i];			CoeffY[i] = CoeffYtemp[i];		}		for(int i = shortest_interval+1; i<npoints;i++)		{			CoeffX[i-1] = CoeffXtemp[i];			CoeffY[i-1] = CoeffYtemp[i];		}				npoints --;	updateN();				ComputeAll();		}// ------------------------------------------------------------------------------------	//	Function:	setNsamples													//	Purpose:	Change the resampling rate to accomodate the increase/decrease in length									// ------------------------------------------------------------------------------------	public void setNsamples(int newsamplingrate){		Nsamples = newsamplingrate;	updateN();		SplineValues = new double[4*Nsamples+1];	SplineDifferentials = new double[4*Nsamples+1];	SplineDDifferentials = new double[4*Nsamples+1];		/* Loading with the Spline values, increasing Sequence.*/	/*-----------------------------------------------------*/		int j = 0;			for (int i=-2*Nsamples;i<=2*Nsamples;i++)				{				  SplineValues[j++] = BSpline((double)i/(double)Nsamples,Degree);			}					/* Loading with the Spline Differential values, increasing Sequence.*/	/*------------------------------------------------------------------*/					j= 0;				for (int i=-2*Nsamples;i<=2*Nsamples;i++)					{					SplineDifferentials[j] 	   = BSpline(((double)i/(double)Nsamples)+0.5,Degree-1);					SplineDifferentials[j]    -= BSpline(((double)i/(double)Nsamples)-0.5,Degree-1);					j++;				}					/* Loading with the Spline 2nd differential values, increasing Sequence.*/		/*----------------------------------------------------------------------*/			j= 0;			for (int i=-2*Nsamples;i<=2*Nsamples;i++)					{					SplineDDifferentials[j]    = BSpline(((double)i/(double)Nsamples)+1.0,Degree-2);					SplineDDifferentials[j]   -= 2*BSpline((double)i/(double)Nsamples,Degree-2);					SplineDDifferentials[j]  += BSpline(((double)i/(double)Nsamples)-1.0,Degree-2);					j++;				}								ComputeAll();}// ------------------------------------------------------------------------------------	//	Function:	resamples													//	Purpose:	Adjust the knot number considering the knot distance and knot ratio (gamma) specified//// -------------------------------------------------------------------------------- ----	public void resample(double knotDist, double gamma){			double denominator, avgKnotDist, knotRatio;	int oldnknots, currentsample;		oldnknots=nknots;		avgKnotDist = knotDist/(1-gamma);		nknots = (int)(lengthNormal/avgKnotDist+0.5)+1;	knotRatio=(double)(oldnknots-1.0)/(double)(nknots-1.0);			Xpoints = new double[nknots];	Ypoints = new double[nknots];		for(int i = 0;i<nknots;i++)		{			currentsample = (int)((double)(i)*(double)Nsamples*knotRatio+0.5);			Xpoints[i] = CurveX[currentsample];			Ypoints[i] = CurveY[currentsample];		}	Xpoints[nknots-1] = CurveX[ncurvepts];	Ypoints[nknots-1] = CurveY[ncurvepts];	npoints=nknots+2;	updateN();		GetInterpolation();		CoeffX  = new double[npoints];	CoeffY  = new double[npoints];				for (int i=0;i<nknots;i++)			{			CoeffX[i+1] = Xpoints[i];			CoeffY[i+1] = Ypoints[i];		}	CoeffX[0] = 2*CoeffX[1]-CoeffX[2];	CoeffY[0] = 2*CoeffY[1]-CoeffY[2];	CoeffX[npoints-1] = 2*CoeffX[npoints-2]-CoeffX[npoints-3];	CoeffY[npoints-1] = 2*CoeffY[npoints-2]-CoeffY[npoints-3];	ComputeAll();}// ------------------------------------------------------------------------------------	//	Function:	Check_for_Curve_looping													//	Purpose:	Checks whether the curve is looping or not									// ------------------------------------------------------------------------------------	//Modified by AS//check for the upper part of the drop, if the total angle excesses 2*pi then it is looping//compute the length, and the coordinates of the apexpublic boolean  Check_for_Curve_looping(){		double checksum = 0;	int   i;	boolean looping;	double denominator;			yapex=5000.0;	lengthNormal=0.0;						//Check for loop at the interface	for(i=2;i<npoints-2;i++){		if(CoeffY[i]>CoeffYsym[symIndex(i)]) {			//IJ.write("loop at interface");			return true;		}	}		// check = (DX*DDY - DY*DDX)/(X*X+Y*Y) 	for(i=0;i<ncurvepts;i++) {											denominator=((CurveDiffX[i]*CurveDiffX[i] + CurveDiffY[i]*CurveDiffY[i]));		if(denominator!=0.0) checksum += (CurveDiffX[i]*CurveDDiffY[i] - CurveDiffY[i]*CurveDDiffX[i])/denominator;				lengthNormal+=Math.sqrt(denominator);		if(CurveY[i] < yapex) { yapex=CurveY[i]; iapex=i; }		}	lengthNormal/=Nsamples;		checksum = Math.abs(checksum)/(Nsamples) /*+2*Math.PI*/-CArad[0]-CArad[1];			xapex=CurveX[iapex];							/*If Curve found looping */	if ((Math.abs(checksum)) >= 0.2) 			{									looping = true;		}		else		{			looping = false;		}	return(looping);	}private void distInterface(){	double distInterfaceLeft,distInterfaceRight;	distInterfaceLeft=computeSegmentLength(1,2);	distInterfaceRight=computeSegmentLength(npoints-3,npoints-2);		distInterface = 0.5*(distInterfaceLeft + distInterfaceRight);}public double  computeSegmentLength(int start, int end){	double length=0.0;	double denominator;				start = (start-1)*Nsamples;	end = (end-1)*Nsamples;	for(int i=start;i<end;i++) {									denominator=((CurveDiffX[i]*CurveDiffX[i] + CurveDiffY[i]*CurveDiffY[i]));		length+=Math.sqrt(denominator);	}	length/=Nsamples;		return length;}// ------------------------------------------------------------------------------------	//	Function:	ComputeArea												//	Purpose:	Compute the area enclosed by the curve								// ------------------------------------------------------------------------------------			public double ComputeArea() {				double area=0.0;				for(int i=0; i<NCurvepts; i++){			area += CurveY[i]*CurveDiffX[i];						}				area=-area/Nsamples;		signarea = (area>0 ? 1 : -1);		Area = Math.abs(area);			 	return area;	}				public double ComputeAreaold() {		int j,k;		double sum;		double area=0.0;		double[] CX = new double[CoeffX.length+1];		double[] CY = new double[CoeffY.length+1];				for (j=0;j<npoints;j++)			{				CX[j] = CoeffX[j];				CY[j] = CoeffY[j];			}		CX[npoints] = CoeffX[0];		CY[npoints] = CoeffY[0];								 for (j=0;j<npoints;j++) 			 	{     			 		sum = 0;				 	for (k=0;k<Origin-j;k++) sum     += CX[npoints-(Origin-j-k)%npoints] * Kernel[k];		 	 		for (k= ((Origin>j)? Origin-j:0) ;k<2*Origin+1;k++) sum += CX[(j+k-Origin)%npoints]* Kernel[k];			 	 		area += CY[j]*sum;	 			}	 	signarea = (area>0 ? 1 : -1);		Area = Math.abs(area);			 	return area;	}			public double getAreaInCurve() {		return Area;	}	// ------------------------------------------------------------------------------------	//	Function:	getClosestPointOnCurve		Used by dirderivatives												//	Purpose:	return the parameter corresponding to the point on the curve closest//              to a given point (x,y)								// ------------------------------------------------------------------------------------		public int getClosestPointOnCurve(double x, double y) {			//int ncurvepts = (npoints-1)*Nsamples;		double distance;		int parameter = 0;		double currentdistance = (x-CurveX[0])* (x-CurveX[0]) + (y-CurveY[0])* (y-CurveY[0]);		for(int i=1; i<NCurvepts; i++)			{			  distance = (x-CurveX[i])* (x-CurveX[i]) + (y-CurveY[i])* (y-CurveY[i]);			  if(distance < currentdistance)			  	{			  		currentdistance = distance;			  		parameter = i;			  	}			}		return parameter;	}		//modify CurveX, CurveY, CoeffX, CoeffYprivate void symmetryTransform() {								CoeffXsym  = new double[npoints];		CoeffYsym  = new double[npoints];		double xs[]=new double[2];					for(int i=0; i<npoints; i++) {						xs=symmetry(CoeffX[npoints-1-i],CoeffY[npoints-1-i]);			CoeffXsym[i] = xs[0];			CoeffYsym[i] = xs[1];			//IJ.write("CoeffX[i] +CoeffY[i]" +CoeffX[i] +" " +CoeffY[i] +"CoeffX[i+Npoints] +CoeffY[i+Npoints]" +CoeffX[i+Npoints] +" " +CoeffY[i+Npoints]);		}					} 		public int symIndex(int i) {		return npoints-1-i;		}				private void initSymmetry(){			double norm;		xa = CoeffX[1];		ya = CoeffY[1];		xb = CoeffX[npoints-2];		yb = CoeffY[npoints-2];		norm = Math.sqrt((yb-ya)*(yb-ya) + (xb-xa)*(xb-xa));		nx = -(yb-ya)/norm;		ny = (xb-xa)/norm;				alpha = Math.atan(nx/ny);		a = (yb-ya)/(xb-xa);	}		public boolean CheckSymLooping(double x, double y) {				if( ((y-ya)/(x-xa)) > a) return true;		else return false;	}			public double[] symmetry(double x, double y){		double xs[]=new double[2];		double delta = -2 * (nx*(x-xb) + ny*(y-yb));					xs[0] = x + delta * nx;		xs[1] = y + delta * ny;			return xs;			}	// ------------------------------------------------------------------------------------	//	Function:	updateN//	Purpose:	update the knot number and sample number from the value of npoints//              // ------------------------------------------------------------------------------------		private void updateN(){				Npoints=2*(npoints);	//no more sens				nknots=npoints-2;		ncurvepts = (npoints-3)*Nsamples;		NCurvepts = 2*ncurvepts;		}		private void ComputeCA() {				//the derivative at the triple knot points is not defined 		//CArad for display purposes -> referenced to horizontal		CArad[0] = -Math.atan2(CurveDiffY[0],CurveDiffX[0]); 		CArad[1] = Math.atan2(CurveDiffY[ncurvepts-1],CurveDiffX[ncurvepts-1]); 				//CA are CA angles in degree for numerical display -> correction due to non horizontal interface		CA[0] = radToDeg*(CArad[0]-alpha); 		CA[1] = radToDeg*(CArad[1]+alpha); 		}// ------------------------------------------------------------------------------------	//	Function:	GetInterpolation()//	Purpose:	compute the control points from the knots coordinates//	input: Xpoints, Ypoints//	output: Xpoints, Ypoints//              // ------------------------------------------------------------------------------------		private void GetInterpolation() {		bspline.getInterpolationCoefficients(Xpoints, Degree);		bspline.getInterpolationCoefficients(Ypoints, Degree);			}		// ------------------------------------------------------------------------------------	//	Function:	computeVS//	Purpose:	compute the surfaces and length from the meridian profile//              // ------------------------------------------------------------------------------------			public void computeVS() {				double M=0.0, Mx=0.0, My=0.0;		double Mh=0.0, Mxh=0.0, Myh=0.0;		double Xmass, Ymass;		double Xmassh, Ymassh;		for(int i=0; i< NCurvepts; i++) {						M += CurveY[i]* CurveDiffX[i];			Mx += 0.5 * CurveY[i]* CurveY[i]* CurveDiffX[i];			My += CurveY[i]* CurveX[i]* CurveDiffX[i];		}				M /= Nsamples;		Mx /= Nsamples;		My /= Nsamples;				surface=0.5*Math.abs(M);		Xmass= My/M;		Ymass= Mx/M;				/*		for(int i=1; i< NCurvepts; i++) {			//takes only the right half of the drop now			if(CurveX[i]+CurveX[NCurvepts-i] > Xmass) {				Mh += CurveY[i]* CurveDiffX[i];				Mxh += 0.5 * CurveY[i]* CurveY[i]* CurveDiffX[i];				Myh += CurveY[i]* Math.abs(CurveX[i]-Xmass)* CurveDiffX[i];								//Myh += Math.abs(0.5*(CurveX[i]+CurveX[NCurvepts-i])-Xmass)				//* (Math.sqrt(				//	(CurveX[i]-CurveX[NCurvepts-i])*(CurveX[i]-CurveX[NCurvepts-i])				//	+(CurveY[i]-CurveY[NCurvepts-i])*(CurveY[i]-CurveY[NCurvepts-i]));			}		}						Mh /= Nsamples;		Mxh /= Nsamples;		Myh /= Nsamples;				Xmassh= Myh/Mh;		Ymassh= Mxh/Mh;		*/		//IJ.write("surface length " +surface +" " +lengthNormal);				//IJ.write("xmass ymass " +Xmass +" " +Ymass);		//IJ.write("xmass ymassh " +Xmassh +" " +Ymassh);				rc = 0.5*Math.abs(CurveX[0]-CurveX[ncurvepts]); 		}	}
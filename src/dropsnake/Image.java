/*====================================================================| DropSnake Version: March 22, 2005\===================================================================*//*====================================================================| EPFL/STI/IOA/BIG| AurŽlien Stalder| aurelien.stalder@gmail.com|\===================================================================*/package dropsnake;// Based on the plugin SplineSnake by Mathews Jacob; Version: March 1, 2003import ij.plugin.PlugIn;import ij.process.*;import java.awt.*;import java.awt.event.*;import java.io.*;import java.util.*;import java.lang.*;import ij.*;public class Image extends Object{		public double mu1, mu2;					// mean inside and outside the curve	public double sigma1, sigma2;			// mean inside and outside the curve	public double totArea;					// total area of the image			public ImageAccess rawImage; 			// input image	public ImageAccess preprocessedImage;	// the preprocessed image	public ImageAccess preprocessedCoeff;	// the preprocessed cubic coefficients image		public ImageAccess sqrImage;	private ImageAccess normalizedImage;	// the preprocessed normalized image	private ImageAccess laplacianimg;		// laplacian image	private ImageAccess laplacianimg_norm;	// laplacian normalized image	private ImageAccess intimage;			// the integrated along x image	private ImageAccess intSqrimage;		// the integrated along x image		private SplineSnakePreferences parameter;	private int signarea;					// the sign of the area	private double weight;	Convolver convolver = new Convolver(Convolver.MIRROR);					int nx;									// width of the image	int ny;									// height of the image//-------------// Constructor//-------------	public Image(ImagePlus imp, Curve snake_curve, SplineSnakePreferences param) 			{		  	parameter = param;		  	double[] xpoints = snake_curve.Xpoints;	// input x points			double[] ypoints = snake_curve.Ypoints;	// input y points			int nsamples = snake_curve.Nsamples;	// number of samples between two points			this.weight = parameter.SnakeWeight;						// Input ImagePlus -> ImageAccess conversion			//imp.getProcessor extracts the current slice of the stack in imp			ImageAccess rawImage0 = new ImageAccess(imp.getProcessor()); 						nx = rawImage0.getWidth();			ny = rawImage0.getHeight();									rawImage = new ImageAccess(nx, ny, ImageAccess.FLOAT);			rawImage.copy(rawImage0);						sqrImage = new ImageAccess(nx, ny, ImageAccess.FLOAT);			sqrImage.copy(rawImage);			sqrImage.multiply(rawImage);						intSqrimage = new ImageAccess(nx, ny, ImageAccess.FLOAT);						// conversion end			signarea = snake_curve.signarea;									intimage = integrate_along_x(rawImage);						if(param.means)				{					est_means(snake_curve, nx, ny); //mu1, mu2 and signarea are calculated					preprocessedImage = transformImageMean(mu1, mu2);				}			else				{					est_meansAndVariance(snake_curve, nx, ny);					preprocessedImage = transformImageVariance(mu1, mu2,sigma1,sigma2);				}			normalizedImage = normalizeImage(preprocessedImage,0.1,1);			laplacianimg = computeLaplacian(preprocessedImage, parameter.SnakeSigma) ;			laplacianimg_norm =  normalizeImage(laplacianimg,0.1,1);						// computing the final preprocessed image			normalizedImage.multiply(weight);			preprocessedImage.copy(normalizedImage);									laplacianimg_norm.multiply((weight-1));			preprocessedImage.add(laplacianimg_norm);// here is the final preprocessed image		//	preprocessedImage.add(laplacianimg_norm);			preprocessedCoeff=new ImageAccess(nx,ny, ImageAccess.FLOAT);			preprocessedCoeff = Interpolation.computeCubicSplineCoeffients(preprocessedImage);					}			/*---------	/ Methods	---------*/	public void scaleWeight (double scale){	weight *= scale;}	//------------------------------------------------------------------------------// giveUpdatedimage: Return a new preprocessed image depending on the new curve//------------------------------------------------------------------------------public void giveUpdatedimage(Curve snake_curve) 			{			double startTime = System.currentTimeMillis();				  	signarea = snake_curve.signarea;			if(parameter.means)				{					est_means(snake_curve, nx, ny); //mu1, mu2 and signarea are calculated					preprocessedImage = transformImageMean(mu1, mu2);				}			else				{					est_meansAndVariance(snake_curve, nx, ny);					preprocessedImage = transformImageVariance(mu1, mu2,sigma1,sigma2);				}						normalizedImage = normalizeImage(preprocessedImage,0.1,1);						laplacianimg = computeLaplacian(preprocessedImage, parameter.SnakeSigma) ;			laplacianimg_norm =  normalizeImage(laplacianimg,0.1,1);			preprocessedImage.copy(normalizedImage);			preprocessedImage.multiply(weight);			laplacianimg_norm.multiply(weight-1);			preprocessedImage.add(laplacianimg_norm);			preprocessedCoeff=new ImageAccess(nx,ny, ImageAccess.FLOAT);			preprocessedCoeff = Interpolation.computeCubicSplineCoeffients(preprocessedImage);			//if(parameter.demo)			//IJ.write("Preprocessed Image updated depending on current curve");		}		/**	* Sets the values of mu1, mu2 and signarea given an image and a curve	* 	* @inputs: 	rawImage - the input image	*			curve    - the curve around mu1	*/	public void est_meansAndVariance(Curve curve, int nx, int ny) {						double totIntegral = 0;		double totVariance = 0;				int minx = nx;		int miny = ny;		int maxx = 0;		int maxy = 0;		int deltax;		int deltay;				for(int i=0; i<curve.NCurvepts; i++) 			{				minx = (int)((minx>(int)curve.CurveX[i])? curve.CurveX[i]: minx);				miny = (int)((miny>(int)curve.CurveY[i])? curve.CurveY[i]: miny);								maxx = (int)((maxx<(int)curve.CurveX[i])? curve.CurveX[i]: maxx);				maxy = (int)((maxy<(int)curve.CurveY[i])? curve.CurveY[i]: maxy);			}				minx = minx - nx/10;		miny = miny - ny/10;				maxx = maxx + nx/10;		maxy = maxy + ny/10;						minx = (minx<0)? 0: (minx>=nx)? nx-1: minx;		miny = (miny<0)? 0: (miny>=ny)? ny-1: miny;		maxx = (maxx<0)? 0: (maxx>=nx)? nx-1: maxx;		maxy = (maxy<0)? 0: (maxy>=ny)? ny-1: maxy;						for(int y=miny; y<maxy; y++)		{			totIntegral += intimage.getPixel(maxx,y);		}		for(int y=miny; y<maxy; y++)		{			totIntegral -= intimage.getPixel(minx,y);			}		totArea = (maxx-minx)*(maxy-miny);		double integInCurve = computeIntegralincurve(curve, intimage);		curve.ComputeArea();				mu1 = integInCurve/curve.Area;		mu2 = (totIntegral-integInCurve)/(totArea-curve.Area);						double accumulate, temp;		for(int y=miny; y<maxy; y++)		{			accumulate = 0.0;			for(int x=minx; x<maxx; x++)				{					temp = rawImage.getPixel(x,y) - mu1;					accumulate += temp*temp;					intSqrimage.putPixel(x,y,accumulate);				}					}		double VarianceInCurve1 = computeIntegralincurve(curve, intSqrimage);				double TotalVariance = 0.0;		for(int y=miny; y<maxy; y++)		{			accumulate = 0.0;			for(int x=minx; x<maxx; x++)				{					temp = rawImage.getPixel(x,y) - mu2;					accumulate += temp*temp;					intSqrimage.putPixel(x,y,accumulate);				}			TotalVariance += accumulate;		}		double VarianceInCurve2 = computeIntegralincurve(curve, intSqrimage);						IJ.write("VarianceInCurve1 "+VarianceInCurve1+" VarianceInCurve2 "+VarianceInCurve2+" TotalVariance "+TotalVariance);		IJ.write("curve.Area "+curve.Area+" totArea "+totArea);				sigma1 = VarianceInCurve1/curve.Area;		sigma2 = (TotalVariance-VarianceInCurve2)/(totArea-curve.Area);						sigma1 = (sigma1<50)? 50:sigma1;			sigma2 = (sigma2<50)? 50:sigma2;			/*sigma1 = (sigma1<0)? -sigma1:sigma1;			sigma2 = (sigma2<0)? -sigma2:sigma2;		*/				IJ.write("sigma1 "+sigma1+" sigma2 "+sigma2);		IJ.write("mu1 "+mu1+" mu2 "+mu2);		if(parameter.demo)			{				IJ.write("sigma1 "+sigma1+" sigma2 "+sigma2);				IJ.write("mu1 "+mu1+" mu2 "+mu2);			}	}/**	* Sets the values of mu1, mu2 and signarea given an image and a curve	* 	* @inputs: 	rawImage - the input image	*			curve    - the curve around mu1	*/	public void est_means(Curve curve, int nx, int ny) {						double totIntegral = 0;		double totVariance = 0;				int minx = nx;		int miny = ny;		int maxx = 0;		int maxy = 0;		int deltax;		int deltay;				for(int i=0; i<curve.NCurvepts; i++) 			{				minx = (int)((minx>(int)curve.CurveX[i])? curve.CurveX[i]: minx);				miny = (int)((miny>(int)curve.CurveY[i])? curve.CurveY[i]: miny);								maxx = (int)((maxx<(int)curve.CurveX[i])? curve.CurveX[i]: maxx);				maxy = (int)((maxy<(int)curve.CurveY[i])? curve.CurveY[i]: maxy);			}				minx = minx - nx/10;		miny = miny - ny/10;				maxx = maxx + nx/10;		maxy = maxy + ny/10;						minx = (minx<0)? 0: (minx>=nx)? nx-1: minx;		miny = (miny<0)? 0: (miny>=ny)? ny-1: miny;		maxx = (maxx<0)? 0: (maxx>=nx)? nx-1: maxx;		maxy = (maxy<0)? 0: (maxy>=ny)? ny-1: maxy;						for(int y=miny; y<maxy; y++)		{			totIntegral += intimage.getPixel(maxx,y);		}		for(int y=miny; y<maxy; y++)		{			totIntegral -= intimage.getPixel(minx,y);			}		totArea = (maxx-minx)*(maxy-miny);		double integInCurve = computeIntegralincurve(curve, intimage);		curve.ComputeArea();				mu1 = integInCurve/curve.Area;		mu2 = (totIntegral-integInCurve)/(totArea-curve.Area);			}	/**	* Computes the integral of the image in the curve	* 	* @input:	curve	*			intimg - an integrated image, needed to compute the B-coeffs	*	* @output:	intern - the integral of the image in the curve	*/		public double computeIntegralincurve(Curve curve, ImageAccess intimg) {				double intern = 0;		Evaluatefunction CC = new Evaluatefunction(intimg, curve);		double[] curvevalues = CC.computeCurvevalues();		for(int i=0;i<curve.NCurvepts;i++) 			{				intern +=  curvevalues[i]*curve.CurveDiffY[i];						}								intern = intern/curve.Nsamples;		intern = (curve.signarea > 0) ? -intern : intern;		return intern;	}	public double computeIntegralincurve_old(Curve curve, ImageAccess intimg) {		Bcoeffs bcoeffs = new Bcoeffs(curve);		// DS		double[] bcoef = bcoeffs.getBcoeffs(intimg, curve);		//double[] bcoef = bcoeffs.getBcoeffs(intimg, curve, false);		//double[] bcoefdown = bcoeffs.getBcoeffs(intimg, curve, true);		//double[] bcoefR = bcoeffs.getBcoeffs(intimg, curve, true);				double intern = 0;		for(int i=1;i<curve.npoints-1;i++) 			{				intern +=  curve.CoeffY[i]*bcoef[i];						}					intern = intern/curve.Nsamples;		intern = (curve.signarea > 0) ? -intern : intern;		return intern;	}	/**	* Integrates the image along the x axis	*	* @input:  in  - image to integrate	*	* @output: out - integrated image	*/	public ImageAccess integrate_along_x(ImageAccess in) 		{			int nx = in.getWidth();			int ny = in.getHeight();			ImageAccess out = new ImageAccess(nx, ny, ImageAccess.FLOAT);						float[] processorIn = (float[])(in.getImageProcessor().getPixels());			float[] processorOut = (float[])(out.getImageProcessor().getPixels());				double pixel;			int index;						// integration			index = 0;			for(int y=0; y<ny; y++) 				{					processorOut[index] = processorIn[index];					index++;					for(int x=1; x<nx; x++) 						{							processorOut[index] = processorOut[index-1] +  processorIn[index];							index++;						}				}			// integration end			return out;		}		/**	* Transforms the input image with the given mu1, mu2	*	* @inputs:	in	- the input image to transform	*			mu1, mu2	* 	* @outputs: out	- the transformed image	*/	public ImageAccess transformImageVariance(double mu1, double mu2, double sigma1, double sigma2) 		{			int nx = rawImage.getWidth();			int ny = rawImage.getHeight();			ImageAccess out = new ImageAccess(nx, ny, ImageAccess.FLOAT);						float[] processorIn = (float[])(rawImage.getImageProcessor().getPixels());			float[] processorSq = (float[])(sqrImage.getImageProcessor().getPixels());			float[] processorOut = (float[])(out.getImageProcessor().getPixels());				float constant1 = (float)(2*(mu1/sigma1-mu2/sigma2)*(double)signarea);			float constant2 = (float)(signarea*(mu2*mu2/sigma2-mu1*mu1/sigma1+ 0.5*(Math.log(sigma2)-Math.log(sigma1))));			float constant3 = (float)(signarea*(1/sigma2-1/sigma1));							IJ.write("a "+constant3+" b "+constant2+" c "+constant1);			for(int i=0; i<nx*ny; i++)				{					processorOut[i] = constant1*processorIn[i]+constant2+constant3*processorSq[i];				}							return out;		}					/**	* Transforms the input image with the given mu1, mu2	*	* @inputs:	in	- the input image to transform	*			mu1, mu2	* 	* @outputs: out	- the transformed image	*/	public ImageAccess transformImageMean(double mu1, double mu2) 		{			int nx = rawImage.getWidth();			int ny = rawImage.getHeight();			ImageAccess out = new ImageAccess(nx, ny, ImageAccess.FLOAT);			out.copy(rawImage);						double constant1 = 2/(mu1-mu2)*(double)signarea;			double constant2 = signarea*(mu1+mu2)/(mu2-mu1);					out.multiply(constant1);			out.add(constant2);					return out;		}			/**	* Normalizes the image: divides eache pixel by the norme of the image	*	* @input:	imgin  - the image to normalize	*		* @output:	imgout - the normalized image	*/	public ImageAccess normalizeImage(ImageAccess imgin, double threshold, double constant) {				double norme = 0;		int nx = imgin.getWidth();		int ny = imgin.getHeight();				ImageAccess imgout = new ImageAccess(nx, ny, imgin.getType());		imgout.copy(imgin);		float[] processorOut = (float[])(imgout.getImageProcessor().getPixels());			// calculating the norm				for(int index=0; index<nx*ny; index++) 			norme += processorOut[index]*processorOut[index];				if(norme > nx*ny*threshold)				norme = 1000000.0*constant/Math.sqrt(norme);		else			norme = 0;				for(int index=0; index<nx*ny; index++) 			processorOut[index] *= norme;					return imgout;		}	/**	* Computes the Laplacian of an image using a Gaussian smoothing	*	* @inputs: 	in		- the image which Laplacien to calculate	*			sigma	- the sigma value to use in the Gaussian smoothing	*	* @output:  imgout	- the Laplacian of the input image	*	*/	public ImageAccess computeLaplacian(ImageAccess in, double sigma) 		{						int length = (int)(3*sigma);			double[] kernel = new double[2*length+1];			double[] kernelD = new double[2*length+1];						for(int i=0; i<2*length+1; i++)				{					kernel[i] =  Gauss((double)(i-length),sigma);					kernelD[i] = DDGauss((double)(i-length),sigma);				}						double sum = 0.0;			for(int i=0; i<2*length+1; i++)				sum += kernelD[i];			sum = sum/(2*length+1);			for(int i=0; i<2*length+1; i++)				kernelD[i] -= sum;										int nx = in.getWidth();			int ny = in.getHeight();			ImageAccess out = new ImageAccess(nx, ny, in.getType());			ImageAccess temp = new ImageAccess(nx, ny, in.getType());			out.copy(in);			temp.copy(in);						double rowin[]  = new double[nx];			double colin[]  = new double[ny];				for(int y=0; y<ny; y++) {				out.getRow(y, rowin);				convolver.convolveFIR(rowin, kernel, length);				out.putRow(y, rowin);			}			for(int x=0; x<nx; x++) {				out.getColumn(x, colin);				convolver.convolveFIR(colin, kernelD, length);				out.putColumn(x, colin);			}									for(int y=0; y<ny; y++) {				temp.getRow(y, rowin);				convolver.convolveFIR(rowin, kernelD, length);				temp.putRow(y, rowin);			}			for(int x=0; x<nx; x++) {				temp.getColumn(x, colin);				convolver.convolveFIR(colin, kernel, length);				temp.putColumn(x, colin);			}						out.add(temp);			return(out);	}			private double DDGauss(double x, double sigma)		{			double sigma2 = sigma*sigma;			double x2 = x*x;						return((4*x2-2*sigma2)*Math.exp(-(x2/sigma2)));				} 	private double Gauss(double x, double sigma)		{			double sigma2 = sigma*sigma;			double x2 = x*x;						return(Math.exp(-x2/sigma2));				} }
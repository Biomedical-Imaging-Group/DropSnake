/*====================================================================| Version: March 1, 2003\===================================================================*//*====================================================================| EPFL/STI/IOA/BIG| Mathews Jacob| Bldg. BM-Ecublens 4.141| CH-1015 Lausanne VD|| phone (CET): +41(21)693.51.43| fax: +41(21)693.37.01| RFC-822: Mathews.Jacob@epfl.ch|| URL: http://bigwww.epfl.ch/jacob\===================================================================*//*====================================================================| Additional help available at http://bigwww.epfl.ch/jacob/splineSnake/\===================================================================*/package dropsnake;import ij.plugin.PlugIn;import ij.process.*;import java.awt.*;import java.awt.event.*;import java.io.*;import java.util.*;import java.lang.*;import ij.*;/*====================================================================|  ImageDisplay|  Performs the preprocessing required for display snake evolution|  Computation of edgemap(gradient magnitude) and its differentials\===================================================================*/public class ImageDisplay extends Object{		public ImageAccess edgemapX; 	public ImageAccess edgemapY; 	public boolean imageComputing = true; 		private double[] kernel1;		private double[] kernel2;			private Convolver convolver = new Convolver(Convolver.MIRROR);	private int nx, ny;		private double[] colin; 	private double[] rowin;	private int length;	//-------------// Constructor//-------------	public ImageDisplay(ImagePlus imp, double sigma) 			{			imageComputing = true;		 	length = (int)(2*sigma);			kernel1 = new double[2*length+1];			kernel2 = new double[2*length+1];						double sum = 0.0;			for(int i=0; i<2*length+1; i++)				{					kernel1[i] = DGauss((double)(i-length),sigma/2);					kernel2[i] = Gauss((double)(i-length),sigma/2);					sum += kernel2[i];				}			for(int i=0; i<2*length+1; i++)				{					kernel1[i] = kernel1[i]/sum;					kernel2[i] = kernel2[i]/sum;				}						 	ImageAccess junk = new ImageAccess(imp.getProcessor()); 		 	nx = junk.getWidth();			ny = junk.getHeight();			rowin  = new double[nx];			colin  = new double[ny];						 	ImageAccess rawImage = new ImageAccess(nx,ny, ImageAccess.FLOAT); 		 	rawImage.copy(junk);		 			 	ImageAccess edgemap = giveedgemap(rawImage);		 	edgemapX = diffAlongX(edgemap);		 	edgemapY = diffAlongY(edgemap);		 			 	imageComputing = false;		 	return;		 } 	// Give gradient magnitude//------------------------	private ImageAccess giveedgemap(ImageAccess in) 		{									ImageAccess out1 = new ImageAccess(nx, ny, in.getType());			ImageAccess out2 = new ImageAccess(nx, ny, in.getType());			out1.copy(in);			out2.copy(in);						for(int y=0; y<ny; y++) {				out1.getRow(y, rowin);				convolver.convolveFIR(rowin, kernel1, length);				out1.putRow(y, rowin);								out2.getRow(y, rowin);				convolver.convolveFIR(rowin, kernel2, length);				out2.putRow(y, rowin);			}						for(int x=0; x<nx; x++) {				out1.getColumn(x, colin);				convolver.convolveFIR(colin, kernel2, length);				out1.putColumn(x, colin);								out2.getColumn(x, colin);				convolver.convolveFIR(colin, kernel1, length);				out2.putColumn(x, colin);			}					out1.multiply(out1);			out2.multiply(out2);			out1.add(out2);						return(out1);	}		// differentiate along X//------------------------		private ImageAccess diffAlongX(ImageAccess in) 		{			ImageAccess out = new ImageAccess(nx, ny, in.getType());			out.copy(in);						for(int y=0; y<ny; y++) {				out.getRow(y, rowin);				convolver.convolveFIR(rowin, kernel1, length);				out.putRow(y, rowin);			}						for(int x=0; x<nx; x++) {				out.getColumn(x, colin);				convolver.convolveFIR(colin, kernel2, length);				out.putColumn(x, colin);			}					return(out);	}			// differentiate along Y//------------------------private ImageAccess diffAlongY(ImageAccess in) 		{			ImageAccess out = new ImageAccess(nx, ny, in.getType());			out.copy(in);						for(int y=0; y<ny; y++) {				out.getRow(y, rowin);				convolver.convolveFIR(rowin, kernel2, length);				out.putRow(y, rowin);			}						for(int x=0; x<nx; x++) {				out.getColumn(x, colin);				convolver.convolveFIR(colin, kernel1, length);				out.putColumn(x, colin);			}					return(out);	}// Gaussian kernels//------------------------	private double DGauss(double x, double sigma)		{			double sigma2 = sigma*sigma;						return( -2*x*Math.exp(-x*x/sigma2)/sigma2 );				} 	private double Gauss(double x, double sigma)		{			double sigma2 = sigma*sigma;						return( Math.exp(-x*x/sigma2) );				} }
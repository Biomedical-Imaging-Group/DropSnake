/*====================================================================| DropSnake Version: March 22, 2005\===================================================================*//*====================================================================| EPFL/STI/IOA/BIG| AurŽlien Stalder| aurelien.stalder@gmail.com|\===================================================================*/// Based on the plugin SplineSnake by Mathews Jacob; Version: March 1, 2003// This class calculates image values along the curvepackage dropsnake;import ij.plugin.PlugIn;import ij.process.*;import java.awt.*;import java.awt.event.*;import java.io.*;import java.util.*;import java.lang.*;import ij.*;public class Evaluatefunction extends Object {	private float[] processor;private float[] processorCoeff;boolean interpolation;private int nx, ny;private Curve curve;double arr[][]=new double[4][4];		//----------------------------// Bcoeffs -> Constructor//----------------------------		public Evaluatefunction(ImageAccess imgin, Curve curve) {				processor = (float[])(imgin.getImageProcessor().getPixels());				nx = imgin.getWidth();		ny = imgin.getHeight();		this.curve = curve;		interpolation=false;	}		// constructor with use of interpolation based on cubic spline	public Evaluatefunction(ImageAccess imgin,ImageAccess Coeffin, Curve curve) {				processor = (float[])(imgin.getImageProcessor().getPixels());		processorCoeff = (float[])(Coeffin.getImageProcessor().getPixels());				nx = imgin.getWidth();		ny = imgin.getHeight();				this.curve = curve;		interpolation=true;	}	//------------------------------------------------------------// computeCurvevalues -> get the image values along the curve// // Reserved for image interpolation.//------------------------------------------------------------	public double[] computeCurvevalues() {			int x,y,index,Xfloor,Yfloor;		double X,Y;		double[] array = new double[curve.NCurvepts];				for(int i=0; i<curve.ncurvepts; i++) {						X=curve.CurveX[i];			Y=curve.CurveY[i];			Xfloor=(int)(curve.CurveX[i]);		//take the largest integer			Yfloor=(int)(curve.CurveY[i]);												if(Xfloor<=1){ X=1; Xfloor=1;}				else if(Xfloor>= nx-3) {X=nx-3; Xfloor=nx-3;}				if(Yfloor<=1) { Y=1; Yfloor=1;}				else if(Yfloor>= ny-3) {Y=ny-3; Yfloor=ny-3;}										else					{					if(interpolation) {											getNeighborhood4x4(Xfloor, Yfloor);						array[i]=Interpolation.getSampleCubicSpline(X-Xfloor, Y-Yfloor, arr);											}					else {						x = (int)(X+0.5);						y = (int)(Y+0.5);						index = y*nx + x;						array[i] = processor[index];					}					}		}		for(int i=curve.ncurvepts; i<curve.NCurvepts; i++) {						X=curve.CurveX[i];			Y=curve.CurveY[i];			Xfloor=(int)(curve.CurveX[i]);		//take the largest integer			Yfloor=(int)(curve.CurveY[i]);												if(Xfloor<=1 || Xfloor>= nx-3) {	//if outside of image negative effect for top points, ignore for reflected points					array[i] = 0.0;				}				else if(Yfloor<=1 || Yfloor>= ny-3) {					array[i] = 0.0;				}								else					{					if(interpolation) {											getNeighborhood4x4(Xfloor, Yfloor);						array[i]=Interpolation.getSampleCubicSpline(X-Xfloor, Y-Yfloor, arr);											}					else {						x = (int)(X+0.5);						y = (int)(Y+0.5);						index = y*nx + x;						array[i] = processor[index];					}					}		}		return array;			}		private void getNeighborhood4x4(int x, int y) {		int index;				for(int i=-1; i<=2; i++) {			for(int j=-1; j<=2; j++) {				index = (y+j)*nx + x+i;				if(index<0 || index>= nx*ny) IJ.write("index " +index);					arr[i+1][j+1] = processorCoeff[index];			}		}	}	}
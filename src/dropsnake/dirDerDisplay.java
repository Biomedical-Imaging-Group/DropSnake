/*====================================================================| Version: March 1, 2003\===================================================================*//*====================================================================| EPFL/STI/IOA/BIG| Mathews Jacob| Bldg. BM-Ecublens 4.141| CH-1015 Lausanne VD|| phone (CET): +41(21)693.51.43| fax: +41(21)693.37.01| RFC-822: Mathews.Jacob@epfl.ch|| URL: http://bigwww.epfl.ch/jacob\===================================================================*//*====================================================================| Additional help available at http://bigwww.epfl.ch/jacob/splineSnake/\===================================================================*/package dropsnake;import ij.plugin.PlugIn;import ij.process.*;import java.awt.*;import java.awt.event.*;import java.io.*;import java.util.*;import java.lang.*;import ij.*;//------------------------------------------// Generates the directional derivatives for// display curve iteration//------------------------------------------public class dirDerDisplay extends Object {		public double[] DC;	public double[] DD;		public double[] DC_final;	public double[] DD_final;	public double Newlength;		double[] Kernel1 = {1.0/120.0, 1.0/5.0, 1.0/8.0, -2.0/3.0, 1.0/8.0,1.0/5.0,1.0/120.0};	private double  DX[];	private double  DY[];	private double  D2X[];	private double  D2Y[];	private double  Amatrix[][];	private double  Bmatrix[][];	private double temp[];	private double tempX[];	private double tempY[];		int Origin = 3;			private double[][][] Kernel =  {{{1.0/4032.0   , 17.0/20160.0  , 1.0/10080.0    ,  0,   0},									{17.0/20160.0  , 43.0/10080.0  , 17.0/20160.0   ,  0,   0},									{1.0/10080.0   , 17.0/20160.0  , 1.0/4032.0     ,  0,   0},									{0			   , 0		       , 0	            ,  0,   0},									{0			   , 0		       , 0	            ,  0,   0}},																		{{17.0/20160.0 , 43.0/10080.0  , 17.0/20160.0   ,  0            ,   0},									{43.0/10080.0  , 1177.0/20160.0,  7.0/180.0     ,  17.0/20160.0 ,   0},									{17.0/20160.0  , 7.0/180.0     , 1177.0/20160.0 ,  43.0/10080.0 ,   0},									{0			   , 17.0/20160.0  , 43.0/10080.0   ,  17.0/20160.0 ,   0},									{0			   , 0		       , 0	            ,  0            ,   0}},																		{{1.0/10080.0  , 17.0/20160.0  , 1.0/4032.0     ,  0              ,   0         },									{17.0/20160.0  ,  7.0/180.0    , 1177.0/20160.0 ,  43.0/10080.0   ,   0         },									{1.0/4032.0    , 1177.0/20160.0, 379.0/1680     ,  1177.0/20160.0 ,   1.0/4032.0},									{0			   , 43.0/10080.0  , 1177.0/20160.0 ,  7.0/180.0      ,   17.0/20160.0  },									{0			   , 0		       , 1.0/4032.0     ,  17.0/20160.0   ,   1.0/10080.0  }},																		{{0			   , 0		       , 0	            ,  0                       ,   0},									{0             , 17.0/20160.0  , 43.0/10080.0   , 17.0/20160.0   ,   0         },									{0             , 43.0/10080.0  , 1177.0/20160.0 ,  7.0/180.0     ,  17.0/20160.0},									{0			   , 17.0/20160.0  , 7.0/180.0      , 1177.0/20160.0 ,  43.0/10080.0  },									{0			   , 0		       , 17.0/20160.0   , 43.0/10080.0   ,  17.0/20160.0  }},																		{{0			   , 0		       , 0	            ,  0,   0                      },									{0			   , 0		       , 0	            ,  0,   0                      },									{0             , 0             , 1.0/4032.0    , 17.0/20160.0   , 1.0/10080.0  },									{0			   , 0             , 17.0/20160.0  , 43.0/10080.0   , 17.0/20160.0 },									{0			   , 0		       , 1.0/10080.0   , 17.0/20160.0   , 1.0/4032.0   }}};										private double[] kernel1 = {1.0/120.0, 13.0/60.0, 11.0/20.0, 13.0/60.0,1.0/120.0 };		// for open curve		//----------------					public void getDirDerivatives(ImageAccess imgX, ImageAccess imgY, DisplayCurve curve, int fixedlength) 			{				DC = new double[curve.Npoints];				DD = new double[curve.Npoints];				DC_final = new double[curve.Npoints];				DD_final = new double[curve.Npoints];								getDDImage(imgX, imgY, curve, fixedlength);				Normalize_DD(0.0001, curve.Npoints, 1);				for(int i=0; i<curve.Npoints; i++)					{						DC_final[i] = DC[i];						DD_final[i] = DD[i];					}			}					// for closed curve		//----------------		public void getDirDerClosed(ImageAccess imgX, ImageAccess imgY, Curve curve, double length) 			{				DC = new double[curve.Npoints];				DD = new double[curve.Npoints];				DC_final = new double[curve.Npoints];				DD_final = new double[curve.Npoints];				DX  = new double[curve.Npoints];			 	DY  = new double[curve.Npoints];			 	tempX = new double[curve.Npoints];			 	tempY = new double[curve.Npoints];				getDDImageClosed(imgX, imgY, curve);				Normalize_DD(0.0001, curve.Npoints, 1);				for(int i=0; i<curve.Npoints; i++)					{						DC_final[i] = DC[i];						DD_final[i] = DD[i];					}							}						private void getDDImage(ImageAccess imgX, ImageAccess imgY, DisplayCurve curve, int fixedlength)			{				int l;				double[] curvevaluesX = new double[curve.NCurvepts];				double[] curvevaluesY = new double[curve.NCurvepts];								int start = (fixedlength-2)*curve.Nsamples;				start = (start < 0)? 0: start;								for(int i=start; i< curve.NCurvepts; i++)					{						curvevaluesX[i] = imgX.getPixel((int)(curve.CurveX[i]),(int)(curve.CurveY[i]));						curvevaluesY[i] = imgY.getPixel((int)(curve.CurveX[i]),(int)(curve.CurveY[i]));					}													for(int i=0;i<fixedlength-1; i++)					{						DC[i] = 0;						DD[i] = 0;					}								int k;				for(int i=fixedlength;i<curve.Npoints-1; i++)					{						DC[i] = 0;						DD[i] = 0;						for(int j=0; j<4*curve.Nsamples+1; j++)							{								k = (i-2)*curve.Nsamples + j;								k = (k<0) ? 0: (k>curve.NCurvepts-1) ? curve.NCurvepts-1: k;								DC[i] += curvevaluesX[k]*curve.SplineValues[j];								DD[i] += curvevaluesY[k]*curve.SplineValues[j];							}												}				return;				}																							private void getDDImageClosed(ImageAccess imgX, ImageAccess imgY, Curve curve)			{				int l;				double[] curvevaluesX = new double[curve.NCurvepts];				double[] curvevaluesY = new double[curve.NCurvepts];								for(int i=0; i< curve.NCurvepts; i++)					{						curvevaluesX[i] = imgX.getPixel((int)(curve.CurveX[i]),(int)(curve.CurveY[i]));						curvevaluesY[i] = imgY.getPixel((int)(curve.CurveX[i]),(int)(curve.CurveY[i]));					}									int k;				for(int i=0;i<curve.Npoints-1; i++)					{						DC[i] = 0;						DD[i] = 0;						for(int j=0; j<4*curve.Nsamples+1; j++)							{								k = (i-2)*curve.Nsamples + j;								k = (k<0) ? 0: (k>curve.NCurvepts-1) ? curve.NCurvepts-1: k;								DC[i] += curvevaluesX[k]*curve.SplineValues[j];								DD[i] += curvevaluesY[k]*curve.SplineValues[j];							}												}				return;				}													private void getDDLength(DisplayCurve curve, int fixedlength)					{					int k,l;					for(int i=fixedlength;i<curve.Npoints-1; i++)						{							DC[i] = 0;							DD[i] = 0;							for(int j=0;j < Kernel1.length; j++)							{								l=i+j-Origin+2;										l = (l<0)? 0: (l>curve.Npoints+3)? curve.Npoints+3: l;								DC[i] += Kernel1[j]*curve.CoeffX[l];								DD[i] += Kernel1[j]*curve.CoeffY[l];							}													}					 return;					}								// ---------------------------------------------------------		//	Normalize_DD: Normalize the  directional derrivatives 		// ---------------------------------------------------------			public void Normalize_DD(double	Threshold, int Npoints, double Constant)				{					int i;					double norm = 0.0;					for(i=0;i<Npoints;i++) 						{							norm += DC[i]*DC[i];							norm += DD[i]*DD[i];						}					if(norm > Threshold)							norm = Constant/Math.sqrt(norm);					else							norm = 0.0;								for(i=0;i<Npoints;i++) 						{							DC[i] = DC[i]*norm;							DD[i] = DD[i]*norm;						}							}		}	
/* * ImageAccess is a interface layer to facilitate the access to the pixels  * of images. Methods of ImageAccess provides  an easy and robust way to  * access to the pixels of ImageProcessor. * * The following type are currently available: * - byte (8 bits)  * - short (16 bits)  * - float (32 bits) * - double (64 bits) *  * ImageAccess doesn't contains any pixels data. * It is is an envelop to ImageProcessor of ImageJ that contains  * the pixels data. It is possible to obtain an array of pixels * by calling the method getImageProcessor() that return a reference to * an ImageProcessor. *  * @author 	Swiss Federal Institute of Technology Lausanne *			Biomedical Imaging Group *			Daniel Sage * * @version 1.0 */ package dropsnake;import ij.ImagePlus;import ij.process.ImageProcessor;import ij.process.ByteProcessor;import ij.process.ShortProcessor;import ij.process.FloatProcessor;public class ImageAccess extends Object{public static final int NOTDEFINED  = -1;public static final int BYTE  = ImagePlus.GRAY8;		// 0 in ImageJpublic static final int SHORT = ImagePlus.GRAY16;		// 1 in ImageJpublic static final int FLOAT = ImagePlus.GRAY32;		// 2 in ImageJpublic static final int DOUBLE = 6;						// Not defined in ImageJpublic static final int CONNECTIVITY_4 = 0;public static final int CONNECTIVITY_8 = 1;private ImageProcessor ip = null;	// Reference to an ImageProcessor of ImageJ	private double doublePixels[] = null;private int type = ImageAccess.NOTDEFINED;private int nx = 0;private int ny = 0;private int size = 0;private int mark = 0;				// a free user integer to mark an image									// accessible with setMark() and getMark()/*** Creates a new object of the class ImageAccess from an ImageProcessor object.** ImageProcessor object contains the image data, the size and the type* of the image. ImageProcessor is provided by ImageJ.** @param ip    an ImageProcessor object provided by ImageJ*/public ImageAccess(ImageProcessor ip) {	this.ip = ip;		if (ip.getPixels() instanceof byte[]) {		type = ImageAccess.BYTE;	}		else if (ip.getPixels() instanceof short[]) {		type = ImageAccess.SHORT;	}		else if (ip.getPixels() instanceof float[]) {		type = ImageAccess.FLOAT;	}	else  {		throw new ArrayStoreException("Unexpected image type");	}		nx = ip.getWidth();	ny = ip.getHeight();	size = nx*ny;}/*** Creates a new object of the class ImageAccess.** The size and the type of the image are given as parameter.* The data pixels are empty and are not initialized.** @param nx       	the size of the image along the X-axis* @param ny       	the size of the image along the Y-axis* @param type     	the type of the image*					the value of type can be:*						ImageAccess.BYTE*						ImageAccess.SHORT*						ImageAccess.FLOAT*						ImageAccess.DOUBLE*/public ImageAccess(int nx, int ny, int type){	if (nx<1 || ny<1) {		throw new IndexOutOfBoundsException("The size of the image is incorrect");	}		this.type = type;	this.nx = nx;	this.ny = ny;	size = nx*ny;		switch(type) {		case BYTE:			ip = new ByteProcessor(nx, ny);			break;				case SHORT:			ip = new ShortProcessor(nx, ny, true);			break;				case FLOAT:			ip = new FloatProcessor(nx, ny);			break;				case DOUBLE:			ip = null;			doublePixels = new double[size];			break;					default:			throw new ArrayStoreException("Unexpected image type");	}}/*** Compute the absolute value.*/public void abs() {	double row[] = new double[nx];	for (int y=0; y<ny; y++) {		getRow(y, row);		for (int x=0; x<nx; x++) {			row[x] = Math.abs(row[x]);		}		putRow(y, row);	}}/*** An ImageAccess object calls this method for adding* a constant to each pixel. ** After having the method executed the result of the addition is* in the ImageAccess object which called the method.** @param constant   a constant to be added*/public void add(final double constant){	switch(type) {			case BYTE:			byte[] bytePixels = getPixelsByte();			byte byteConstant = (byte)Math.round(constant);			for (int k=0; k<size; k++)				bytePixels[k] += byteConstant;			break;				case SHORT:			short[] shortPixels = getPixelsShort();			short shortConstant = (short)Math.round(constant);			for (int k=0; k<size; k++)				shortPixels[k] += shortConstant;			break;				case FLOAT:			float[] floatPixels = getPixelsFloat();			float floatConstant = (float)constant;			for (int k=0; k<size; k++) {				floatPixels[k] += floatConstant;			}			break;				case DOUBLE:			for (int k=0; k<size; k++)				doublePixels[k] += constant;				break;					default:			throw new ArrayStoreException("Unexpected image type");	}}/*** An ImageAccess object calls this method for adding* a ImageAccess object which is the arguments for the method* by means of pixel to pixel addition. ** After having the method executed the result of the addition is* in the ImageAccess object which called the method.* The ImageAccess objects should have the same size.** @param im		an ImageAccess object to be added*/public void add(ImageAccess im){	if (im.getWidth() != nx) {		throw new ArrayStoreException("Unexpected operand image size");	}		if (im.getHeight() != ny) {		throw new ArrayStoreException("Unexpected operand image size");	}		if (im.getType() != type) {		throw new ArrayStoreException("Unexpected operand image type");	}				switch(type) {			case BYTE:			byte[] bytePixels  = getPixelsByte();			byte[] byteOperand = im.getPixelsByte();			for (int k=0; k<size; k++)				bytePixels[k] += byteOperand[k];			break;				case SHORT:			short[] shortPixels  = getPixelsShort();			short[] shortOperand = im.getPixelsShort();			for (int k=0; k<size; k++)				shortPixels[k] += shortOperand[k];			break;				case FLOAT:			float[] floatPixels  = getPixelsFloat();			float[] floatOperand = im.getPixelsFloat();			for (int k=0; k<size; k++)				floatPixels[k] += floatOperand[k];			break;				case DOUBLE:			double[] doubleOperand = im.getPixelsDouble();			for (int k=0; k<size; k++)				doublePixels[k] += doubleOperand[k];			break;					default:			throw new ArrayStoreException("Unexpected image type");	}}/*** An ImageAccess object (destination) calls this method to copy* all the pixels from a source ImageAccess object.** After having the method executed the result of the copying process is* in the ImageAccess object which called the method.* The destination and the source should have the same size.** If the type of the source and the destination are different there is * conversion to the type of the destination.** @param source    an ImageProcessor object to be copied*/public void copy(ImageAccess source){	if (source.getWidth() != nx) {		throw new ArrayStoreException("Unexpected image size axis X (" + 						source.getWidth() + "!=" + nx + ")");	}		if (source.getHeight() != ny) {		throw new ArrayStoreException("Unexpected image size axis Y (" + 						source.getHeight() + "!=" + ny + ")");	}	switch (source.getType()) {			case BYTE:			byte[] bsrc = source.getPixelsByte();			switch(type) {							case BYTE:					byte[] bdst = getPixelsByte();					System.arraycopy(bsrc, 0, bdst, 0, size);					break;									case SHORT:					short[] sdst = getPixelsShort();					for (int k=0; k<size; k++)						sdst[k] = (short)(bsrc[k] & 0xFF);					break;									case FLOAT:					float[] fdst = getPixelsFloat();					for (int k=0; k<size; k++)						fdst[k] = (float)(bsrc[k] & 0xFF);					break;									case DOUBLE:					for (int k=0; k<size; k++)						doublePixels[k] = (double)(bsrc[k] & 0xFF);					break;									default:					throw new ArrayStoreException("Unexpected image type");			}			break;					case SHORT:			short[] ssrc = (short[])source.ip.getPixels();			switch(type) {							case BYTE:					byte[] bdst = getPixelsByte();					byte b0 = Byte.MIN_VALUE;					byte b1 = Byte.MAX_VALUE;					for (int k=0; k<size; k++)						bdst[k] = ((ssrc[k]<0)?(b0):((ssrc[k]>255)?(b1):((byte)Math.round(ssrc[k]))));					break;									case SHORT:					short[] sdst = getPixelsShort();					System.arraycopy(ssrc, 0, sdst, 0, size);					break;									case FLOAT:					float[] fdst = getPixelsFloat();					for (int k=0; k<size; k++)						fdst[k] = (float)ssrc[k];					break;									case DOUBLE:					for (int k=0; k<size; k++)						doublePixels[k] = (double)ssrc[k];					break;									default:					throw new ArrayStoreException("Unexpected image type");			}			break;					case FLOAT:				float[] fsrc = (float[])source.ip.getPixels();			switch(type) {							case BYTE:					byte[] bdst = getPixelsByte();					byte b0 = (byte)0;					byte b1 = (byte)255;					for (int k=0; k<size; k++)						bdst[k] = ((fsrc[k]<0.0)?(b0):((fsrc[k]>255.0)?(b1):((byte)Math.round(fsrc[k]))));					break;									case SHORT:					short[] sdst = getPixelsShort();					short smin = Short.MIN_VALUE;					short smax = Short.MAX_VALUE;					float fmin = (float)Short.MIN_VALUE;					float fmax = (float)Short.MAX_VALUE;					for (int k=0; k<size; k++)						sdst[k] = ((fsrc[k]<fmin)?(smin):((fsrc[k]>fmax)?(smax):((byte)Math.round(fsrc[k]))));					break;									case FLOAT:					float[] fdst = getPixelsFloat();					System.arraycopy(fsrc, 0, fdst, 0, size);					break;									case DOUBLE:					for (int k=0; k<size; k++)						doublePixels[k] = (double)fsrc[k];					break;									default:					throw new ArrayStoreException("Unexpected image type");			}			break;						case DOUBLE:			double[] dsrc = source.getPixelsDouble();			switch(type) {							case BYTE:					byte[] bdst = getPixelsByte();					byte b0 = (byte)0;					byte b1 = (byte)255;					for (int k=0; k<size; k++)						bdst[k] = ((dsrc[k]<0.0)?(b0):((dsrc[k]>255.0)?(b1):((byte)Math.round(dsrc[k]))));					break;									case SHORT:					short[] sdst = getPixelsShort();					short smin = Short.MIN_VALUE;					short smax = Short.MAX_VALUE;					float fmin = (float)Short.MIN_VALUE;					float fmax = (float)Short.MAX_VALUE;					for (int k=0; k<size; k++)						sdst[k] = ((dsrc[k]<fmin)?(smin):((dsrc[k]>fmax)?(smax):((byte)Math.round(dsrc[k]))));					break;									case FLOAT:					float[] fdst = getPixelsFloat();					for (int k=0; k<size; k++)						fdst[k] = (float)dsrc[k];					break;									case DOUBLE:					System.arraycopy(dsrc, 0, doublePixels, 0, size);					break;										default:					throw new ArrayStoreException("Unexpected image type");			}			break;					default:			throw new ArrayStoreException("Unexpected image type");	}	}/*** An ImageAccess object (destination) calls this method to copy a block of pixels* from a source ImageAccess object with the possibility of selecting* the coordinates of the starting copying pixels in the both images.** After having the method executed the result of the copying process is* in the ImageAccess object which called the method.* The coordinates of the pixel in the source image to copy from and* the ones in the destination image to put from are selectable.** If the type of the source and the destination are different there is * conversion to the type of the destination.** @param source    	an ImageAccess object to be copied* @param xsrc       the integer x-coordinate in the source image for the start of the copying process* @param ysrc       the integer y-coordinate in the source image for the start of the copying process* @param xdst       the integer x-coordinate in the destination image for the start of the copying process  * @param ydst       the integer y-coordinate in the destination image for the start of the copying process* @param nxcopy     the width of the data block which should be copied (integer number of pixels)* @param nycopy     the height of the data block which should be copied (integer number of pixels)*/public void copy(ImageAccess source, int xsrc, int ysrc, int xdst, int ydst, int nxcopy, int nycopy){ 	if ((nxcopy<0) || (nycopy<0)) {		throw new IndexOutOfBoundsException("The size of the image is incorrect");	} 	if ((xsrc<0) || (ysrc<0)) {		throw new IndexOutOfBoundsException("Incompatible image size");	} 	if ((xdst<0) || (ydst<0)) {		throw new IndexOutOfBoundsException("Incompatible image size");	} 	int nxsrc = source.getWidth(); 	int nysrc = source.getHeight(); 	if ((xsrc>=nxsrc) || (ysrc>=nysrc)) {		throw new IndexOutOfBoundsException("Incompatible image size");	}	 	// nx is nx of the destination and ny is ny of the destination 	if ((xdst>=nx) || (ydst>=ny)) {		throw new IndexOutOfBoundsException("Incompatible image size");	}	// Reduces the size of the area to copy if it is too large	if (xsrc+nxcopy>nxsrc) 		nxcopy = nxsrc-xsrc;	if (ysrc+nycopy>nysrc) 		nycopy = nysrc-ysrc;	if (xdst+nxcopy>nx) 		nxcopy = nx-xdst;	if (ydst+nycopy>ny) 		nycopy = ny-ydst;	// Copies lines per lines	switch( source.getType()) {				case BYTE:			byte[] bsrc = (byte[])source.ip.getPixels();			switch(type) {							case BYTE:					byte[] dst = getPixelsByte();					for ( int j=0; j<nycopy; j++)						System.arraycopy(bsrc, (j+ysrc)*nxsrc+xsrc, dst, (j+ydst)*nx+xdst, nxcopy);					break;									case SHORT:					short[] sdst = getPixelsShort();					for ( int j=0; j<nycopy; j++) {						int jdst = (j+ydst)*nx;						int jsrc = (j+ysrc)*nxsrc;						for (int i=0; i<nxcopy; i++)							sdst[jdst+xdst+i] = (short)(bsrc[jsrc+xsrc+i] & 0xFF);					}					break;									case FLOAT:					float[] fdst = getPixelsFloat();					for ( int j=0; j<nycopy; j++) {						int jdst = (j+ydst)*nx;						int jsrc = (j+ysrc)*nxsrc;						for (int i=0; i<nxcopy; i++)							fdst[jdst+xdst+i] = (float)(bsrc[jsrc+xsrc+i] & 0xFF);					}					break;									case DOUBLE:					for ( int j=0; j<nycopy; j++) {						int jdst = (j+ydst)*nx;						int jsrc = (j+ysrc)*nxsrc;						for (int i=0; i<nxcopy; i++)							doublePixels[jdst+xdst+i] = (double)(bsrc[jsrc+xsrc+i] & 0xFF);					}					break;									default: 					throw new ArrayStoreException("Unexpected image type");			}			break;					case SHORT:			short[] ssrc = (short[])source.ip.getPixels();						switch(type) {							case BYTE:					byte[] bdst = getPixelsByte();					byte b0 = Byte.MIN_VALUE;					byte b1 = Byte.MAX_VALUE;					int k;					for ( int j=0; j<nycopy; j++) {						int jdst = (j+ydst)*nx;						int jsrc = (j+ysrc)*nxsrc;						for (int i=0; i<nxcopy; i++) {							k = jsrc+xsrc+i;							bdst[jdst+xdst+i] = ((ssrc[k]<0)?(b0):((ssrc[k]>255)?(b1):((byte)Math.round(ssrc[k]))));						}					}					break;									case SHORT:					short[] sdst = getPixelsShort();					for ( int j=0; j<nycopy; j++)						System.arraycopy(ssrc, (j+ysrc)*nxsrc+xsrc, sdst, (j+ydst)*nx+xdst, nxcopy);					break;									case FLOAT:					float[] fdst = getPixelsFloat();					for ( int j=0; j<nycopy; j++) {						int jdst = (j+ydst)*nx;						int jsrc = (j+ysrc)*nxsrc;						for (int i=0; i<nxcopy; i++)							fdst[jdst+xdst+i] = (float)(ssrc[jsrc+xsrc+i]);					}					break;									case DOUBLE:					for ( int j=0; j<nycopy; j++) {						int jdst = (j+ydst)*nx;						int jsrc = (j+ysrc)*nxsrc;						for (int i=0; i<nxcopy; i++)							doublePixels[jdst+xdst+i] = (double)(ssrc[jsrc+xsrc+i]);					}					break;				default: 					throw new ArrayStoreException("Unexpected image type");			}			break;					case FLOAT:			float[] fsrc = (float[])source.ip.getPixels();			int k;						switch(type) {							case BYTE:					byte[] bdst = getPixelsByte();					byte b0 = Byte.MIN_VALUE;					byte b1 = Byte.MAX_VALUE;					for ( int j=0; j<nycopy; j++) {						int jdst = (j+ydst)*nx;						int jsrc = (j+ysrc)*nxsrc;						for (int i=0; i<nxcopy; i++) {							k = jsrc+xsrc+i;							bdst[jdst+xdst+i] = ((fsrc[k]<0.0)?(b0):((fsrc[k]>255.0)?(b1):((byte)Math.round(fsrc[k]))));						}					}					break;									case SHORT:					short[] sdst = getPixelsShort();					short smin = Short.MIN_VALUE;					short smax = Short.MAX_VALUE;					float fmin = (float)Short.MIN_VALUE;					float fmax = (float)Short.MAX_VALUE;					for ( int j=0; j<nycopy; j++) {						int jdst = (j+ydst)*nx;						int jsrc = (j+ysrc)*nxsrc;						for (int i=0; i<nxcopy; i++) {							k = jsrc+xsrc+i;							sdst[jdst+xdst+i] = ((fsrc[k]<fmin)?(smin):((fsrc[k]>fmax)?(smax):((byte)Math.round(fsrc[k]))));						}					}					break;									case FLOAT:					float[] fdst = getPixelsFloat();					for ( int j=0; j<nycopy; j++)						System.arraycopy(fsrc, (j+ysrc)*nxsrc+xsrc, fdst, (j+ydst)*nx+xdst, nxcopy);					break;									case DOUBLE:					for ( int j=0; j<nycopy; j++) {						int jdst = (j+ydst)*nx;						int jsrc = (j+ysrc)*nxsrc;						for (int i=0; i<nxcopy; i++)							doublePixels[jdst+xdst+i] = (double)(fsrc[jsrc+xsrc+i]);					}					break;				default: 					throw new ArrayStoreException("Unexpected image type");			}			break;					case DOUBLE:			double[] dsrc = source.getPixelsDouble();			switch(type) {							case BYTE:					byte[] bdst = getPixelsByte();					byte b0 = Byte.MIN_VALUE;					byte b1 = Byte.MAX_VALUE;					for ( int j=0; j<nycopy; j++) {						int jdst = (j+ydst)*nx;						int jsrc = (j+ysrc)*nxsrc;						for (int i=0; i<nxcopy; i++) {							k = jsrc+xsrc+i;							bdst[jdst+xdst+i] = ((dsrc[k]<0.0)?(b0):((dsrc[k]>255.0)?(b1):((byte)Math.round(dsrc[k]))));						}					}					break;									case SHORT:					short[] sdst = getPixelsShort();					short smin = Short.MIN_VALUE;					short smax = Short.MAX_VALUE;					float fmin = (float)Short.MIN_VALUE;					float fmax = (float)Short.MAX_VALUE;					for ( int j=0; j<nycopy; j++) {						int jdst = (j+ydst)*nx;						int jsrc = (j+ysrc)*nxsrc;						for (int i=0; i<nxcopy; i++) {							k = jsrc+xsrc+i;							sdst[jdst+xdst+i] = ((dsrc[k]<fmin)?(smin):((dsrc[k]>fmax)?(smax):((byte)Math.round(dsrc[k]))));						}					}					break;									case FLOAT:					float[] fdst = getPixelsFloat();					for ( int j=0; j<nycopy; j++) {						int jdst = (j+ydst)*nx;						int jsrc = (j+ysrc)*nxsrc;						for (int i=0; i<nxcopy; i++)							fdst[jdst+xdst+i] = (float)(dsrc[jsrc+xsrc+i]);					}					break;				case DOUBLE:					for ( int j=0; j<nycopy; j++)						System.arraycopy(dsrc, (j+ysrc)*nxsrc+xsrc, doublePixels, (j+ydst)*nx+xdst, nxcopy);					break;									default: 					throw new ArrayStoreException("Unexpected image type");			}			break;					default: 			throw new ArrayStoreException("Unexpected image type");	}}/*** An ImageAccess object calls this method for dividing* a constant to each pixel. ** After having the method executed the result is* in the ImageAccess object which called the method.** @param constant   a constant to be multiplied*/public void divide(final double constant){	if (constant == 0.0) { 		throw new ArrayStoreException("Divide by 0");	}		switch(type) {			case BYTE:			byte[] bytePixels = getPixelsByte();			byte byteConstant = (byte)Math.round(constant);			for (int k=0; k<size; k++)				bytePixels[k] /= byteConstant;			break;				case SHORT:			short[] shortPixels = getPixelsShort();			short shortConstant = (short)Math.round(constant);			for (int k=0; k<size; k++)				shortPixels[k] /= shortConstant;			break;				case FLOAT:			float[] floatPixels = getPixelsFloat();			float floatConstant = (float)constant;			for (int k=0; k<size; k++)				floatPixels[k] /= floatConstant;			break;				case DOUBLE:			for (int k=0; k<size; k++)				doublePixels[k] /= constant;				break;					default:			throw new ArrayStoreException("Unexpected image type");	}}/*** An ImageAccess object calls this method for dividing* a ImageAccess object which is the arguments for the method* by means of pixel to pixel addition. ** After having the method executed the result is* in the ImageAccess object which called the method.* The ImageAccess objects should have the same size.** @param im		an ImageAccess object to be multiplied*/public void divide(ImageAccess im){	if (im.getWidth() != nx) {		throw new ArrayStoreException("Unexpected operand image size");	}		if (im.getHeight() != ny) {		throw new ArrayStoreException("Unexpected operand image size");	}		if (im.getType() != type) {		throw new ArrayStoreException("Unexpected operand image type");	}				switch(type) {			case BYTE:			byte[] bytePixels  = getPixelsByte();			byte[] byteOperand = im.getPixelsByte();			for (int k=0; k<size; k++)				bytePixels[k] /= byteOperand[k];			break;				case SHORT:			short[] shortPixels  = getPixelsShort();			short[] shortOperand = im.getPixelsShort();			for (int k=0; k<size; k++)				shortPixels[k] /= shortOperand[k];			break;				case FLOAT:			float[] floatPixels  = getPixelsFloat();			float[] floatOperand = im.getPixelsFloat();			for (int k=0; k<size; k++)				floatPixels[k] /= floatOperand[k];			break;				case DOUBLE:			double[] doubleOperand = im.getPixelsDouble();			for (int k=0; k<size; k++)				doublePixels[k] /= doubleOperand[k];			break;					default:			throw new ArrayStoreException("Unexpected image type");	}}/** Create a new ImageAccess object by duplication of the current the * ImageAccess object.** @return   a new ImageAccess object**/public ImageAccess duplicate(){	ImageAccess ia = new ImageAccess(nx, ny, type);	ia.copy(this);	return ia;}/** Compute the exp.*/public void exp() {	double row[] = new double[nx];	for (int y=0; y<ny; y++) {		getRow(y, row);		for (int x=0; x<nx; x++) {			row[x] = Math.exp(row[x]);		}		putRow(y, row);	}}/*** An ImageAccess object calls this method for getting a selected column* of the image data.** After having the method executed the result is* in an array of the type double which is passed to the method* through the list of arguments.** @param x       	input, the integer x-coordinate of a column* @param column     output, an array of the type double*/public void getColumn(int x, double[] column) {	if ( x < 0) {    	int periodx = 2*nx - 2;						while (x < 0) 			x += periodx;		// Periodize		if (x >= nx)  			x = periodx - x;	// Symmetrize	}	else if ( x >= nx) {    	int periodx = 2*nx - 2;						while (x >= nx) 			x -= periodx;		// Periodize		if (x < 0)  			x = - x;			// Symmetrize	}	switch(type) {			case BYTE:			byte[] bytePixels = getPixelsByte();			for (int i=0; i<ny; i++) {				double v = (double)bytePixels[x];				column[i] = ((v<0)?(v+256.0):(v));				x += nx;			}			break;				case SHORT:			short[] shortPixels = getPixelsShort();			for (int i=0; i<ny; i++) {				column[i] = (double)shortPixels[x];				x += nx;			}			break;				case FLOAT:			float[] floatPixels = getPixelsFloat();			for (int i=0; i<ny; i++) {				column[i] = (double)floatPixels[x];				x += nx;			}			break;				case DOUBLE:			for (int i=0; i<ny; i++) {				column[i] = doublePixels[x];				x += nx;			}			break;					default: 			throw new ArrayStoreException("Unexpected image type");	}}/*** An ImageAccess object calls this method for getting a part of a selected column* of the image data.** After having the method executed the result is* in an array of the type double which is passed to the method* through the list of arguments.** @param x       	input, the integer x-coordinate of a column* @param column     output, an array of the type double* @param start      input, the coordonate of the first element you want to have* @param end        input, the coordonate of the last element you want to have + 1** example : for having a part of a column from [0] to [N-1], * you must call getColumnPart(y,row,0,N)*/public void getColumn(int x, double[] column, int start, int end) {	if ( x < 0) {    	int periodx = 2*nx - 2;						while (x < 0) x += periodx;		// Periodize		if (x >= nx)  x = periodx - x;	// Symmetrize	}	else if ( x >= nx) {    	int periodx = 2*nx - 2;						while (x >= nx) x -= periodx;	// Periodize		if (x < 0)  x = - x;			// Symmetrize	}		if(start>=end || start<0 || end>ny)		throw new ArrayStoreException("Out of boundary in getColumn.");			int lengthColumn = end-start;	x += (start*nx);	switch(type) {			case BYTE:			byte[] bytePixels = getPixelsByte();			for (int i=0; i<lengthColumn; i++) {				double v = (double)bytePixels[x];				column[i] = ((v<0)?(v+256.0):(v));				x += nx;			}			break;				case SHORT:			short[] shortPixels = getPixelsShort();			for (int i=0; i<lengthColumn; i++) {				column[i] = (double)shortPixels[x];				x += nx;			}			break;				case FLOAT:			float[] floatPixels = getPixelsFloat();			for (int i=0; i<lengthColumn; i++) {				column[i] = (double)floatPixels[x];				x += nx;			}			break;				case DOUBLE:			for (int i=0; i<lengthColumn; i++) {				column[i] = doublePixels[x];				x += nx;			}			break;					default: 			throw new ArrayStoreException("Unexpected image type");	}	}/*** An ImageAccess object calls this method for getting* a 45 degree diagonal pixels.** The diagonal should be allocated before calling the routine. A way* to define the size is to call the method getSizeDiagonal(). The diagonal* array is not necessary filled up until the end depending of the index.* * The index k of the diagonal start from the Upper Left corner, go down,* turn right to finish at the Lower right corner.* If the index k equal 0 the diagonal contains 1 pixel (pixel [0,0]).* If the index k equal nx+ny-1 the diagonal contains 1 pixel (pixel [nx-1,ny-1]).* * Mirror border conditions are applied.** @param k			index of the diagonal* @param diagonal	array containing the diagonal* @return 			the length of the utile part of the diagonal*/public int getDiagonal45(int k, double[] diagonal){	if ( k < 0) {    	int periody = 2*(ny+nx) - 2;						while (k < 0) k += periody;			// Periodize		if (k >= (ny+nx))  k = periody - k;	// Symmetrize	}	else if ( k >= ny+nx) {    	int periody = 2*(ny+nx) - 2;						while (k >= (ny+nx)) k -= periody;	// Periodize		if (k < 0)  k = - k;				// Symmetrize	}		int len = -1;	int index;	if (nx > ny) {		if (k < ny) {			index = k*nx;			len = k+1;		}		else if (k < nx) {			index = (ny-1)*nx + (k-ny)+1;			len = ny;		}		else {			index = (ny-1)*nx + (k-ny)+1;			len = nx+ny-k-1;		}	}	else {		if (k < nx) {			index = k*nx;			len = k+1;		}		else if (k < ny) {			index = k*nx;			len = nx;		}		else {			index = (ny-1)*nx + (k-ny)+1;			len = nx+ny-k-1;		}	}		switch(type) {			case BYTE:			byte[] bytePixels = getPixelsByte();			for (int i=0; i<len; i++) {				double v = (double)bytePixels[index];				diagonal[i] = ((v<0)?(v+256.0):(v));				index -= (nx - 1);			}			break;				case SHORT:			short[] shortPixels = getPixelsShort();			for (int i=0; i<len; i++) {				diagonal[i] = (double)shortPixels[index];				index -= (nx - 1);			}			break;				case FLOAT:			float[] floatPixels = getPixelsFloat();			for (int i=0; i<len; i++) {				diagonal[i] = (double)floatPixels[index];				index -= (nx - 1);			}			break;				case DOUBLE:			for (int i=0; i<len; i++) {				diagonal[i] = doublePixels[index];				index -= (nx - 1);			}			break;					default: 			throw new ArrayStoreException("Unexpected image type");	}		return len;}/*** An ImageAccess object calls this method for getting* a 135 degrees diagonal pixels.** The diagonal should be allocated before calling the routine. A way* to define the size is to call the method getSizeDiagonal(). The diagonal* array is not necessary filled up until the end depending of the index.* * The index k of the diagonal start from the Lower Left corner, go right,* turn up to finish at the Upper right corner.* If the index k equal 0 the diagonal contains 1 pixel (pixel [0,ny-1]).* If the index k equal nx+ny-1 the diagonal contains 1 pixel (pixel [nx-1,0]).* * Mirror border conditions are applied.** @param k			index of the diagonal* @param diagonal	array containing the diagonal* @return 			the length of the utile part of the diagonal*/public int getDiagonal135(int k, double[] diagonal){	if ( k < 0) {    	int periody = 2*(ny+nx) - 2;						while (k < 0) k += periody;			// Periodize		if (k >= (ny+nx))  k = periody - k;	// Symmetrize	}	else if ( k >= ny+nx) {    	int periody = 2*(ny+nx) - 2;						while (k >= (ny+nx)) k -= periody;	// Periodize		if (k < 0)  k = - k;				// Symmetrize	}		int len = -1;	int index;	if (nx > ny) {		if (k < ny) {			index = (ny-1)*nx + k;			len = k+1;		}		else if (k < nx) {			index = (ny-1)*nx + k;			len = ny;		}		else {			index = (ny+nx-k-2)*nx + (nx-1);			len = nx+ny-k-1;		}	}	else {		if (k < nx) {			index = (ny-1)*nx + k;			len = k+1;		}		else if (k < ny) {			index = (ny+nx-k-2)*nx + (nx-1);			len = nx;		}		else {			index = (ny+nx-k-2)*nx + (nx-1);			len = nx+ny-k-1;		}	}		switch(type) {			case BYTE:			byte[] bytePixels = getPixelsByte();			for (int i=0; i<len; i++) {				double v = (double)bytePixels[index];				diagonal[i] = ((v<0)?(v+256.0):(v));				index -= (nx + 1);			}			break;				case SHORT:			short[] shortPixels = getPixelsShort();			for (int i=0; i<len; i++) {				diagonal[i] = (double)shortPixels[index];				index -= (nx + 1);			}			break;				case FLOAT:			float[] floatPixels = getPixelsFloat();			for (int i=0; i<len; i++) {				diagonal[i] = (double)floatPixels[index];				index -= (nx + 1);			}			break;				case DOUBLE:			for (int i=0; i<len; i++) {				diagonal[i] = doublePixels[index];				index -= (nx + 1);			}			break;					default: 			throw new ArrayStoreException("Unexpected image type");	}		return len;}/*** An ImageAccess object calls this method for getting the height of the image* i.e. the size of the image along the Y-axis.** @return     	the image height (integer)*/public int getHeight(){	return ny;}/*** An ImageAccess object calls this method for getting* the gray level of a selected pixel using a bilinear interpolation.* The coordinates can be given in real and the ** bilinear interpolation is applied the find the gray level.** Mirror border conditions are applied.** @param x		input, the double x-coordinate of a pixel* @param y		input, the double y-coordinate of a pixel* @return     	the gray level of the pixel (double) */public double getInterpolatedPixel(double x, double y){		int i = (int)Math.floor(x);	int j = (int)Math.floor(y);		double dx = x - (double)i;	double dy = y - (double)j;	double v[][] = getNeighborhood2x2(i, j);			/*double v00 = getPixel(i,j);	double v01 = getPixel(i,j+1);	double v10 = getPixel(i+1,j);	double v11 = getPixel(i+1,j+1);	*/			return dx*(v[1][1]*dy-v[1][0]*(dy-1.0)) - (dx-1.0)*(v[0][1]*dy-v[0][0]*(dy-1.0));}/*** An ImageAccess object calls this method for getting* a 2*2 neighborhood pixels around a selected pixel.** After having the method executed the result is* in an array of the type double which is passed to the method* through the list of arguments.** Mirror border conditions are applied.** @param x		input, the integer x-coordinate of a selected central pixel* @param y		input, the integer y-coordinate of a selected central pixel* @param neigh	output, an array consisting of 4 elements of the type double*/public void getNeighborhood2(int x, int y, double neigh[]){	if ( x < 0) {    	int periodx = 2*nx - 2;						while (x < 0) x += periodx;		// Periodize		if (x >= nx)  x = periodx - x;	// Symmetrize	}	else if ( x >= nx) {    	int periodx = 2*nx - 2;						while (x >= nx) x -= periodx;	// Periodize		if (x < 0)  x = - x;			// Symmetrize	}	if ( y < 0) {    	int periody = 2*ny - 2;						while (y < 0) y += periody;		// Periodize		if (y >= ny)  y = periody - y;	// Symmetrize	}	else if ( y >= ny) {    	int periody = 2*ny - 2;						while (y >= ny) y -= periody;	// Periodize		if (y < 0)  y = - y;			// Symmetrize	} 	if (x >= 0) 	if (y >= 0) 	if (x < nx-1) 	if (y < ny-1) { 		int index = y*nx + x;		switch(type) {		case BYTE:			byte[] bytePixels = getPixelsByte(); 			double v;			v = (double)bytePixels[index++]; 			neigh[0] = ((v<0)?(v+256.0):(v));			v = (double)bytePixels[index]; 			neigh[1] = ((v<0)?(v+256.0):(v));			index = (y+1)*nx + x;			v = (double)bytePixels[index++]; 			neigh[2] =  ((v<0)?(v+256.0):(v));			v = (double)bytePixels[index]; 			neigh[3] =  ((v<0)?(v+256.0):(v));			break;		case SHORT:			short[] shortPixels = getPixelsShort();			neigh[0] = (double)shortPixels[index++];			neigh[1] = (double)shortPixels[index];			index = (y+1)*nx + x;			neigh[2] = (double)shortPixels[index++];			neigh[3] = (double)shortPixels[index];			break;		case FLOAT:			float[] floatPixels = getPixelsFloat();			neigh[0] = (double)floatPixels[index++];			neigh[1] = (double)floatPixels[index];			index = (y+1)*nx + x;			neigh[2] = (double)floatPixels[index++];			neigh[3] = (double)floatPixels[index];			break;		case DOUBLE:			neigh[0] = doublePixels[index++];			neigh[1] = doublePixels[index];			index = (y+1)*nx + x;			neigh[2] = doublePixels[index++];			neigh[3] = doublePixels[index];			break;		default: 			throw new ArrayStoreException("Unexpected image type");		}		return;	}		int x1 = x;	int x2 = x + 1;	int y1 = y;	int y2 = y + 1;		if (x == 0)		x1 = x2;			if (y == 0)		y1 = y2;	if (x == nx-1)		x2 = x1;			if (y == ny-1)		y2 = y1; 	int offset;	switch(type) {	case BYTE:		byte[] bytePixels = getPixelsByte(); 		double v; 		offset = y1*nx;		v = (double)bytePixels[offset+x1]; 		neigh[0] = ((v<0)?(v+256.0):(v));		v = (double)bytePixels[offset+x2]; 		neigh[1] = ((v<0)?(v+256.0):(v)); 		offset = y2*nx;		v = (double)bytePixels[offset+x1]; 		neigh[2] =  ((v<0)?(v+256.0):(v));		v = (double)bytePixels[offset+x2]; 		neigh[3] =  ((v<0)?(v+256.0):(v));		break;	case SHORT:		short[] shortPixels = getPixelsShort(); 		offset = y1*nx;		neigh[0] = (double)shortPixels[offset+x1];		neigh[1] = (double)shortPixels[offset+x2]; 		offset = y2*nx;		neigh[2] = (double)shortPixels[offset+x1];		neigh[3] = (double)shortPixels[offset+x2];		break;	case FLOAT:		float[] floatPixels = getPixelsFloat(); 		offset = y1*nx;		neigh[0] = (double)floatPixels[offset+x1];		neigh[1] = (double)floatPixels[offset+x2]; 		offset = y2*nx;		neigh[2] = (double)floatPixels[offset+x1];		neigh[3] = (double)floatPixels[offset+x2];		break;	case DOUBLE: 		offset = y1*nx;		neigh[0] = doublePixels[offset+x1];		neigh[1] = doublePixels[offset+x2]; 		offset = y2*nx;		neigh[2] = doublePixels[offset+x1];		neigh[3] = doublePixels[offset+x2];		break;	default: 		throw new ArrayStoreException("Unexpected image type");	}}/*** An ImageAccess object calls this method for getting* a 2*2 neighborhood pixels around a selected pixel.** After having the method executed the result is* in an array of the type double.** Mirror border conditions are applied.** <br>* <br>Mirror border conditions are applied.* <br>* <br>The pixel value of (x  , y  ) are put into neigh[0][0]* <br>The pixel value of (x+1, y  ) are put into neigh[1][0]* <br>The pixel value of (x  , y+1) are put into neigh[0][1]* <br>The pixel value of (x+1, y+1) are put into neigh[1][1]** @param x		input, the integer x-coordinate of a selected central pixel* @param y		input, the integer y-coordinate of a selected central pixel* @return		output, an array consisting of 2*2 elements of the type double*/public double[][] getNeighborhood2x2(int x, int y){	double neigh[][] = new double[2][2];	getNeighborhood2x2( x, y, neigh);	return neigh;}/*** An ImageAccess object calls this method for getting* a 2*2 neighborhood pixels around a selected pixel.** After having the method executed the result is* in an array of the type double which is passed to the method* through the list of arguments.** <br>* <br>If the connect string is "8-connected" * <br>The pixel value of (x  , y  ) are put into neigh[0][0]* <br>The pixel value of (x+1, y  ) are put into neigh[1][0]* <br>The pixel value of (x  , y+1) are put into neigh[0][1]* <br>The pixel value of (x+1, y+1) are put into neigh[1][1]** @param x		input, the integer x-coordinate of a selected central pixel* @param y		input, the integer y-coordinate of a selected central pixel* @param neigh	output, an array consisting of 2*2 elements of the type double*/public void getNeighborhood2x2(int x, int y, double neigh[][]){	if ( x < 0) {    	int periodx = 2*nx - 2;						while (x < 0) x += periodx;		// Periodize		if (x >= nx)  x = periodx - x;	// Symmetrize	}	else if ( x >= nx) {    	int periodx = 2*nx - 2;						while (x >= nx) x -= periodx;	// Periodize		if (x < 0)  x = - x;			// Symmetrize	}	if ( y < 0) {    	int periody = 2*ny - 2;						while (y < 0) y += periody;		// Periodize		if (y >= ny)  y = periody - y;	// Symmetrize	}	else if ( y >= ny) {    	int periody = 2*ny - 2;						while (y >= ny) y -= periody;	// Periodize		if (y < 0)  y = - y;			// Symmetrize	} 	if (x >= 0) 	if (y >= 0) 	if (x < nx-1) 	if (y < ny-1) { 		int index = y*nx + x;		switch(type) {		case BYTE:			byte[] bytePixels = getPixelsByte(); 			double v;			v = (double)bytePixels[index++]; 			neigh[0][0] = ((v<0)?(v+256.0):(v));			v = (double)bytePixels[index]; 			neigh[1][0] = ((v<0)?(v+256.0):(v));			index = (y+1)*nx + x;			v = (double)bytePixels[index++]; 			neigh[0][1] =  ((v<0)?(v+256.0):(v));			v = (double)bytePixels[index]; 			neigh[1][1] =  ((v<0)?(v+256.0):(v));			break;		case SHORT:			short[] shortPixels = getPixelsShort();			neigh[0][0] = (double)shortPixels[index++];			neigh[1][0] = (double)shortPixels[index];			index = (y+1)*nx + x;			neigh[0][1] = (double)shortPixels[index++];			neigh[1][1] = (double)shortPixels[index];			break;		case FLOAT:			float[] floatPixels = getPixelsFloat();			neigh[0][0] = (double)floatPixels[index++];			neigh[1][0] = (double)floatPixels[index];			index = (y+1)*nx + x;			neigh[0][1] = (double)floatPixels[index++];			neigh[1][1] = (double)floatPixels[index];			break;		case DOUBLE:			neigh[0][0] = doublePixels[index++];			neigh[1][0] = doublePixels[index];			index = (y+1)*nx + x;			neigh[0][1] = doublePixels[index++];			neigh[1][1] = doublePixels[index];			break;		default: 			throw new ArrayStoreException("Unexpected image type");		}		return;	}	int x1 = x;	int x2 = x + 1;	int y1 = y;	int y2 = y + 1;		if (x == nx-1)		x2 = x1;			if (y == ny-1)		y2 = y1; 	int offset;	switch(type) {	case BYTE:		byte[] bytePixels = getPixelsByte(); 		double v; 		offset = y1*nx;		v = (double)bytePixels[offset+x1]; 		neigh[0][0] = ((v<0)?(v+256.0):(v));		v = (double)bytePixels[offset+x2]; 		neigh[1][0] = ((v<0)?(v+256.0):(v)); 		offset = y2*nx;		v = (double)bytePixels[offset+x1]; 		neigh[0][1] =  ((v<0)?(v+256.0):(v));		v = (double)bytePixels[offset+x2]; 		neigh[1][1] =  ((v<0)?(v+256.0):(v));		break;	case SHORT:		short[] shortPixels = getPixelsShort(); 		offset = y1*nx;		neigh[0][0] = (double)shortPixels[offset+x1];		neigh[1][0] = (double)shortPixels[offset+x2]; 		offset = y2*nx;		neigh[0][1] = (double)shortPixels[offset+x1];		neigh[1][1] = (double)shortPixels[offset+x2];		break;	case FLOAT:		float[] floatPixels = getPixelsFloat(); 		offset = y1*nx;		neigh[0][0] = (double)floatPixels[offset+x1];		neigh[1][0] = (double)floatPixels[offset+x2]; 		offset = y2*nx;		neigh[0][1] = (double)floatPixels[offset+x1];		neigh[1][1] = (double)floatPixels[offset+x2];		break;	case DOUBLE:		offset = y1*nx;		neigh[0][0] = doublePixels[offset+x1];		neigh[1][0] = doublePixels[offset+x2]; 		offset = y2*nx;		neigh[0][1] = doublePixels[offset+x1];		neigh[1][1] = doublePixels[offset+x2];		break;	default: 		throw new ArrayStoreException("Unexpected image type");	}	}/*** An ImageAccess object calls this method for getting* a 3x3 neighborhood of "8-connected" pixels around a selected pixel.** After having the method executed the result is* in an array of the type double which is passed to the method* through the list of arguments.** <br>Mirror border conditions are applied.* <br>* <br>The pixel value of (x-1, y-1) are put into neigh[0]* <br>The pixel value of (x  , y-1) are put into neigh[1]* <br>The pixel value of (x+1, y-1) are put into neigh[2]* <br>The pixel value of (x-1, y  ) are put into neigh[3]* <br>The pixel value of (x  , y  ) are put into neigh[4]* <br>The pixel value of (x+1, y  ) are put into neigh[5]* <br>The pixel value of (x-1, y+1) are put into neigh[6]* <br>The pixel value of (x  , y+1) are put into neigh[7]* <br>The pixel value of (x+1, y+1) are put into neigh[8]** @param x			input, the integer x-coordinate of a selected central pixel* @param y			input, the integer y-coordinate of a selected central pixel* @param neigh		output, an array consisting of 9 elements of the type double*/public void getNeighborhood3(int x, int y, double neigh[]){	getNeighborhood3_8connected(x, y, neigh);}/*** An ImageAccess object calls this method for getting* a 3x3 neighborhood of "4-connected" or "8-connected" pixels* around a selected pixel.** The type of connectivity of the neighboring pixels can be selected.** After having the method executed the result is* in an array of the type double which is passed to the method* through the list of arguments.* <br>* <br>Mirror border conditions are applied.* <br>* <br>If the connect string is CONNECTIVITY_8* <br>The pixel value of (x-1, y-1) are put into neigh[0]* <br>The pixel value of (x  , y-1) are put into neigh[1]* <br>The pixel value of (x+1, y-1) are put into neigh[2]* <br>The pixel value of (x-1, y  ) are put into neigh[3]* <br>The pixel value of (x  , y  ) are put into neigh[4]* <br>The pixel value of (x+1, y  ) are put into neigh[5]* <br>The pixel value of (x-1, y+1) are put into neigh[6]* <br>The pixel value of (x  , y+1) are put into neigh[7]* <br>The pixel value of (x+1, y+1) are put into neigh[8]* <br>* <br>If the connect string is CONNECTIVITY_4* <br>The pixel value of (x  , y-1) are put into neigh[0]* <br>The pixel value of (x-1, y  ) are put into neigh[1]* <br>The pixel value of (x  , y  ) are put into neigh[2]* <br>The pixel value of (x+1, y  ) are put into neigh[3]* <br>The pixel value of (x  , y+1) are put into neigh[4]* @param x			input, the integer x-coordinate of a selected central pixel* @param y			input, the integer y-coordinate of a selected central pixel* @param neigh		output, an array consisting of 9 or 5 elements of the type double* @param connect	input, a selected type of connectivity ImageAccess.CONNECTIVITY_8 (default) or ImageAccess.CONNECTIVITY_4.*/public void getNeighborhood3(int x, int y, double neigh[], int connectivity){	if (connectivity == CONNECTIVITY_4)		getNeighborhood3_4connected(x, y, neigh);	else		getNeighborhood3_8connected(x, y, neigh);}/*** An ImageAccess object calls this method for getting* a 3x3 neighborhood of 8-connected pixels around a selected pixel.** After having the method executed the result is* in an array of the type double which is passed to the method* through the list of arguments.** Mirror border conditions are applied.** @param x		input, the integer x-coordinate of a selected central pixel* @param y		input, the integer y-coordinate of a selected central pixel* @param neigh	output, an array consisting of 9 elements of the type double*/private void getNeighborhood3_8connected(int x, int y, double neigh[]){	if ( x < 0) {    	int periodx = 2*nx - 2;						while (x < 0) x += periodx;		// Periodize		if (x >= nx)  x = periodx - x;	// Symmetrize	}	else if ( x >= nx) {    	int periodx = 2*nx - 2;						while (x >= nx) x -= periodx;	// Periodize		if (x < 0)  x = - x;			// Symmetrize	}	if ( y < 0) {    	int periody = 2*ny - 2;						while (y < 0) y += periody;		// Periodize		if (y >= ny)  y = periody - y;	// Symmetrize	}	else if ( y >= ny) {    	int periody = 2*ny - 2;						while (y >= ny) y -= periody;	// Periodize		if (y < 0)  y = - y;			// Symmetrize	} 	if (x >= 1) 	if (y >= 1) 	if (x < nx-1) 	if (y < ny-1) { 		int index = (y-1)*nx + (x-1);		switch(type) {		case BYTE:			byte[] bytePixels = getPixelsByte(); 			double v;			v = (double)bytePixels[index++]; 			neigh[0] = ((v<0)?(v+256.0):(v));			v = (double)bytePixels[index++]; 			neigh[1] = ((v<0)?(v+256.0):(v));			v = (double)bytePixels[index]; 			neigh[2] = ((v<0)?(v+256.0):(v));			index += (nx - 2);			v = (double)bytePixels[index++]; 			neigh[3] =  ((v<0)?(v+256.0):(v));			v = (double)bytePixels[index++]; 			neigh[4] =  ((v<0)?(v+256.0):(v));			v = (double)bytePixels[index]; 			neigh[5] =  ((v<0)?(v+256.0):(v));			index += (nx - 2);			v = (double)bytePixels[index++]; 			neigh[6] =  ((v<0)?(v+256.0):(v));			v = (double)bytePixels[index++]; 			neigh[7] =  ((v<0)?(v+256.0):(v));			v = (double)bytePixels[index]; 			neigh[8] =  ((v<0)?(v+256.0):(v));			break;		case SHORT:			short[] shortPixels = getPixelsShort();			neigh[0] = (double)shortPixels[index++];			neigh[1] = (double)shortPixels[index++];			neigh[2] = (double)shortPixels[index];			index += (nx - 2);			neigh[3] = (double)shortPixels[index++];			neigh[4] = (double)shortPixels[index++];			neigh[5] = (double)shortPixels[index];			index += (nx - 2);			neigh[6] = (double)shortPixels[index++];			neigh[7] = (double)shortPixels[index++];			neigh[8] = (double)shortPixels[index];			break;		case FLOAT:			float[] floatPixels = getPixelsFloat();			neigh[0] = (double)floatPixels[index++];			neigh[1] = (double)floatPixels[index++];			neigh[2] = (double)floatPixels[index];			index += (nx - 2);			neigh[3] = (double)floatPixels[index++];			neigh[4] = (double)floatPixels[index++];			neigh[5] = (double)floatPixels[index];			index += (nx - 2);			neigh[6] = (double)floatPixels[index++];			neigh[7] = (double)floatPixels[index++];			neigh[8] = (double)floatPixels[index];			break;		case DOUBLE:			neigh[0] = doublePixels[index++];			neigh[1] = doublePixels[index++];			neigh[2] = doublePixels[index];			index += (nx - 2);			neigh[3] = doublePixels[index++];			neigh[4] = doublePixels[index++];			neigh[5] = doublePixels[index];			index += (nx - 2);			neigh[6] = doublePixels[index++];			neigh[7] = doublePixels[index++];			neigh[8] = doublePixels[index];			break;		default: 			throw new ArrayStoreException("Unexpected image type");		}		return;	}		int x1 = x - 1;	int x2 = x;	int x3 = x + 1;	int y1 = y - 1;	int y2 = y;	int y3 = y + 1;		if ( x == 0)		x1 = x3;			if ( y == 0)		y1 = y3;	if ( x == nx-1)		x3 = x1;			if ( y == ny-1)		y3 = y1; 	int offset;	switch(type) {	case BYTE:		byte[] bytePixels = getPixelsByte(); 		double v; 		offset = y1*nx;		v = (double)bytePixels[offset+x1]; 		neigh[0] = ((v<0)?(v+256.0):(v));		v = (double)bytePixels[offset+x2]; 		neigh[1] = ((v<0)?(v+256.0):(v));		v = (double)bytePixels[offset+x3]; 		neigh[2] = ((v<0)?(v+256.0):(v)); 		offset = y2*nx;		v = (double)bytePixels[offset+x1]; 		neigh[3] =  ((v<0)?(v+256.0):(v));		v = (double)bytePixels[offset+x2]; 		neigh[4] =  ((v<0)?(v+256.0):(v));		v = (double)bytePixels[offset+x3]; 		neigh[5] =  ((v<0)?(v+256.0):(v)); 		offset = y3*nx;		v = (double)bytePixels[offset+x1]; 		neigh[6] =  ((v<0)?(v+256.0):(v));		v = (double)bytePixels[offset+x2]; 		neigh[7] =  ((v<0)?(v+256.0):(v));		v = (double)bytePixels[offset+x3]; 		neigh[8] =  ((v<0)?(v+256.0):(v));		break;	case SHORT:		short[] shortPixels = getPixelsShort(); 		offset = y1*nx;		neigh[0] = (double)shortPixels[offset+x1];		neigh[1] = (double)shortPixels[offset+x2];		neigh[2] = (double)shortPixels[offset+x3]; 		offset = y2*nx;		neigh[3] = (double)shortPixels[offset+x1];		neigh[4] = (double)shortPixels[offset+x2];		neigh[5] = (double)shortPixels[offset+x3];	 	offset = y3*nx;		neigh[6] = (double)shortPixels[offset+x1];		neigh[7] = (double)shortPixels[offset+x2];		neigh[8] = (double)shortPixels[offset+x3];		break;	case FLOAT:		float[] floatPixels = getPixelsFloat(); 		offset = y1*nx;		neigh[0] = (double)floatPixels[offset+x1];		neigh[1] = (double)floatPixels[offset+x2];		neigh[2] = (double)floatPixels[offset+x3]; 		offset = y2*nx;		neigh[3] = (double)floatPixels[offset+x1];		neigh[4] = (double)floatPixels[offset+x2];		neigh[5] = (double)floatPixels[offset+x3]; 		offset = y3*nx;		neigh[6] = (double)floatPixels[offset+x1];		neigh[7] = (double)floatPixels[offset+x2];		neigh[8] = (double)floatPixels[offset+x3];		break;	case DOUBLE: 		offset = y1*nx;		neigh[0] = doublePixels[offset+x1];		neigh[1] = doublePixels[offset+x2];		neigh[2] = doublePixels[offset+x3]; 		offset = y2*nx;		neigh[3] = doublePixels[offset+x1];		neigh[4] = doublePixels[offset+x2];		neigh[5] = doublePixels[offset+x3]; 		offset = y3*nx;		neigh[6] = doublePixels[offset+x1];		neigh[7] = doublePixels[offset+x2];		neigh[8] = doublePixels[offset+x3];		break;	default: 		throw new ArrayStoreException("Unexpected image type");	}}/*** An ImageAccess object calls this method for getting* a 3x3 neighborhood of 4-connected pixels around a selected pixel.** After having the method executed the result is* in an array of the type double which is passed to the method* through the list of arguments.** Mirror border conditions are applied.** @param x		input, the integer x-coordinate of a selected central pixel* @param y		input, the integer y-coordinate of a selected central pixel* @param neigh	output, an array consisting of 5 elements of the type double*/private void getNeighborhood3_4connected(int x, int y, double neigh[]){	if ( x < 0) {    	int periodx = 2*nx - 2;						while (x < 0) x += periodx;		// Periodize		if (x >= nx)  x = periodx - x;	// Symmetrize	}	else if ( x >= nx) {    	int periodx = 2*nx - 2;						while (x >= nx) x -= periodx;	// Periodize		if (x < 0)  x = - x;			// Symmetrize	}	if ( y < 0) {    	int periody = 2*ny - 2;						while (y < 0) y += periody;		// Periodize		if (y >= ny)  y = periody - y;	// Symmetrize	}	else if ( y >= ny) {    	int periody = 2*ny - 2;						while (y >= ny) y -= periody;	// Periodize		if (y < 0)  y = - y;			// Symmetrize	} 	if (x >= 1) 	if (y >= 1) 	if (x < nx-1) 	if (y < ny-1) { 		int index = (y-1)*nx + x;		switch(type) {		case BYTE:			byte[] bytePixels = getPixelsByte(); 			double v;			v = (double)bytePixels[index]; 			neigh[0] = ((v<0)?(v+256.0):(v));			index += (nx - 1);			v = (double)bytePixels[index++]; 			neigh[1] = ((v<0)?(v+256.0):(v));			v = (double)bytePixels[index++]; 			neigh[2] = ((v<0)?(v+256.0):(v));			v = (double)bytePixels[index]; 			neigh[3] =  ((v<0)?(v+256.0):(v));			index += (nx - 1);			v = (double)bytePixels[index]; 			neigh[4] =  ((v<0)?(v+256.0):(v));			break;		case SHORT:			short[] shortPixels = getPixelsShort();			neigh[0] = (double)shortPixels[index];			index += (nx - 1);			neigh[1] = (double)shortPixels[index++];			neigh[2] = (double)shortPixels[index++];			neigh[3] = (double)shortPixels[index];			index += (nx - 1);			neigh[4] = (double)shortPixels[index];			break;		case FLOAT:			float[] floatPixels = getPixelsFloat();			neigh[0] = (double)floatPixels[index];			index += (nx - 1);			neigh[1] = (double)floatPixels[index++];			neigh[2] = (double)floatPixels[index++];			neigh[3] = (double)floatPixels[index];			index += (nx - 1);			neigh[4] = (double)floatPixels[index];			break;		case DOUBLE:			neigh[0] = doublePixels[index];			index += (nx - 1);			neigh[1] = doublePixels[index++];			neigh[2] = doublePixels[index++];			neigh[3] = doublePixels[index];			index += (nx - 1);			neigh[4] = doublePixels[index];			break;		default: 			throw new ArrayStoreException("Unexpected image type");		}		return;	}		int x1 = x - 1;	int x2 = x;	int x3 = x + 1;	int y1 = y - 1;	int y2 = y;	int y3 = y + 1;		if ( x == 0)		x1 = x3;			if ( y == 0)		y1 = y3;	if ( x == nx-1)		x3 = x1;			if ( y == ny-1)		y3 = y1; 	int offset;	switch(type) {	case BYTE:		byte[] bytePixels = getPixelsByte(); 		double v; 		offset = y1*nx;		v = (double)bytePixels[offset+x2]; 		neigh[0] = ((v<0)?(v+256.0):(v)); 		offset = y2*nx;		v = (double)bytePixels[offset+x1]; 		neigh[1] =  ((v<0)?(v+256.0):(v));		v = (double)bytePixels[offset+x2]; 		neigh[2] =  ((v<0)?(v+256.0):(v));		v = (double)bytePixels[offset+x3]; 		neigh[3] =  ((v<0)?(v+256.0):(v)); 		offset = y3*nx;		v = (double)bytePixels[offset+x2]; 		neigh[4] =  ((v<0)?(v+256.0):(v));		break;	case SHORT:		short[] shortPixels = getPixelsShort(); 		offset = y1*nx;		neigh[0] = (double)shortPixels[offset+x2]; 		offset = y2*nx;		neigh[1] = (double)shortPixels[offset+x1];		neigh[2] = (double)shortPixels[offset+x2];		neigh[3] = (double)shortPixels[offset+x3];	 	offset = y3*nx;		neigh[4] = (double)shortPixels[offset+x2];		break;	case FLOAT:		float[] floatPixels = getPixelsFloat(); 		offset = y1*nx;		neigh[0] = (double)floatPixels[offset+x2]; 		offset = y2*nx;		neigh[1] = (double)floatPixels[offset+x1];		neigh[2] = (double)floatPixels[offset+x2];		neigh[3] = (double)floatPixels[offset+x3]; 		offset = y3*nx;		neigh[4] = (double)floatPixels[offset+x2];		break;	case DOUBLE: 		offset = y1*nx;		neigh[0] = doublePixels[offset+x2]; 		offset = y2*nx;		neigh[1] = doublePixels[offset+x1];		neigh[2] = doublePixels[offset+x2];		neigh[3] = doublePixels[offset+x3]; 		offset = y3*nx;		neigh[4] = doublePixels[offset+x2];		break;	default: 		throw new ArrayStoreException("Unexpected image type");	}}/*** An ImageAccess object calls this method for getting* a 3x3 neighborhood of "8-connected" pixels around a selected pixel.** After having the method executed the result is* in an array of the type double which is passed to the method* through the list of arguments.** <br>* <br>Mirror border conditions are applied.* <br>* <br>If the connect string is "8-connected" * <br>The pixel value of (x-1, y-1) are put into neigh[0][0]* <br>The pixel value of (x  , y-1) are put into neigh[1][0]* <br>The pixel value of (x+1, y-1) are put into neigh[2][0]* <br>The pixel value of (x-1, y  ) are put into neigh[0][1]* <br>The pixel value of (x  , y  ) are put into neigh[1][1]* <br>The pixel value of (x+1, y  ) are put into neigh[2][1]* <br>The pixel value of (x-1, y+1) are put into neigh[0][2]* <br>The pixel value of (x  , y+1) are put into neigh[1][2]* <br>The pixel value of (x+1, y+1) are put into neigh[2][2]** @param x		input, the integer x-coordinate of a selected central pixel* @param y		input, the integer y-coordinate of a selected central pixel* @param neigh	output, an array consisting of 3*3 elements of the type double*/public void getNeighborhood3x3(int x, int y, double neigh[][]){	if ( x < 0) {    	int periodx = 2*nx - 2;						while (x < 0) x += periodx;		// Periodize		if (x >= nx)  x = periodx - x;	// Symmetrize	}	else if ( x >= nx) {    	int periodx = 2*nx - 2;						while (x >= nx) x -= periodx;	// Periodize		if (x < 0)  x = - x;			// Symmetrize	}	if ( y < 0) {    	int periody = 2*ny - 2;						while (y < 0) y += periody;		// Periodize		if (y >= ny)  y = periody - y;	// Symmetrize	}	else if ( y >= ny) {    	int periody = 2*ny - 2;						while (y >= ny) y -= periody;	// Periodize		if (y < 0)  y = - y;			// Symmetrize	} 	if (x >= 1) 	if (y >= 1) 	if (x < nx-1) 	if (y < ny-1) { 		int index = (y-1)*nx + (x-1);		switch(type) {				case BYTE:			byte[] bytePixels = getPixelsByte(); 			double v;			v = (double)bytePixels[index++]; 			neigh[0][0] = ((v<0)?(v+256.0):(v));			v = (double)bytePixels[index++]; 			neigh[1][0] = ((v<0)?(v+256.0):(v));			v = (double)bytePixels[index]; 			neigh[2][0] = ((v<0)?(v+256.0):(v));			index += (nx - 2);			v = (double)bytePixels[index++]; 			neigh[0][1] =  ((v<0)?(v+256.0):(v));			v = (double)bytePixels[index++]; 			neigh[1][1] =  ((v<0)?(v+256.0):(v));			v = (double)bytePixels[index]; 			neigh[2][1] =  ((v<0)?(v+256.0):(v));			index += (nx - 2);			v = (double)bytePixels[index++]; 			neigh[0][2] =  ((v<0)?(v+256.0):(v));			v = (double)bytePixels[index++]; 			neigh[1][2] =  ((v<0)?(v+256.0):(v));			v = (double)bytePixels[index]; 			neigh[2][2] =  ((v<0)?(v+256.0):(v));			break;					case SHORT:			short[] shortPixels = getPixelsShort();			neigh[0][0] = (double)shortPixels[index++];			neigh[1][0] = (double)shortPixels[index++];			neigh[2][0] = (double)shortPixels[index];			index += (nx - 2);			neigh[0][1] = (double)shortPixels[index++];			neigh[1][1] = (double)shortPixels[index++];			neigh[2][1] = (double)shortPixels[index];			index += (nx - 2);			neigh[0][2] = (double)shortPixels[index++];			neigh[1][2] = (double)shortPixels[index++];			neigh[2][2] = (double)shortPixels[index];			break;				case FLOAT:			float[] floatPixels = getPixelsFloat();			neigh[0][0] = (double)floatPixels[index++];			neigh[1][0] = (double)floatPixels[index++];			neigh[2][0] = (double)floatPixels[index];			index += (nx - 2);			neigh[0][1] = (double)floatPixels[index++];			neigh[1][1] = (double)floatPixels[index++];			neigh[2][1] = (double)floatPixels[index];			index += (nx - 2);			neigh[0][2] = (double)floatPixels[index++];			neigh[1][2] = (double)floatPixels[index++];			neigh[2][2] = (double)floatPixels[index];			break;					case DOUBLE:			neigh[0][0] = doublePixels[index++];			neigh[1][0] = doublePixels[index++];			neigh[2][0] = doublePixels[index];			index += (nx - 2);			neigh[0][1] = doublePixels[index++];			neigh[1][1] = doublePixels[index++];			neigh[2][1] = doublePixels[index];			index += (nx - 2);			neigh[0][2] = doublePixels[index++];			neigh[1][2] = doublePixels[index++];			neigh[2][2] = doublePixels[index];			break;					default: 			throw new ArrayStoreException("Unexpected image type");		}		return;	}		int x1 = x - 1;	int x2 = x;	int x3 = x + 1;	int y1 = y - 1;	int y2 = y;	int y3 = y + 1;		if ( x == 0)		x1 = x3;			if ( y == 0)		y1 = y3;	if ( x == nx-1)		x3 = x1;			if ( y == ny-1)		y3 = y1;	int offset;	switch(type) {		case BYTE:		byte[] bytePixels = getPixelsByte(); 		double v;  		offset = y1*nx;		v = (double)bytePixels[offset+x1]; 		neigh[0][0] = ((v<0)?(v+256.0):(v));		v = (double)bytePixels[offset+x2]; 		neigh[1][0] = ((v<0)?(v+256.0):(v));		v = (double)bytePixels[offset+x3]; 		neigh[2][0] = ((v<0)?(v+256.0):(v)); 		offset = y2*nx;		v = (double)bytePixels[offset+x1]; 		neigh[0][1] =  ((v<0)?(v+256.0):(v));		v = (double)bytePixels[offset+x2]; 		neigh[1][1] =  ((v<0)?(v+256.0):(v));		v = (double)bytePixels[offset+x3]; 		neigh[2][1] =  ((v<0)?(v+256.0):(v)); 		offset = y3*nx;		v = (double)bytePixels[offset+x1]; 		neigh[0][2] =  ((v<0)?(v+256.0):(v));		v = (double)bytePixels[offset+x2]; 		neigh[1][2] =  ((v<0)?(v+256.0):(v));		v = (double)bytePixels[offset+x3]; 		neigh[2][2] =  ((v<0)?(v+256.0):(v));		break;			case SHORT:		short[] shortPixels = getPixelsShort();		offset = y1*nx;		neigh[0][0] = (double)shortPixels[offset+x1];		neigh[1][0] = (double)shortPixels[offset+x2];		neigh[2][0] = (double)shortPixels[offset+x3]; 		offset = y2*nx;		neigh[0][1] = (double)shortPixels[offset+x1];		neigh[1][1] = (double)shortPixels[offset+x2];		neigh[2][1] = (double)shortPixels[offset+x3];	 	offset = y3*nx;		neigh[0][2] = (double)shortPixels[offset+x1];		neigh[1][2] = (double)shortPixels[offset+x2];		neigh[2][2] = (double)shortPixels[offset+x3];		break;			case FLOAT:		float[] floatPixels = getPixelsFloat(); 		offset = y1*nx;		neigh[0][0] = (double)floatPixels[offset+x1];		neigh[1][0] = (double)floatPixels[offset+x2];		neigh[2][0] = (double)floatPixels[offset+x3]; 		offset = y2*nx;		neigh[0][1] = (double)floatPixels[offset+x1];		neigh[1][1] = (double)floatPixels[offset+x2];		neigh[2][1] = (double)floatPixels[offset+x3]; 		offset = y3*nx;		neigh[0][2] = (double)floatPixels[offset+x1];		neigh[1][2] = (double)floatPixels[offset+x2];		neigh[2][2] = (double)floatPixels[offset+x3];		break;			case DOUBLE: 		offset = y1*nx;		neigh[0][0] = doublePixels[offset+x1];		neigh[1][0] = doublePixels[offset+x2];		neigh[2][0] = doublePixels[offset+x3]; 		offset = y2*nx;		neigh[0][1] = doublePixels[offset+x1];		neigh[1][1] = doublePixels[offset+x2];		neigh[2][1] = doublePixels[offset+x3]; 		offset = y3*nx;		neigh[0][2] = doublePixels[offset+x1];		neigh[1][2] = doublePixels[offset+x2];		neigh[2][2] = doublePixels[offset+x3];		break;				default: 		throw new ArrayStoreException("Unexpected image type");	}}/*** An ImageAccess object calls this method for getting* a 3x3 neighborhood of "8-connected" pixels around a selected pixel.** After having the method executed the result is* in an array of the type double.** <br>* <br>Mirror border conditions are applied.* <br>* <br>If the connect string is "8-connected" * <br>The pixel value of (x-1, y-1) are put into neigh[0][0]* <br>The pixel value of (x  , y-1) are put into neigh[1][0]* <br>The pixel value of (x+1, y-1) are put into neigh[2][0]* <br>The pixel value of (x-1, y  ) are put into neigh[0][1]* <br>The pixel value of (x  , y  ) are put into neigh[1][1]* <br>The pixel value of (x+1, y  ) are put into neigh[2][1]* <br>The pixel value of (x-1, y+1) are put into neigh[0][2]* <br>The pixel value of (x  , y+1) are put into neigh[1][2]* <br>The pixel value of (x+1, y+1) are put into neigh[2][2]** @param x		input, the integer x-coordinate of a selected central pixel* @param y		input, the integer y-coordinate of a selected central pixel* @return neigh	output, an array consisting of 3*3 elements of the type double*/public double[][] getNeighborhood3x3(int x, int y){	double neigh[][] = new double[3][3];	getNeighborhood3x3( x, y, neigh);	return neigh;}/*** An ImageAccess object calls this method for getting a 5x5 neighborhood* of a selected pixel.** After having the method executed the result is* in an array of the type double which is passed to the method* through the list of arguments.** <br>Mirror border conditions are applied.* <br>* <br>The pixels value returned are organized row by row.* <br> * <br>The pixel value of (x-2, y-2) are put into neigh[0]* <br>The pixel value of (x-1, y-2) are put into neigh[1]* <br>...* <br>The pixel value of (x+2, y+2) are put into neigh[24]** @param x		input, the integer x-coordinate of a selected central pixel* @param y		input, the integer y-coordinate of a selected central pixel* @param neigh	output, an array consisting of 25 elements of the type double*/public void getNeighborhood5(int x, int y, double neigh[]){		if ( x < 0) {    	int periodx = 2*nx - 2;						while (x < 0) x += periodx;		// Periodize		if (x >= nx)  x = periodx - x;	// Symmetrize	}	else if ( x >= nx) {    	int periodx = 2*nx - 2;						while (x >= nx) x -= periodx;	// Periodize		if (x < 0)  x = - x;			// Symmetrize	}	if ( y < 0) {    	int periody = 2*ny - 2;						while (y < 0) y += periody;		// Periodize		if (y >= ny)  y = periody - y;	// Symmetrize	}	else if ( y >= ny) {    	int periody = 2*ny - 2;						while (y >= ny) y -= periody;	// Periodize		if (y < 0)  y = - y;			// Symmetrize	} 	if (x >= 2) 	if (y >= 2) 	if (x < nx-2) 	if (y < ny-2) { 		int index = (y-2)*nx + (x-2);		switch(type) {				case BYTE:			byte[] bytePixels = getPixelsByte(); 			double v;			v = (double)bytePixels[index++]; 			neigh[0] = ((v<0)?(v+256.0):(v));			v = (double)bytePixels[index++]; 			neigh[1] = ((v<0)?(v+256.0):(v));			v = (double)bytePixels[index++]; 			neigh[2] = ((v<0)?(v+256.0):(v));			v = (double)bytePixels[index++]; 			neigh[3] = ((v<0)?(v+256.0):(v));						v = (double)bytePixels[index]; 			neigh[4] = ((v<0)?(v+256.0):(v));			index += (nx - 4);			v = (double)bytePixels[index++]; 			neigh[5] =  ((v<0)?(v+256.0):(v));			v = (double)bytePixels[index++]; 			neigh[6] =  ((v<0)?(v+256.0):(v));			v = (double)bytePixels[index++]; 			neigh[7] =  ((v<0)?(v+256.0):(v));			v = (double)bytePixels[index++]; 			neigh[8] =  ((v<0)?(v+256.0):(v));						v = (double)bytePixels[index]; 			neigh[9] =  ((v<0)?(v+256.0):(v));			index += (nx - 4);			v = (double)bytePixels[index++]; 			neigh[10] =  ((v<0)?(v+256.0):(v));			v = (double)bytePixels[index++]; 			neigh[11] =  ((v<0)?(v+256.0):(v));			v = (double)bytePixels[index++]; 			neigh[12] =  ((v<0)?(v+256.0):(v));			v = (double)bytePixels[index++]; 			neigh[13] =  ((v<0)?(v+256.0):(v));						v = (double)bytePixels[index]; 			neigh[14] =  ((v<0)?(v+256.0):(v));			index += (nx - 4);			v = (double)bytePixels[index++]; 			neigh[15] =  ((v<0)?(v+256.0):(v));			v = (double)bytePixels[index++]; 			neigh[16] =  ((v<0)?(v+256.0):(v));			v = (double)bytePixels[index++]; 			neigh[17] =  ((v<0)?(v+256.0):(v));			v = (double)bytePixels[index++]; 			neigh[18] =  ((v<0)?(v+256.0):(v));						v = (double)bytePixels[index]; 			neigh[19] =  ((v<0)?(v+256.0):(v));			index += (nx - 4);			v = (double)bytePixels[index++]; 			neigh[20] =  ((v<0)?(v+256.0):(v));			v = (double)bytePixels[index++]; 			neigh[21] =  ((v<0)?(v+256.0):(v));			v = (double)bytePixels[index++]; 			neigh[22] =  ((v<0)?(v+256.0):(v));			v = (double)bytePixels[index++]; 			neigh[23] =  ((v<0)?(v+256.0):(v));						v = (double)bytePixels[index]; 			neigh[24] =  ((v<0)?(v+256.0):(v));			break;					case SHORT:			short[] shortPixels = getPixelsShort();			neigh[0] = (double)shortPixels[index++];						neigh[1] = (double)shortPixels[index++];						neigh[2] = (double)shortPixels[index++];					neigh[3] = (double)shortPixels[index++];					neigh[4] = (double)shortPixels[index];			index += (nx - 4);			neigh[5] =  (double)shortPixels[index++];						neigh[6] =  (double)shortPixels[index++];						neigh[7] =  (double)shortPixels[index++];						neigh[8] =  (double)shortPixels[index++];						neigh[9] =  (double)shortPixels[index];			index += (nx - 4);			neigh[10] =  (double)shortPixels[index++];						neigh[11] =  (double)shortPixels[index++];						neigh[12] =  (double)shortPixels[index++];						neigh[13] =  (double)shortPixels[index++];					neigh[14] =  (double)shortPixels[index];			index += (nx - 4);			neigh[15] =  (double)shortPixels[index++];						neigh[16] =  (double)shortPixels[index++];						neigh[17] =  (double)shortPixels[index++];						neigh[18] =  (double)shortPixels[index++];						neigh[19] =  (double)shortPixels[index];			index += (nx - 4);			neigh[20] =  (double)shortPixels[index++];						neigh[21] =  (double)shortPixels[index++];			 			neigh[22] =  (double)shortPixels[index++];			 			neigh[23] =  (double)shortPixels[index++];			 			neigh[24] =  (double)shortPixels[index];					break;				case FLOAT:			float[] floatPixels = getPixelsFloat();			neigh[0] = (double)floatPixels[index++];						neigh[1] = (double)floatPixels[index++];						neigh[2] = (double)floatPixels[index++];					neigh[3] = (double)floatPixels[index++];					neigh[4] = (double)floatPixels[index];			index += (nx - 4);			neigh[5] =  (double)floatPixels[index++];						neigh[6] =  (double)floatPixels[index++];						neigh[7] =  (double)floatPixels[index++];						neigh[8] =  (double)floatPixels[index++];						neigh[9] =  (double)floatPixels[index];			index += (nx - 4);			neigh[10] =  (double)floatPixels[index++];						neigh[11] =  (double)floatPixels[index++];						neigh[12] =  (double)floatPixels[index++];						neigh[13] =  (double)floatPixels[index++];					neigh[14] =  (double)floatPixels[index];			index += (nx - 4);						neigh[15] =  (double)floatPixels[index++];						neigh[16] =  (double)floatPixels[index++];						neigh[17] =  (double)floatPixels[index++];						neigh[18] =  (double)floatPixels[index++];						neigh[19] =  (double)floatPixels[index];			index += (nx - 4);						neigh[20] =  (double)floatPixels[index++];						neigh[21] =  (double)floatPixels[index++];			 			neigh[22] =  (double)floatPixels[index++];			 			neigh[23] =  (double)floatPixels[index++];			 			neigh[24] =  (double)floatPixels[index];			break;							case DOUBLE:			neigh[0] = doublePixels[index++];						neigh[1] = doublePixels[index++];						neigh[2] = doublePixels[index++];					neigh[3] = doublePixels[index++];					neigh[4] = doublePixels[index];			index += (nx - 4);			neigh[5] =  doublePixels[index++];						neigh[6] =  doublePixels[index++];						neigh[7] =  doublePixels[index++];						neigh[8] =  doublePixels[index++];						neigh[9] =  doublePixels[index];			index += (nx - 4);			neigh[10] =  doublePixels[index++];						neigh[11] =  doublePixels[index++];						neigh[12] =  doublePixels[index++];						neigh[13] =  doublePixels[index++];					neigh[14] =  doublePixels[index];			index += (nx - 4);						neigh[15] =  doublePixels[index++];						neigh[16] =  doublePixels[index++];						neigh[17] =  doublePixels[index++];						neigh[18] =  doublePixels[index++];						neigh[19] =  doublePixels[index];			index += (nx - 4);						neigh[20] =  doublePixels[index++];						neigh[21] =  doublePixels[index++];			 			neigh[22] =  doublePixels[index++];			 			neigh[23] =  doublePixels[index++];			 			neigh[24] =  doublePixels[index];			break;							default: 			throw new ArrayStoreException("Unexpected image type");		}		return;	}		int x1 = x - 2;	int x2 = x - 1;	int x3 = x;	int x4 = x + 1;	int x5 = x + 2;		int y1 = y - 2;	int y2 = y - 1;	int y3 = y;	int y4 = y + 1;	int y5 = y + 2;		if ( x == 0) {		x2 = x4;		x1 = x5;			}		else if ( x == 1) {		x1 = x3;			}			else if ( x == nx-1) {		x4 = x2; 		x5 = x1; 	}		else if (x == nx-2) { 		x5 = x3; 	}				if ( y == 0) {		y2 = y4;		y1 = y5;	}		else if ( y == 1) {		y1 = y3;	}	else if ( y == ny-1) {		y4 = y2; 		y5 = y1; 	}		else if (y == ny-2) {		y5 = y3; 	} 	int offset;	switch(type) {		case BYTE:		byte[] bytePixels = getPixelsByte(); 		double v; 		offset = y1*nx;		v = (double)bytePixels[offset+x1];		neigh[0] = ((v<0)?(v+256.0):(v));		v = (double)bytePixels[offset+x2];		neigh[1] = ((v<0)?(v+256.0):(v));		v = (double)bytePixels[offset+x3];		neigh[2] = ((v<0)?(v+256.0):(v));		v = (double)bytePixels[offset+x4];		neigh[3] = ((v<0)?(v+256.0):(v));					v = (double)bytePixels[offset+x5]; 		neigh[4] = ((v<0)?(v+256.0):(v));		offset = y2*nx;			v = (double)bytePixels[offset+x1]; 		neigh[5] =  ((v<0)?(v+256.0):(v));		v = (double)bytePixels[offset+x2];		neigh[6] =  ((v<0)?(v+256.0):(v));		v = (double)bytePixels[offset+x3];		neigh[7] =  ((v<0)?(v+256.0):(v));		v = (double)bytePixels[offset+x4]; 		neigh[8] =  ((v<0)?(v+256.0):(v));					v = (double)bytePixels[offset+x5]; 		neigh[9] =  ((v<0)?(v+256.0):(v));		offset = y3*nx;			v = (double)bytePixels[offset+x1]; 		neigh[10] =  ((v<0)?(v+256.0):(v));		v = (double)bytePixels[offset+x2];  		neigh[11] =  ((v<0)?(v+256.0):(v));		v = (double)bytePixels[offset+x3];  		neigh[12] =  ((v<0)?(v+256.0):(v));		v = (double)bytePixels[offset+x4];  		neigh[13] =  ((v<0)?(v+256.0):(v));					v = (double)bytePixels[offset+x5];  		neigh[14] =  ((v<0)?(v+256.0):(v));					offset = y4*nx;			v = (double)bytePixels[offset+x1]; 		neigh[15] =  ((v<0)?(v+256.0):(v));		v = (double)bytePixels[offset+x2]; 		neigh[16] =  ((v<0)?(v+256.0):(v));		v = (double)bytePixels[offset+x3]; 		neigh[17] =  ((v<0)?(v+256.0):(v));		v = (double)bytePixels[offset+x4]; 		neigh[18] =  ((v<0)?(v+256.0):(v));					v = (double)bytePixels[offset+x5]; 		neigh[19] =  ((v<0)?(v+256.0):(v));		offset = y5*nx;			v = (double)bytePixels[offset+x1];		neigh[20] =  ((v<0)?(v+256.0):(v));		v = (double)bytePixels[offset+x2];		neigh[21] =  ((v<0)?(v+256.0):(v));		v = (double)bytePixels[offset+x3];		neigh[22] =  ((v<0)?(v+256.0):(v));		v = (double)bytePixels[offset+x4]; 		neigh[23] =  ((v<0)?(v+256.0):(v));					v = (double)bytePixels[offset+x5];		neigh[24] =  ((v<0)?(v+256.0):(v));				break;			case SHORT:		short[] shortPixels = getPixelsShort();		offset = y1*nx;		neigh[0] = (double)shortPixels[offset+x1];		neigh[1] = (double)shortPixels[offset+x2];		neigh[2] = (double)shortPixels[offset+x3];		neigh[3] = (double)shortPixels[offset+x4];					neigh[4] = (double)shortPixels[offset+x5]; 				offset = y2*nx;			neigh[5] = (double)shortPixels[offset+x1]; 		neigh[6] = (double)shortPixels[offset+x2];		neigh[7] = (double)shortPixels[offset+x3];		neigh[8] = (double)shortPixels[offset+x4]; 					neigh[9] = (double)shortPixels[offset+x5]; 		offset = y3*nx;			neigh[10] = (double)shortPixels[offset+x1]; 		neigh[11] = (double)shortPixels[offset+x2];  		neigh[12] = (double)shortPixels[offset+x3]; 		neigh[13] = (double)shortPixels[offset+x4];  					neigh[14] = (double)shortPixels[offset+x5];  		offset = y4*nx;			neigh[15] = (double)shortPixels[offset+x1]; 		neigh[16] = (double)shortPixels[offset+x2]; 		neigh[17] = (double)shortPixels[offset+x3]; 		neigh[18] = (double)shortPixels[offset+x4]; 					neigh[19] = (double)shortPixels[offset+x5]; 		offset = y5*nx;			neigh[20] = (double)shortPixels[offset+x1];		neigh[21] = (double)shortPixels[offset+x2];		neigh[22] = (double)shortPixels[offset+x3];		neigh[23] = (double)shortPixels[offset+x4]; 						neigh[24] = (double)shortPixels[offset+x5];		break;			case FLOAT:		float[] floatPixels = getPixelsFloat();		offset = y1*nx;		neigh[0] = (double)floatPixels[offset+x1];		neigh[1] = (double)floatPixels[offset+x2];		neigh[2] = (double)floatPixels[offset+x3];		neigh[3] = (double)floatPixels[offset+x4];					neigh[4] = (double)floatPixels[offset+x5]; 				offset = y2*nx;			neigh[5] = (double)floatPixels[offset+x1]; 		neigh[6] = (double)floatPixels[offset+x2];		neigh[7] = (double)floatPixels[offset+x3];		neigh[8] = (double)floatPixels[offset+x4]; 					neigh[9] = (double)floatPixels[offset+x5]; 		offset = y3*nx;			neigh[10] = (double)floatPixels[offset+x1]; 		neigh[11] = (double)floatPixels[offset+x2];  		neigh[12] = (double)floatPixels[offset+x3]; 		neigh[13] = (double)floatPixels[offset+x4];  					neigh[14] = (double)floatPixels[offset+x5];  		offset = y4*nx;			neigh[15] = (double)floatPixels[offset+x1]; 		neigh[16] = (double)floatPixels[offset+x2]; 		neigh[17] = (double)floatPixels[offset+x3]; 		neigh[18] = (double)floatPixels[offset+x4]; 					neigh[19] = (double)floatPixels[offset+x5]; 		offset = y5*nx;			neigh[20] = (double)floatPixels[offset+x1];		neigh[21] = (double)floatPixels[offset+x2];		neigh[22] = (double)floatPixels[offset+x3];		neigh[23] = (double)floatPixels[offset+x4]; 						neigh[24] = (double)floatPixels[offset+x5];		break;					case DOUBLE:		offset = y1*nx;		neigh[0] = doublePixels[offset+x1];		neigh[1] = doublePixels[offset+x2];		neigh[2] = doublePixels[offset+x3];		neigh[3] = doublePixels[offset+x4];					neigh[4] = doublePixels[offset+x5]; 				offset = y2*nx;			neigh[5] = doublePixels[offset+x1]; 		neigh[6] = doublePixels[offset+x2];		neigh[7] = doublePixels[offset+x3];		neigh[8] = doublePixels[offset+x4]; 					neigh[9] = doublePixels[offset+x5]; 		offset = y3*nx;			neigh[10] = doublePixels[offset+x1]; 		neigh[11] = doublePixels[offset+x2];  		neigh[12] = doublePixels[offset+x3]; 		neigh[13] = doublePixels[offset+x4];  					neigh[14] = doublePixels[offset+x5];  		offset = y4*nx;			neigh[15] = doublePixels[offset+x1]; 		neigh[16] = doublePixels[offset+x2]; 		neigh[17] = doublePixels[offset+x3]; 		neigh[18] = doublePixels[offset+x4]; 					neigh[19] = doublePixels[offset+x5]; 		offset = y5*nx;			neigh[20] = doublePixels[offset+x1];		neigh[21] = doublePixels[offset+x2];		neigh[22] = doublePixels[offset+x3];		neigh[23] = doublePixels[offset+x4]; 						neigh[24] = doublePixels[offset+x5];		break;					default: 		throw new ArrayStoreException("Unexpected image type");	}}/*** An ImageAccess object calls this method for getting a 5x5 neighborhood* of a selected pixel.** After having the method executed the result is* in an array of the type double which is passed to the method* through the list of arguments.** <br>Mirror border conditions are applied.* <br>* <br>The pixels value returned are organized row by row.* <br> * <br>The pixel value of (x-2, y-2) are put into neigh[0][0]* <br>The pixel value of (x-1, y-2) are put into neigh[1][0]* <br>...* <br>The pixel value of (x+2, y+2) are put into neigh[4][4]** @param x		input, the integer x-coordinate of a selected central pixel* @param y		input, the integer y-coordinate of a selected central pixel* @param neigh	output, an array consisting of 5*5 elements of the type double*/public void getNeighborhood5x5(int x, int y, double neigh[][]){	if ( x < 0) {    	int periodx = 2*nx - 2;						while (x < 0) x += periodx;		// Periodize		if (x >= nx)  x = periodx - x;	// Symmetrize	}	else if ( x >= nx) {    	int periodx = 2*nx - 2;						while (x >= nx) x -= periodx;	// Periodize		if (x < 0)  x = - x;			// Symmetrize	}	if ( y < 0) {    	int periody = 2*ny - 2;						while (y < 0) y += periody;		// Periodize		if (y >= ny)  y = periody - y;	// Symmetrize	}	else if ( y >= ny) {    	int periody = 2*ny - 2;						while (y >= ny) y -= periody;	// Periodize		if (y < 0)  y = - y;			// Symmetrize	} 	if (x >= 2) 	if (y >= 2) 	if (x < nx-2) 	if (y < ny-2) { 		int index = (y-2)*nx + (x-2);		switch(type) {				case BYTE:			byte[] bytePixels = getPixelsByte(); 			double v;			v = (double)bytePixels[index++]; 			neigh[0][0] = ((v<0)?(v+256.0):(v));			v = (double)bytePixels[index++]; 			neigh[1][0] = ((v<0)?(v+256.0):(v));			v = (double)bytePixels[index++]; 			neigh[2][0] = ((v<0)?(v+256.0):(v));			v = (double)bytePixels[index++]; 			neigh[3][0] = ((v<0)?(v+256.0):(v));						v = (double)bytePixels[index]; 			neigh[4][0] = ((v<0)?(v+256.0):(v));			index += (nx - 4);			v = (double)bytePixels[index++]; 			neigh[0][1] =  ((v<0)?(v+256.0):(v));			v = (double)bytePixels[index++]; 			neigh[1][1] =  ((v<0)?(v+256.0):(v));			v = (double)bytePixels[index++]; 			neigh[2][1] =  ((v<0)?(v+256.0):(v));			v = (double)bytePixels[index++]; 			neigh[3][1] =  ((v<0)?(v+256.0):(v));						v = (double)bytePixels[index]; 			neigh[4][1] =  ((v<0)?(v+256.0):(v));			index += (nx - 4);			v = (double)bytePixels[index++]; 			neigh[0][2] =  ((v<0)?(v+256.0):(v));			v = (double)bytePixels[index++]; 			neigh[1][2] =  ((v<0)?(v+256.0):(v));			v = (double)bytePixels[index++]; 			neigh[2][2] =  ((v<0)?(v+256.0):(v));			v = (double)bytePixels[index++]; 			neigh[3][2] =  ((v<0)?(v+256.0):(v));						v = (double)bytePixels[index]; 			neigh[4][2] =  ((v<0)?(v+256.0):(v));			index += (nx - 4);			v = (double)bytePixels[index++]; 			neigh[0][3] =  ((v<0)?(v+256.0):(v));			v = (double)bytePixels[index++]; 			neigh[1][3] =  ((v<0)?(v+256.0):(v));			v = (double)bytePixels[index++]; 			neigh[2][3] =  ((v<0)?(v+256.0):(v));			v = (double)bytePixels[index++]; 			neigh[3][3] =  ((v<0)?(v+256.0):(v));						v = (double)bytePixels[index]; 			neigh[4][3] =  ((v<0)?(v+256.0):(v));			index += (nx - 4);			v = (double)bytePixels[index++]; 			neigh[0][4] =  ((v<0)?(v+256.0):(v));			v = (double)bytePixels[index++]; 			neigh[1][4] =  ((v<0)?(v+256.0):(v));			v = (double)bytePixels[index++]; 			neigh[2][4] =  ((v<0)?(v+256.0):(v));			v = (double)bytePixels[index++]; 			neigh[3][4] =  ((v<0)?(v+256.0):(v));						v = (double)bytePixels[index]; 			neigh[4][4] =  ((v<0)?(v+256.0):(v));			break;					case SHORT:			short[] shortPixels = getPixelsShort();			neigh[0][0] = (double)shortPixels[index++];						neigh[1][0] = (double)shortPixels[index++];						neigh[2][0] = (double)shortPixels[index++];					neigh[3][0] = (double)shortPixels[index++];					neigh[4][0] = (double)shortPixels[index];			index += (nx - 4);			neigh[0][1] =  (double)shortPixels[index++];						neigh[1][1] =  (double)shortPixels[index++];						neigh[2][1] =  (double)shortPixels[index++];						neigh[3][1] =  (double)shortPixels[index++];						neigh[4][1] =  (double)shortPixels[index];			index += (nx - 4);			neigh[0][2] =  (double)shortPixels[index++];						neigh[1][2] =  (double)shortPixels[index++];						neigh[2][2] =  (double)shortPixels[index++];						neigh[3][2] =  (double)shortPixels[index++];					neigh[4][2] =  (double)shortPixels[index];			index += (nx - 4);			neigh[0][3] =  (double)shortPixels[index++];						neigh[1][3] =  (double)shortPixels[index++];						neigh[2][3] =  (double)shortPixels[index++];						neigh[3][3] =  (double)shortPixels[index++];						neigh[4][3] =  (double)shortPixels[index];			index += (nx - 4);			neigh[0][4] =  (double)shortPixels[index++];						neigh[1][4] =  (double)shortPixels[index++];			 			neigh[2][4] =  (double)shortPixels[index++];			 			neigh[3][4] =  (double)shortPixels[index++];			 			neigh[4][4] =  (double)shortPixels[index];					break;				case FLOAT:			float[] floatPixels = getPixelsFloat();			neigh[0][0] = (double)floatPixels[index++];						neigh[1][0] = (double)floatPixels[index++];						neigh[2][0] = (double)floatPixels[index++];					neigh[3][0] = (double)floatPixels[index++];					neigh[4][0] = (double)floatPixels[index];			index += (nx - 4);			neigh[0][1] =  (double)floatPixels[index++];						neigh[1][1] =  (double)floatPixels[index++];						neigh[2][1] =  (double)floatPixels[index++];						neigh[3][1] =  (double)floatPixels[index++];						neigh[4][1] =  (double)floatPixels[index];			index += (nx - 4);			neigh[0][2] =  (double)floatPixels[index++];						neigh[1][2] =  (double)floatPixels[index++];						neigh[2][2] =  (double)floatPixels[index++];						neigh[3][2] =  (double)floatPixels[index++];					neigh[4][2] =  (double)floatPixels[index];			index += (nx - 4);						neigh[0][3] =  (double)floatPixels[index++];						neigh[1][3] =  (double)floatPixels[index++];						neigh[2][3] =  (double)floatPixels[index++];						neigh[3][3] =  (double)floatPixels[index++];						neigh[4][3] =  (double)floatPixels[index];			index += (nx - 4);						neigh[0][4] =  (double)floatPixels[index++];						neigh[1][4] =  (double)floatPixels[index++];			 			neigh[2][4] =  (double)floatPixels[index++];			 			neigh[3][4] =  (double)floatPixels[index++];			 			neigh[4][4] =  (double)floatPixels[index];			break;							case DOUBLE:			neigh[0][0] = doublePixels[index++];						neigh[1][0] = doublePixels[index++];						neigh[2][0] = doublePixels[index++];					neigh[3][0] = doublePixels[index++];					neigh[4][0] = doublePixels[index];			index += (nx - 4);			neigh[0][1] =  doublePixels[index++];						neigh[1][1] =  doublePixels[index++];						neigh[2][1] =  doublePixels[index++];						neigh[3][1] =  doublePixels[index++];						neigh[4][1] =  doublePixels[index];			index += (nx - 4);			neigh[0][2] =  doublePixels[index++];						neigh[1][2] =  doublePixels[index++];						neigh[2][2] =  doublePixels[index++];						neigh[3][2] =  doublePixels[index++];					neigh[4][2] =  doublePixels[index];			index += (nx - 4);						neigh[0][3] =  doublePixels[index++];						neigh[1][3] =  doublePixels[index++];						neigh[2][3] =  doublePixels[index++];						neigh[3][3] =  doublePixels[index++];						neigh[4][3] =  doublePixels[index];			index += (nx - 4);						neigh[0][4] =  doublePixels[index++];						neigh[1][4] =  doublePixels[index++];			 			neigh[2][4] =  doublePixels[index++];			 			neigh[3][4] =  doublePixels[index++];			 			neigh[4][4] =  doublePixels[index];			break;							default: 			throw new ArrayStoreException("Unexpected image type");		}		return;	}		int x1 = x - 2;	int x2 = x - 1;	int x3 = x;	int x4 = x + 1;	int x5 = x + 2;		int y1 = y - 2;	int y2 = y - 1;	int y3 = y;	int y4 = y + 1;	int y5 = y + 2;		if ( x == 0) {		x2 = x4;		x1 = x5;			}		else if ( x == 1) {		x1 = x3;			}			else if ( x == nx-1) {		x4 = x2; 		x5 = x1; 	}		else if (x == nx-2) { 		x5 = x3; 	}				if ( y == 0) {		y2 = y4;		y1 = y5;	}		else if ( y == 1) {		y1 = y3;	}	else if ( y == ny-1) {		y4 = y2; 		y5 = y1; 	}		else if (y == ny-2) {		y5 = y3; 	} 	int offset;	switch(type) {		case BYTE:		byte[] bytePixels = getPixelsByte(); 		double v; 		offset = y1*nx;		v = (double)bytePixels[offset+x1];		neigh[0][0] = ((v<0)?(v+256.0):(v));		v = (double)bytePixels[offset+x2];		neigh[1][0] = ((v<0)?(v+256.0):(v));		v = (double)bytePixels[offset+x3];		neigh[2][0] = ((v<0)?(v+256.0):(v));		v = (double)bytePixels[offset+x4];		neigh[3][0] = ((v<0)?(v+256.0):(v));					v = (double)bytePixels[offset+x5]; 		neigh[4][0] = ((v<0)?(v+256.0):(v));		offset = y2*nx;			v = (double)bytePixels[offset+x1]; 		neigh[0][1] =  ((v<0)?(v+256.0):(v));		v = (double)bytePixels[offset+x2];		neigh[1][1] =  ((v<0)?(v+256.0):(v));		v = (double)bytePixels[offset+x3];		neigh[2][1] =  ((v<0)?(v+256.0):(v));		v = (double)bytePixels[offset+x4]; 		neigh[3][1] =  ((v<0)?(v+256.0):(v));					v = (double)bytePixels[offset+x5]; 		neigh[4][1] =  ((v<0)?(v+256.0):(v));		offset = y3*nx;			v = (double)bytePixels[offset+x1]; 		neigh[0][2] =  ((v<0)?(v+256.0):(v));		v = (double)bytePixels[offset+x2];  		neigh[1][2] =  ((v<0)?(v+256.0):(v));		v = (double)bytePixels[offset+x3];  		neigh[2][2] =  ((v<0)?(v+256.0):(v));		v = (double)bytePixels[offset+x4];  		neigh[3][2] =  ((v<0)?(v+256.0):(v));					v = (double)bytePixels[offset+x5];  		neigh[4][2] =  ((v<0)?(v+256.0):(v));		offset = y4*nx;			v = (double)bytePixels[offset+x1]; 		neigh[0][3] =  ((v<0)?(v+256.0):(v));		v = (double)bytePixels[offset+x2]; 		neigh[1][3] =  ((v<0)?(v+256.0):(v));		v = (double)bytePixels[offset+x3]; 		neigh[2][3] =  ((v<0)?(v+256.0):(v));		v = (double)bytePixels[offset+x4]; 		neigh[3][3] =  ((v<0)?(v+256.0):(v));					v = (double)bytePixels[offset+x5]; 		neigh[4][3] =  ((v<0)?(v+256.0):(v));		offset = y5*nx;			v = (double)bytePixels[offset+x1];		neigh[0][4] =  ((v<0)?(v+256.0):(v));		v = (double)bytePixels[offset+x2];		neigh[1][4] =  ((v<0)?(v+256.0):(v));		v = (double)bytePixels[offset+x3];		neigh[2][4] =  ((v<0)?(v+256.0):(v));		v = (double)bytePixels[offset+x4]; 		neigh[3][4] =  ((v<0)?(v+256.0):(v));					v = (double)bytePixels[offset+x5];		neigh[4][4] =  ((v<0)?(v+256.0):(v));				break;			case SHORT:		short[] shortPixels = getPixelsShort();		offset = y1*nx;		neigh[0][0] = (double)shortPixels[offset+x1];		neigh[1][0] = (double)shortPixels[offset+x2];		neigh[2][0] = (double)shortPixels[offset+x3];		neigh[3][0] = (double)shortPixels[offset+x4];					neigh[4][0] = (double)shortPixels[offset+x5]; 				offset = y2*nx;			neigh[0][1] = (double)shortPixels[offset+x1]; 		neigh[1][1] = (double)shortPixels[offset+x2];		neigh[2][1] = (double)shortPixels[offset+x3];		neigh[3][1] = (double)shortPixels[offset+x4]; 					neigh[4][1] = (double)shortPixels[offset+x5]; 		offset = y3*nx;			neigh[0][2] = (double)shortPixels[offset+x1]; 		neigh[1][2] = (double)shortPixels[offset+x2];  		neigh[2][2] = (double)shortPixels[offset+x3]; 		neigh[3][2] = (double)shortPixels[offset+x4];  					neigh[4][2] = (double)shortPixels[offset+x5];  		offset = y4*nx;			neigh[0][3] = (double)shortPixels[offset+x1]; 		neigh[1][3] = (double)shortPixels[offset+x2]; 		neigh[2][3] = (double)shortPixels[offset+x3]; 		neigh[3][3] = (double)shortPixels[offset+x4]; 					neigh[4][3] = (double)shortPixels[offset+x5]; 		offset = y5*nx;			neigh[0][4] = (double)shortPixels[offset+x1];		neigh[1][4] = (double)shortPixels[offset+x2];		neigh[2][4] = (double)shortPixels[offset+x3];		neigh[3][4] = (double)shortPixels[offset+x4]; 						neigh[4][4] = (double)shortPixels[offset+x5];		break;			case FLOAT:		float[] floatPixels = getPixelsFloat();		offset = y1*nx;		neigh[0][0] = (double)floatPixels[offset+x1];		neigh[1][0] = (double)floatPixels[offset+x2];		neigh[2][0] = (double)floatPixels[offset+x3];		neigh[3][0] = (double)floatPixels[offset+x4];					neigh[4][0] = (double)floatPixels[offset+x5]; 				offset = y2*nx;			neigh[0][1] = (double)floatPixels[offset+x1]; 		neigh[1][1] = (double)floatPixels[offset+x2];		neigh[2][1] = (double)floatPixels[offset+x3];		neigh[3][1] = (double)floatPixels[offset+x4]; 					neigh[4][1] = (double)floatPixels[offset+x5]; 		offset = y3*nx;			neigh[0][2] = (double)floatPixels[offset+x1]; 		neigh[1][2] = (double)floatPixels[offset+x2];  		neigh[2][2] = (double)floatPixels[offset+x3]; 		neigh[3][2] = (double)floatPixels[offset+x4];  					neigh[4][2] = (double)floatPixels[offset+x5];  		offset = y4*nx;			neigh[0][3] = (double)floatPixels[offset+x1]; 		neigh[1][3] = (double)floatPixels[offset+x2]; 		neigh[2][3] = (double)floatPixels[offset+x3]; 		neigh[3][3] = (double)floatPixels[offset+x4]; 					neigh[4][3] = (double)floatPixels[offset+x5]; 		offset = y5*nx;			neigh[0][4] = (double)floatPixels[offset+x1];		neigh[1][4] = (double)floatPixels[offset+x2];		neigh[2][4] = (double)floatPixels[offset+x3];		neigh[3][4] = (double)floatPixels[offset+x4]; 						neigh[4][4] = (double)floatPixels[offset+x5];		break;					case DOUBLE:		offset = y1*nx;		neigh[0][0] = doublePixels[offset+x1];		neigh[1][0] = doublePixels[offset+x2];		neigh[2][0] = doublePixels[offset+x3];		neigh[3][0] = doublePixels[offset+x4];					neigh[4][0] = doublePixels[offset+x5]; 				offset = y2*nx;			neigh[0][1] = doublePixels[offset+x1]; 		neigh[1][1] = doublePixels[offset+x2];		neigh[2][1] = doublePixels[offset+x3];		neigh[3][1] = doublePixels[offset+x4]; 					neigh[4][1] = doublePixels[offset+x5]; 		offset = y3*nx;			neigh[0][2] = doublePixels[offset+x1]; 		neigh[1][2] = doublePixels[offset+x2];  		neigh[2][2] = doublePixels[offset+x3]; 		neigh[3][2] = doublePixels[offset+x4];  					neigh[4][2] = doublePixels[offset+x5];  		offset = y4*nx;			neigh[0][3] = doublePixels[offset+x1]; 		neigh[1][3] = doublePixels[offset+x2]; 		neigh[2][3] = doublePixels[offset+x3]; 		neigh[3][3] = doublePixels[offset+x4]; 					neigh[4][3] = doublePixels[offset+x5]; 		offset = y5*nx;			neigh[0][4] = doublePixels[offset+x1];		neigh[1][4] = doublePixels[offset+x2];		neigh[2][4] = doublePixels[offset+x3];		neigh[3][4] = doublePixels[offset+x4]; 						neigh[4][4] = doublePixels[offset+x5];		break;					default: 		throw new ArrayStoreException("Unexpected image type");	}}/*** An ImageAccess object calls this method for getting a 5x5 neighborhood* of a selected pixel.** After having the method executed the result is* in an array of the type double.** <br>Mirror border conditions are applied.* <br>* <br>The pixels value returned are organized row by row.* <br> * <br>The pixel value of (x-2, y-2) are put into neigh[0][0]* <br>The pixel value of (x-1, y-2) are put into neigh[1][0]* <br>...* <br>The pixel value of (x+2, y+2) are put into neigh[4][4]** @param x		input, the integer x-coordinate of a selected central pixel* @param y		input, the integer y-coordinate of a selected central pixel* @return neigh	output, an array consisting of 5*5 elements of the type double*/public double[][] getNeighborhood5x5(int x, int y){	double neigh[][] = new double[3][3];	getNeighborhood5x5( x, y, neigh);	return neigh;}	/*** An ImageAccess object calls this method for getting a n*n neighborhood* of a selected pixel.** After having the method executed the result is* in an array of the type double which is passed to the method* through the list of arguments.** <br>Mirror border conditions are applied.* <br>* <br>The pixel value of (x-n/2, y-n/2) is put into neigh[0][0]* <br>...* <br>The pixel value of (x+n/2, y+n/2) is put into neigh[n-1][n-1]* <br>* <br>For example for n = 4* <br>The pixel value of (x-1, y-1) is put into neigh[0][0]* <br>The pixel value of (x  , y  ) is put into neigh[1][1]* <br>The pixel value of (x+1, y+1) is put into neigh[2][2]* <br>The pixel value of (x+2, y+2) is put into neigh[3][3]* <br>...* <br>For example for n = 5* <br>The pixel value of (x-2, y-2) is put into neigh[0][0]* <br>The pixel value of (x-1, y-1) is put into neigh[1][1]* <br>The pixel value of (x  , y  ) is put into neigh[2][2]* <br>The pixel value of (x+1, y+1) is put into neigh[3][3]* <br>The pixel value of (x+2, y+2) is put into neigh[4][4]* @param x		input, the integer x-coordinate of a selected central pixel* @param y		input, the integer y-coordinate of a selected central pixel* @param neigh	output, an array consisting of n*n elements of the type double*/public void getNeighborhoodNxN(int x, int y, int n, double neigh[][]){	if ( x < 0) {    	int periodx = 2*nx - 2;						while (x < 0) x += periodx;		// Periodize		if (x >= nx)  x = periodx - x;	// Symmetrize	}	else if ( x >= nx) {    	int periodx = 2*nx - 2;						while (x >= nx) x -= periodx;	// Periodize		if (x < 0)  x = - x;			// Symmetrize	}	if ( y < 0) {    	int periody = 2*ny - 2;						while (y < 0) y += periody;		// Periodize		if (y >= ny)  y = periody - y;	// Symmetrize	}	else if ( y >= ny) {    	int periody = 2*ny - 2;						while (y >= ny) y -= periody;	// Periodize		if (y < 0)  y = - y;			// Symmetrize	}		int n2 = (n-1)/2;	 	if (x >= n2) 	if (y >= n2) 	if (x < nx-n2-1) 	if (y < ny-n2-1) { 		int index = (y-n2)*nx + (x-n2);		switch(type) {				case BYTE:			byte[] bytePixels = getPixelsByte(); 			double v; 			for (int j = 0; j < n; j++) { 				for (int i = 0; i < n; i++) {					v = (double)bytePixels[index++]; 					neigh[i][j] = ((v<0)?(v+256.0):(v));				}				index += (nx - n);			}				break;					case SHORT:			short[] shortPixels = getPixelsShort(); 			for (int j = 0; j < n; j++) { 				for (int i = 0; i < n; i++) {					neigh[i][j] = (double)shortPixels[index++];							}				index += (nx - n);			}				break;				case FLOAT:			float[] floatPixels = getPixelsFloat(); 			for (int j = 0; j < n; j++) { 				for (int i = 0; i < n; i++) {					neigh[i][j] = (double)floatPixels[index++];							}				index += (nx - n);			}				break;							case DOUBLE: 			for (int j = 0; j < n; j++) { 				for (int i = 0; i < n; i++) {					neigh[i][j] = doublePixels[index++];							}				index += (nx - n);			}				break;							default: 			throw new ArrayStoreException("Unexpected image type");		}		return;	}	int xt[] = new int[n];	for (int k = 0; k < n; k++) {		int xa = x + k - n2;    	int periodx = 2*nx - 2;						while (xa < 0) xa += periodx;		// Periodize		if (xa >= nx)  xa = periodx - xa;	// Symmetrize		xt[k] = xa;	}		int yt[] = new int[n];	for (int k = 0; k < n; k++) {		int ya = y + k - n2;    	int periody = 2*ny - 2;						while (ya < 0) ya += periody;		// Periodize		if (ya >= ny)  ya = periody - ya;	// Symmetrize		yt[k] = ya;	}			int offset;	switch(type) {		case BYTE:		byte[] bytePixels = getPixelsByte(); 		double v; 		for (int j = 0; j < n; j++) {			int index = yt[j]*nx; 			for (int i = 0; i < n; i++) {				v = (double)bytePixels[index+xt[i]]; 				neigh[i][j] = ((v<0)?(v+256.0):(v));			}		}			break;			case SHORT:		short[] shortPixels = getPixelsShort(); 		for (int j = 0; j < n; j++) {			int index = yt[j]*nx; 			for (int i = 0; i < n; i++) {				neigh[i][j] = (double)shortPixels[index+xt[i]];			}		}			break;			case FLOAT:		float[] floatPixels = getPixelsFloat(); 		for (int j = 0; j < n; j++) {			int index = yt[j]*nx; 			for (int i = 0; i < n; i++) {				neigh[i][j] = (double)floatPixels[index+xt[i]];			}		}			break;					case DOUBLE: 		for (int j = 0; j < n; j++) {			int index = yt[j]*nx; 			for (int i = 0; i < n; i++) {				neigh[i][j] = doublePixels[index+xt[i]];			}		}			break;					default: 		throw new ArrayStoreException("Unexpected image type");	}}/*** An ImageAccess object calls this method for getting a nxn neighborhood* of a selected pixel.** After having the method executed the result is* in an array of the type double.** <br>Mirror border conditions are applied.* <br>* <br>The pixel value of (x-n/2, y-n/2) is put into neigh[0][0]* <br>...* <br>The pixel value of (x+n/2, y+n/2) is put into neigh[n-1][n-1]* <br>* <br>For example for n = 4* <br>The pixel value of (x-1, y-1) is put into neigh[0][0]* <br>The pixel value of (x  , y  ) is put into neigh[1][1]* <br>The pixel value of (x+1, y+1) is put into neigh[2][2]* <br>The pixel value of (x+2, y+2) is put into neigh[3][3]* <br>...* <br>For example for n = 5* <br>The pixel value of (x-2, y-2) is put into neigh[0][0]* <br>The pixel value of (x-1, y-1) is put into neigh[1][1]* <br>The pixel value of (x  , y  ) is put into neigh[2][2]* <br>The pixel value of (x+1, y+1) is put into neigh[3][3]* <br>The pixel value of (x+2, y+2) is put into neigh[4][4]** @param x		input, the integer x-coordinate of a selected central pixel* @param y		input, the integer y-coordinate of a selected central pixel* @return neigh	output, an array consisting of n*n elements of the type double*/public double[][] getNeighborhoodNxN(int x, int y, int N){	double neigh[][] = new double[N][N];	getNeighborhoodNxN( x, y, N, neigh);	return neigh;}	/*** Returns an reference to the ImageProcessor*/public ImageProcessor getImageProcessor(){	return ip;}/*** Return the mark of ImageAccess.** @return     	the mark*/public int getMark(){	return mark;}/*** Return the maximum value of ImageAccess.** @return     	the maximum value*/public double getMaximum(){	double maxi=0.0;	switch(type) {			case BYTE:			byte[] bytePixels = getPixelsByte();			byte byteMax = bytePixels[0];			for (int i=1; i<size; i++)				if (bytePixels[i] > byteMax) 					byteMax = bytePixels[i];			maxi = (double)byteMax;			break;							case SHORT:			short[] shortPixels = getPixelsShort();			short shortMax = shortPixels[0];			for (int i=1; i<size; i++)				if (shortPixels[i] > shortMax) 					shortMax = shortPixels[i];			maxi = (double)shortMax;			break;							case FLOAT:			float[] floatPixels = getPixelsFloat();			float floatMax = floatPixels[0];			for (int i=1; i<size; i++)				if (floatPixels[i] > floatMax) 					floatMax = floatPixels[i];			maxi = (double)floatMax;			break;					case DOUBLE:			maxi = doublePixels[0];			for (int i=1; i<size; i++)				if (doublePixels[i] > maxi) 					maxi = doublePixels[i];			break;							default:			throw new ArrayStoreException("Unexpected image type");	}	return maxi;}/*** Return the minimum value of ImageAccess.** @return     	the minimum value*/public double getMinimum(){	double mini=0.0;			switch(type) {			case BYTE:			byte[] bytePixels = getPixelsByte();			byte byteMin = bytePixels[0];			for (int i=1; i<size; i++)				if (bytePixels[i] < byteMin) 					byteMin = bytePixels[i];			mini = (double)byteMin;			break;							case SHORT:			short[] shortPixels = getPixelsShort();			short shortMin = shortPixels[0];			for (int i=1; i<size; i++)				if (shortPixels[i] < shortMin) 					shortMin = shortPixels[i];			mini = (double)shortMin;			break;							case FLOAT:			float[] floatPixels = getPixelsFloat();			float floatMin = floatPixels[0];			for (int i=1; i<size; i++)				if (floatPixels[i] < floatMin) 					floatMin = floatPixels[i];			mini = (double)floatMin;			break;					case DOUBLE:			mini = doublePixels[0];			for (int i=1; i<size; i++)				if (doublePixels[i] < mini) 					mini = doublePixels[i];			break;					default:			throw new ArrayStoreException("Unexpected image type");	}	return mini;}/*** Return the mean value of ImageAccess.** @return     	the mean value*/public double getMean(){	double mean=0.0;	switch(type) {			case BYTE:			byte[] bytePixels = getPixelsByte();			for ( int i=0; i<size; i++)				mean += (double)bytePixels[i];			break;							case SHORT:			short[] shortPixels = getPixelsShort();			for ( int i=0; i<size; i++)				mean += (double)shortPixels[i];			break;							case FLOAT:			float[] floatPixels = getPixelsFloat();			for ( int i=0; i<size; i++)				mean += (double)floatPixels[i];			break;					case DOUBLE:			for ( int i=0; i<size; i++)				mean += doublePixels[i];			break;					default:			throw new ArrayStoreException("Unexpected image type");	}		mean /= (double)(size);	return mean;}/*** An ImageAccess object calls this method for getting* the gray level of a selected pixel.** <br>Mirror border conditions are applied.** @param x		input, the integer x-coordinate of a pixel* @param y		input, the integer y-coordinate of a pixel* @return     	the gray level of the pixel (double) */public double getPixel(int x, int y){ 	int periodx = 2*nx-2; 	int periody = 2*ny-2; 		if (x<0) {					while (x<0) x += periodx;		// Periodize			if (x >= nx) x = periodx - x;	// Symmetrize	}	else if (x>=nx) {					while (x>=nx) x -= periodx;		// Periodize			if (x < 0) x = -x;				// Symmetrize	}		if (y<0) {					while (y<0) y += periody;		// Periodize			if (y>=ny)  y = periody - y;	// Symmetrize		}	else if (y>=ny) {					while (y>=ny) y -= periody;		// Periodize			if (y < 0) y = -y;				// Symmetrize 	} 		switch(type) {			case BYTE:			byte[] bytePixels = getPixelsByte();			double v = (double)bytePixels[x+y*nx]; 			return ((v<0)?(v+256.0):(v));					case SHORT:			short[] shortPixels = getPixelsShort();			return (double)(shortPixels[x+y*nx]);					case FLOAT:			float[] floatPixels = getPixelsFloat();			return (double)(floatPixels[x+y*nx]);					case DOUBLE:			return doublePixels[x+y*nx];					default:			throw new ArrayStoreException("Unexpected image type");	}}/*** Returns an reference to the pixel data in byte.*/public byte[] getPixelsByte(){	if (type == BYTE)		return (byte[])ip.getPixels();	else		throw new ArrayStoreException("Not a byte image");}/*** Returns an reference to the pixel data in short.*/public short[] getPixelsShort(){	if (type == SHORT)		return (short[])ip.getPixels();	else		throw new ArrayStoreException("Not a short image");}/*** Returns an reference to the pixel data in float.*/public float[] getPixelsFloat(){	if (type == FLOAT)		return (float[])ip.getPixels();	else		throw new ArrayStoreException("Not a float image");}/*** Returns an reference to the pixel data in double.*/public double[] getPixelsDouble(){	if (type == DOUBLE)		return doublePixels;	else		throw new ArrayStoreException("Not a double image");}/*** An ImageAccess object calls this method for getting a selected row* of the image data.** After having the method executed the result is* in an array of the type double which is passed to the method* through the list of arguments.** @param y       	input, the integer y-coordinate of a row* @param row        output, an array of the type double*/public void getRow(int y, double[] row){	if ( y < 0) {    	int periody = 2*ny - 2;						while (y < 0) y += periody;		// Periodize		if (y >= ny)  y = periody - y;	// Symmetrize	}	else if ( y >= ny) {    	int periody = 2*ny - 2;						while (y >= ny) y -= periody;	// Periodize		if (y < 0)  y = - y;			// Symmetrize	}	 	y *= nx;	switch(type) {			case BYTE:			byte[] bytePixels = getPixelsByte();			for (int i=0; i<nx; i++) {				double v = (double)bytePixels[y++];				row[i] = ((v<0)?(v+256.0):(v));			}			break;				case SHORT:			short[] shortPixels = getPixelsShort();			for (int i=0; i<nx; i++) {				row[i] = (double)shortPixels[y++];			}			break;				case FLOAT:			float[] floatPixels = getPixelsFloat();			for (int i=0; i<nx; i++) {				row[i] = (double)floatPixels[y++];			}			break;				case DOUBLE:			for (int i=0; i<nx; i++) {				row[i] = doublePixels[y++];			}			break;					default: 			throw new ArrayStoreException("Unexpected image type");	}	}/*** An ImageAccess object calls this method for getting a part of a selected row* of the image data.** After having the method executed the result is* in an array of the type double which is passed to the method* through the list of arguments.** @param y       	input, the integer y-coordinate of a row* @param row        output, an array of the type double* @param start      input, the coordonate of the first element you want to have* @param end        input, the coordonate of the last element you want to have + 1*/public void getRow(int y, double[] row, int start, int end){	if ( y < 0) {    	int periody = 2*ny - 2;						while (y < 0) y += periody;		// Periodize		if (y >= ny)  y = periody - y;	// Symmetrize	}	else if ( y >= ny) {    	int periody = 2*ny - 2;						while (y >= ny) y -= periody;	// Periodize		if (y < 0)  y = - y;			// Symmetrize	}		if(start>=end || start<0 || end>nx)		throw new ArrayStoreException("Out of boundary in getColumn.");			y *= nx;	y += start;		int lengthRow = end-start;		switch(type) {			case BYTE:			byte[] bytePixels = getPixelsByte();			for (int i = 0; (i < lengthRow); i++) {				double v = (double)bytePixels[y++];				row[i] = ((v<0)?(v+256.0):(v));			}			break;				case SHORT:			short[] shortPixels = getPixelsShort();			for (int i = 0; (i < lengthRow); i++) {				row[i] = (double)shortPixels[y++];			}			break;				case FLOAT:			float[] floatPixels = getPixelsFloat();			for (int i = 0; (i < lengthRow); i++) {				row[i] = (double)floatPixels[y++];			}			break;				case DOUBLE:			for (int i = 0; (i < lengthRow); i++) {				row[i] = doublePixels[y++];			}			break;					default: 			throw new ArrayStoreException("Unexpected image type");	}}/*** Return the size of the diagonal of the image.* * Use the routine to determine the size of the array for the * getDiagonal45() getDiagonal135() putDiagonal45() and putDiagonal135().** Note: the size of the diagonal is the minimum of the height and the width.* * @return     	size of the diagonal*/public int getSizeDiagonal(){	return (nx<ny?nx:ny);}/*** An ImageAccess object calls this method for getting the type of the image data* which can be byte, short, short, float or double.** @return     	the type*/public int getType(){	return type;}/*** An ImageAccess object calls this method for getting the width of the image* i.e. the size of the image along the X-axis.** @return     	the image width (integer)*/public int getWidth(){	return nx;}/*** Compute the log.*/public void log() {	double row[] = new double[nx];	for (int y=0; y<ny; y++) {		getRow(y, row);		for (int x=0; x<nx; x++) {			row[x] = Math.log(row[x]);		}		putRow(y, row);	}}/*** An ImageAccess object calls this method for multiplying* a constant to each pixel. ** After having the method executed the result is* in the ImageAccess object which called the method.** @param constant   a constant to be multiplied*/public void multiply(final double constant){	switch(type) {			case BYTE:			byte[] bytePixels = getPixelsByte();			byte byteConstant = (byte)Math.round(constant);			for (int k=0; k<size; k++)				bytePixels[k] *= byteConstant;			break;				case SHORT:			short[] shortPixels = getPixelsShort();			short shortConstant = (short)Math.round(constant);			for (int k=0; k<size; k++)				shortPixels[k] *= shortConstant;			break;				case FLOAT:			float[] floatPixels = getPixelsFloat();			float floatConstant = (float)constant;			for (int k=0; k<size; k++)				floatPixels[k] *= floatConstant;			break;				case DOUBLE:			for (int k=0; k<size; k++)				doublePixels[k] *= constant;				break;					default:			throw new ArrayStoreException("Unexpected image type");	}}/*** An ImageAccess object calls this method for multiplying* a ImageAccess object which is the arguments for the method* by means of pixel to pixel addition. ** After having the method executed the result is* in the ImageAccess object which called the method.* The ImageAccess objects should have the same size.** @param im		an ImageAccess object to be multiplied*/public void multiply(ImageAccess im){	if (im.getWidth() != nx) {		throw new ArrayStoreException("Unexpected operand image size");	}		if (im.getHeight() != ny) {		throw new ArrayStoreException("Unexpected operand image size");	}		if (im.getType() != type) {		throw new ArrayStoreException("Unexpected operand image type");	}				switch(type) {			case BYTE:			byte[] bytePixels  = getPixelsByte();			byte[] byteOperand = im.getPixelsByte();			for (int k=0; k<size; k++)				bytePixels[k] *= byteOperand[k];			break;				case SHORT:			short[] shortPixels  = getPixelsShort();			short[] shortOperand = im.getPixelsShort();			for (int k=0; k<size; k++)				shortPixels[k] *= shortOperand[k];			break;				case FLOAT:			float[] floatPixels  = getPixelsFloat();			float[] floatOperand = im.getPixelsFloat();			for (int k=0; k<size; k++)				floatPixels[k] *= floatOperand[k];			break;				case DOUBLE:			double[] doubleOperand = im.getPixelsDouble();			for (int k=0; k<size; k++)				doublePixels[k] *= doubleOperand[k];			break;					default:			throw new ArrayStoreException("Unexpected image type");	}}/*** Stretches the contrast inside an image so that the gray levels are* in the range [minGoal-maxGoal].*/public void normalizeContrast(double minGoal, double maxGoal){	// Search the min and max	double minImage = getMinimum();	double maxImage = getMaximum();		// Compute the parameter to rescale the gray levels	double a;	if ( minImage-maxImage == 0) {		a = 1.0;		minImage = (maxGoal-minGoal)/2.0;	}	else		a = (maxGoal-minGoal) / (maxImage-minImage);	switch(type) {				case BYTE:			byte[] bytePixels  = getPixelsByte();			for (int i = 0; i < size; i++) {				bytePixels[i] = (byte)(a*((double)bytePixels[i]-minImage) + minGoal);			}			break;					case SHORT:			short[] shortPixels  = getPixelsShort();			for (int i = 0; i < size; i++) {				shortPixels[i]= (short)(a*((double)shortPixels[i]-minImage) + minGoal);			}			break;				case FLOAT:			float[] floatPixels  = getPixelsFloat();			for (int i = 0; i < size; i++) {				floatPixels[i]= (float)(a*((double)floatPixels[i]-minImage) + minGoal);			}			break;		case DOUBLE:			for (int i = 0; i < size; i++) {				doublePixels[i]= (float)(a*(doublePixels[i]-minImage) + minGoal);			}			break;					default:			throw new ArrayStoreException("Unexpected image type");	}}/*** Stretches the contrast inside an image so that the gray levels are* in the range : the positivy values are stretched to center-max * and the negative values are stretched to min-center.*/public void normalizeContrastCentered(double minGoal, double maxGoal){	double center = (maxGoal+minGoal)/2.0;		// Get the min and max	double minImage = getMinimum();	double maxImage = getMaximum();		// Compute the parameter to rescale the gray levels	double a;	if (minImage-maxImage == 0) {		a = 1.0;		minImage = (maxGoal-minGoal)/2.0;	}	else {		if ( Math.abs(maxImage) > Math.abs(minImage) )			a = (maxGoal-center) / Math.abs(maxImage);		else			a = (center-minGoal) / Math.abs(minImage);	}		// Apply the rescaling	switch(type) {				case BYTE:			byte[] bytePixels  = getPixelsByte();			for (int i = 0; i < size; i++) {				bytePixels[i] = (byte)(a*((double)bytePixels[i])+center);			}			break;					case SHORT:			short[] shortPixels  = getPixelsShort();			for (int i = 0; i < size; i++) {				shortPixels[i]= (short)(a*((double)shortPixels[i])+center);			}			break;				case FLOAT:			float[] floatPixels  = getPixelsFloat();			for (int i = 0; i < size; i++) {				floatPixels[i]= (float)(a*((double)floatPixels[i])+center);			}			break;					case DOUBLE:			for (int i = 0; i < size; i++) {				doublePixels[i]= (float)(a*(doublePixels[i])+center);			}			break;					default:			throw new ArrayStoreException("Unexpected image type");	}}/*** Raised an ImageAccess object to the power a.* @param a 	input*/public void pow(final double a) {	double row[] = new double[nx];	for (int y=0; y<ny; y++) {		getRow(y, row);		for (int x=0; x<nx; x++) {			row[x] = Math.pow(row[x], a);		}		putRow(y, row);	}}/*** An ImageAccess object calls this method in order a data array* to be put into a selected column of the image data.** After having the method executed the result is* in the ImageAccess object which called the method.** @param x       	input, the integer x-coordinate of a column* @param column     input, an array of the type double*/public void putColumn (int x, double[] column){   	if ( x < 0)    		return;   	if ( x >= nx)   		return;   			switch(type) {			case BYTE:			byte[] bytePixels = getPixelsByte();			for (int i=0; i<ny; i++) {				bytePixels[x] = (byte)Math.round(column[i]);				x += nx;			}			break;				case SHORT:			short[] shortPixels = getPixelsShort();			for (int i=0; i<ny; i++) {				shortPixels[x] = (short)Math.round(column[i]);				x += nx;			}			break;				case FLOAT:			float[] floatPixels = getPixelsFloat();			for (int i=0; i<ny; i++) {				floatPixels[x] = (float)column[i];				x += nx;			}			break;				case DOUBLE:			for (int i=0; i<ny; i++) {				doublePixels[x] = column[i];				x += nx;			}			break;					default: 			throw new ArrayStoreException("Unexpected image type");	}}/*** An ImageAccess object calls this method in order a data array* to be put into a part of a selected column of the image data.** After having the method executed the result is* in the ImageAccess object which called the method.** @param x       	input, the integer x-coordinate of a column* @param column     input, an array of the type double* @param start      input, the coordonate of the first element you want to have* @param end        input, the coordonate of the last element you want to have + 1*/public void putColumn (int x, double[] column, int start, int end){   	if ( x < 0)    		return;   	if ( x >= nx)   		return;   	   	if(start>=end || start<0 || end>ny)		throw new ArrayStoreException("Out of boundary in getColumn.");   		int lengthColumn = end-start;	x += (start*nx);			switch(type) {			case BYTE:			byte[] bytePixels = getPixelsByte();			for (int i=0; i<lengthColumn; i++) {				bytePixels[x] = (byte)column[i];				x += nx;			}			break;				case SHORT:			short[] shortPixels = getPixelsShort();			for (int i=0; i<lengthColumn; i++) {				shortPixels[x] = (short)column[i];				x += nx;			}			break;				case FLOAT:			float[] floatPixels = getPixelsFloat();			for (int i=0; i<lengthColumn; i++) {				floatPixels[x] = (float)column[i];				x += nx;			}			break;				case DOUBLE:			for (int i=0; i<lengthColumn; i++) {				doublePixels[x] = column[i];				x += nx;			}			break;					default: 			throw new ArrayStoreException("Unexpected image type");	}}/*** An ImageAccess object calls this method for putting* a 45 degrees diagonal pixels.** Only the necessary part of diagonal is use.** The index k of the diagonal start from the Upper Left corner, go down,* turn right to finish at the Lower right corner.* If the index k equal 0 the diagonal contains 1 pixel (pixel [0,0]).* If the index k equal nx+ny-1 the diagonal contains 1 pixel (pixel [nx-1,ny-1]).* * Mirror border conditions are applied.** @param k			index of the diagonal* @param diagonal	array containing the diagonal*/public void putDiagonal45(int k, double[] diagonal){	if ( k < 0) {    	int periody = 2*(ny+nx) - 2;						while (k < 0) k += periody;			// Periodize		if (k >= (ny+nx))  k = periody - k;	// Symmetrize	}	else if ( k >= ny+nx) {    	int periody = 2*(ny+nx) - 2;						while (k >= (ny+nx)) k -= periody;	// Periodize		if (k < 0)  k = - k;				// Symmetrize	}		int len = -1;	int index;	if (nx > ny) {		if (k < ny) {			index = k*nx;			len = k+1;		}		else if (k < nx) {			index = (ny-1)*nx + (k-ny)+1;			len = ny;		}		else {			index = (ny-1)*nx + (k-ny)+1;			len = nx+ny-k-1;		}	}	else {		if (k < nx) {			index = k*nx;			len = k+1;		}		else if (k < ny) {			index = k*nx;			len = nx;		}		else {			index = (ny-1)*nx + (k-ny)+1;			len = nx+ny-k-1;		}	}		switch(type) {			case BYTE:			byte[] bytePixels = getPixelsByte();			for (int i=0; i<len; i++) {				bytePixels[index] = (byte)Math.round(diagonal[i]);				index -= (nx - 1);			}			break;				case SHORT:			short[] shortPixels = getPixelsShort();			for (int i=0; i<len; i++) {				shortPixels[index] = (short)diagonal[i];				index -= (nx - 1);			}			break;				case FLOAT:			float[] floatPixels = getPixelsFloat();			for (int i=0; i<len; i++) {				floatPixels[index] = (float)diagonal[i];				index -= (nx - 1);			}			break;				case DOUBLE:			for (int i=0; i<len; i++) {				doublePixels[index] = diagonal[i];				index -= (nx - 1);			}			break;					default: 			throw new ArrayStoreException("Unexpected image type");	}}/*** An ImageAccess object calls this method for putting* a 45 degrees diagonal pixels.** Only the necessary part of diagonal is use.** The index k of the diagonal start from the Lower Left corner, go right,* turn up to finish at the Upper right corner.* If the index k equal 0 the diagonal contains 1 pixel (pixel [0,ny-1]).* If the index k equal nx+ny-1 the diagonal contains 1 pixel (pixel [nx-1,0]).* * Mirror border conditions are applied.** @param k			index of the diagonal* @param diagonal	array containing the diagonal*/public void putDiagonal135(int k, double[] diagonal){	if ( k < 0) {    	int periody = 2*(ny+nx) - 2;						while (k < 0) k += periody;				// Periodize		if (k >= (ny+nx))  k = periody - k;		// Symmetrize	}	else if ( k >= ny+nx) {    	int periody = 2*(ny+nx) - 2;						while (k >= (ny+nx)) k -= periody;		// Periodize		if (k < 0)  k = - k;					// Symmetrize	}		int len = -1;	int index;	if (nx > ny) {		if (k < ny) {			index = (ny-1)*nx + k;			len = k+1;		}		else if (k < nx) {			index = (ny-1)*nx + k;			len = ny;		}		else {			index = (ny+nx-k-2)*nx + (nx-1);			len = nx+ny-k-1;		}	}	else {		if (k < nx) {			index = (ny-1)*nx + k;			len = k+1;		}		else if (k < ny) {			index = (ny+nx-k-2)*nx + (nx-1);			len = nx;		}		else {			index = (ny+nx-k-2)*nx + (nx-1);			len = nx+ny-k-1;		}	}		switch(type) {			case BYTE:			byte[] bytePixels = getPixelsByte();			for (int i=0; i<len; i++) {				bytePixels[index] = (byte)Math.round(diagonal[i]);				index -= (nx + 1);			}			break;				case SHORT:			short[] shortPixels = getPixelsShort();			for (int i=0; i<len; i++) {				shortPixels[index] = (short)diagonal[i];				index -= (nx + 1);			}			break;				case FLOAT:			float[] floatPixels = getPixelsFloat();			for (int i=0; i<len; i++) {				floatPixels[index] = (float)diagonal[i];				index -= (nx + 1);			}			break;				case DOUBLE:			for (int i=0; i<len; i++) {				doublePixels[index] = diagonal[i];				index -= (nx + 1);			}			break;					default: 			throw new ArrayStoreException("Unexpected image type");	}}/*** An ImageAccess object calls this method in order a data array* to be put into a selected row of the image data.** After having the method executed the result is* in the ImageAccess object which called the method.** @param y       	input, the integer y-coordinate of a row* @param row        input, an array of the type double*/public void putRow (int y, double[] row) {   	if ( y < 0)   		return;   	if ( y >= ny)   		return;   			y *= nx;	switch(type) {			case BYTE:			byte[] bytePixels = getPixelsByte();			for (int i=0; i<nx; i++) {				bytePixels[y++] = (byte)Math.round(row[i]);			}			break;				case SHORT:			short[] shortPixels = getPixelsShort();			for (int i=0; i<nx; i++) {				shortPixels[y++] = (short)Math.round(row[i]);			}			break;				case FLOAT:			float[] floatPixels = getPixelsFloat();			for (int i=0; i<nx; i++) {				floatPixels[y++] = (float)row[i];			}			break;				case DOUBLE:			for (int i=0; i<nx; i++) {				doublePixels[y++] = row[i];			}			break;					default: 			throw new ArrayStoreException("Unexpected image type");	}}/*** An ImageAccess object calls this method in order a data array* to be put into a part of a selected row of the image data.** After having the method executed the result is* in the ImageAccess object which called the method.** @param y       	input, the integer y-coordinate of a row* @param row        input, an array of the type double* @param start      input, the coordonate of the first element you want to have* @param end        input, the coordonate of the last element you want to have + 1*/public void putRow(int y, double[] row, int start, int end) {   	if ( y < 0)   		return;   	if ( y >= ny)   		return;   	   	if(start>=end || start<0 || end>nx)		throw new ArrayStoreException("Out of boundary in getColumn.");   				y *= nx;	y += start;		int lengthRow = end-start;		switch(type) {			case BYTE:			byte[] bytePixels = getPixelsByte();			for (int i=0; i<lengthRow; i++) {				bytePixels[y++] = (byte)row[i];			}			break;				case SHORT:			short[] shortPixels = getPixelsShort();			for (int i=0; i<lengthRow; i++) {				shortPixels[y++] = (short)row[i];			}			break;				case FLOAT:			float[] floatPixels = getPixelsFloat();			for (int i=0; i<lengthRow; i++) {				floatPixels[y++] = (float)row[i];			}			break;				case DOUBLE:			for (int i=0; i<lengthRow; i++) {				doublePixels[y++] = row[i];			}			break;					default: 			throw new ArrayStoreException("Unexpected image type");	}}/*** An ImageAccess object calls this method in order a value* of the gray level to be put to a position inside it* given by the coordinates.** After having the method executed the result is* in the ImageAccess object which called the method.** @param x		input, the integer x-coordinate of a pixel* @param y		input, the integer y-coordinate of a pixel* @param value	input, a value of the gray level of the type double*/public void putPixel(int x, int y, double value){   	if ( x < 0)    		return;   	if ( y < 0)   		return;   	if ( x >= nx)   		return;   	if ( y >= ny)   		return;   			switch(type) {			case BYTE:			byte[] bytePixels = getPixelsByte();			bytePixels[x+y*nx] = (byte)Math.round(value); 			break;					case SHORT:			short[] shortPixels = getPixelsShort();			shortPixels[x+y*nx] = (short)Math.round(value);			break;			case FLOAT:			float[] floatPixels = getPixelsFloat();			floatPixels[x+y*nx] = (float)value;			break;			case DOUBLE:			doublePixels[x+y*nx] = value;			break;				default:			throw new ArrayStoreException("Unexpected image type");	}}/*** An ImageAccess object calls this method to set a constant* value to all pixels of the image.** @param constant a constant value */public void setConstant(double constant){	switch(type) {			case BYTE:			byte[] bytePixels = getPixelsByte();			byte b0 = Byte.MIN_VALUE;			byte b1 = Byte.MAX_VALUE;			byte byteConstant = ((constant<0.0)?(b0):((constant>255.0)?(b1):((byte)Math.round(constant))));			for (int k=0; k<size; k++) {				bytePixels[k]= byteConstant;			}			break;					case SHORT:			short[] shortPixels = getPixelsShort();			short shortConstant = (short)Math.round(constant);			for (int k=0; k<size; k++) {				shortPixels[k]= shortConstant;			}			break;			case FLOAT:			float[] floatPixels = getPixelsFloat();			float floatConstant = (float)constant;			for (int k=0; k<size; k++) {				floatPixels[k]= floatConstant;			}			break;			case DOUBLE:			for (int k=0; k<size; k++) {				doublePixels[k]= constant;			}			break;				default:			throw new ArrayStoreException("Unexpected image type");	}	}/*** Set the mark of ImageAccess.*/public void setMark(int mark){	this.mark = mark;}/*** An ImageAccess object calls this method to saturate* the values of the gray levels strictly greater than a selected * maximum value and stricly less than a selected minimum value.** After having the method executed the result of the saturation is* in the ImageAccess object which called the method.** @param min	input, a minimum value of the gray level (double)* @param max	input, a maximum value of the gray level (double)*/public void saturate(double min, double max){	switch(type) {				case BYTE:			byte[] bytePixels = getPixelsByte();			byte byteMin = (byte)Math.round(min);			byte byteMax = (byte)Math.round(max);			for (int k=0; k<size; k++) {				if (bytePixels[k] < byteMin)					bytePixels[k]= byteMin;				else if (bytePixels[k] > byteMax)					bytePixels[k]= byteMax;			}			break;					case SHORT:			short[] shortPixels = getPixelsShort();			short shortMin = (short)Math.round(min);			short shortMax = (short)Math.round(max);			for (int k=0; k<size; k++) {				if (shortPixels[k] < shortMin)					shortPixels[k]= shortMin;				else if (shortPixels[k] > shortMax)					shortPixels[k]= shortMax;			}			break;					case FLOAT:			float[] floatPixels = getPixelsFloat();			float floatMin = (float)min;			float floatMax = (float)max;			for (int k=0; k<size; k++) {				if (floatPixels[k] < floatMin)					floatPixels[k]= floatMin;				else if (floatPixels[k] > floatMax)					floatPixels[k]= floatMax;			}			break;					case DOUBLE:			for (int k=0; k<size; k++) {				if (doublePixels[k] < min)					doublePixels[k]= min;				else if (doublePixels[k] > max)					doublePixels[k]= max;			}			break;				default:			throw new ArrayStoreException("Unexpected image type");	}	}/** Shifts pixels along the two directions to the center.** Elements shifted off one end wrap around and are shifted onto the other end.* That means the output image size is the same that the input image.**/public void shift() {	shift(nx/2, ny/2);}/** Shifts pixels along the two directions by a specified number of pixels.** Elements shifted off one end wrap around and are shifted onto the other end.* That means the output image size is the same that the input image.** @param xshift   value a the shift in the X axis* @param yshift   value a the shift in the Y axis*/public void shift(int xshift, int yshift) {	if (xshift < 0 || yshift < 0) {		throw new ArrayStoreException("Unexpected center");	}		if (xshift >= nx || yshift >= ny) {		throw new ArrayStoreException("Unexpected center");	}		if (xshift != 0 && xshift != nx) {		double rowin[] = new double[nx];			double rowout[] = new double[nx];			for (int y=0; y<ny; y++) {			getRow(y, rowin);			System.arraycopy(rowin, xshift, rowout, 0, nx-xshift);			System.arraycopy(rowin, 0, rowout, nx-xshift, xshift);			putRow(y, rowout);		}	}		if (yshift != 0 && yshift != ny) {		double colin[] = new double[ny];			double colout[] = new double[ny];			for (int x=0; x<nx; x++) {			getColumn(x, colin);			System.arraycopy(colin, yshift, colout, 0, ny-yshift);			System.arraycopy(colin, 0, colout, ny-yshift, yshift);			putColumn(x, colout);		}	}}/*** Compute the square root of an ImageAccess.*/public void sqrt() {	double row[] = new double[nx];	for (int y=0; y<ny; y++) {		getRow(y, row);		for (int x=0; x<nx; x++) {			row[x] = Math.sqrt(row[x]);		}		putRow(y, row);	}}/*** An ImageAccess object calls this method for adding* a constant to each pixel. ** After having the method executed the result of the addition is* in the ImageAccess object which called the method.** @param constant   a constant to be added*/public void subtract(final double constant){	switch(type) {			case BYTE:			byte[] bytePixels = getPixelsByte();			byte byteConstant = (byte)Math.round(constant);			for (int k=0; k<size; k++)				bytePixels[k] -= byteConstant;			break;				case SHORT:			short[] shortPixels = getPixelsShort();			short shortConstant = (short)Math.round(constant);			for (int k=0; k<size; k++)				shortPixels[k] -= shortConstant;			break;				case FLOAT:			float[] floatPixels = getPixelsFloat();			float floatConstant = (float)constant;			for (int k=0; k<size; k++)				floatPixels[k] -= floatConstant;			break;				case DOUBLE:			for (int k=0; k<size; k++)				doublePixels[k] -= constant;				break;					default:			throw new ArrayStoreException("Unexpected image type");	}}/*** An ImageAccess object calls this method for subtracting* a ImageAccess object which is the arguments for the method* by means of pixel to pixel substraction. ** After having the method executed the result of the substraction is* in the ImageAccess object which called the method.* The ImageAccess objects should have the same size.** @param im		an ImageAccess object to be subtracted*/public void subtract(ImageAccess im){	if (im.getWidth() != nx) {		throw new ArrayStoreException("Unexpected operand image size");	}		if (im.getHeight() != ny) {		throw new ArrayStoreException("Unexpected operand image size");	}		if (im.getType() != type) {		throw new ArrayStoreException("Unexpected operand image type");	}			switch(type) {			case BYTE:			byte[] bytePixels = getPixelsByte();			byte[] byteOperand = im.getPixelsByte();			for (int k=0; k<size; k++) {				bytePixels[k] -= byteOperand[k];			}			break;					case SHORT:			short[] shortPixels = getPixelsShort();			short[] shortOperand = im.getPixelsShort();			for (int k=0; k<size; k++) {				shortPixels[k] -= shortOperand[k];			}			break;					case FLOAT:			float[] floatPixels = getPixelsFloat();			float[] floatOperand = im.getPixelsFloat();			for (int k=0; k<size; k++) {				floatPixels[k] -= floatOperand[k];			}			break;					case DOUBLE:			double[] doubleOperand = im.getPixelsDouble();			for (int k=0; k<size; k++) {				doublePixels[k] -= doubleOperand[k];			}			break;				default:			throw new ArrayStoreException("Unexpected image type");	}}/*** Update the display*/public void updateDisplay(){	ip.resetMinAndMax();}} // end of class
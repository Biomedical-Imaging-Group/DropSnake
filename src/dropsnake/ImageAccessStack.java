/* * Provide routines to manipulate a stack of ImageAccess in relation * to ImageJ. * * @author 	Swiss Federal Institute of Technology Lausanne *			Biomedical Imaging Group *			Daniel Sage * * @version 1.0 * */ package dropsnake;import ij.*;import ij.process.*;import ij.gui.*;public class ImageAccessStack extends Object{private ImageStack stack=null;		// Reference to the output stackprivate ImagePlus  imp=null;			// Reference to the input ImagePlusprivate ImageAccess ia[]=null;private int nbPlanes=0;private int slices=0;private int nx=0;private int ny=0;/*** Constructor from parameters.*/public ImageAccessStack(int nx, int ny, int slices, int type){	switch(type) {		case ImagePlus.GRAY8:  	  			imp = NewImage.createByteImage("", nx, ny, slices, NewImage.FILL_BLACK); 			if (imp.getStack().isRGB() || imp.getStack().isHSB())				nbPlanes = 3;			else				nbPlanes = 1;			break;		case ImagePlus.GRAY16:    			imp = NewImage.createShortImage("", nx, ny, slices, NewImage.FILL_BLACK); 			nbPlanes = 1;			break;		case ImagePlus.GRAY32:    			imp = NewImage.createFloatImage("", nx, ny, slices, NewImage.FILL_BLACK); 			nbPlanes = 1;			break;		case ImagePlus.COLOR_RGB: 			imp = NewImage.createRGBImage("", nx, ny, slices, NewImage.FILL_BLACK); 			nbPlanes = 3;			break;		case ImagePlus.COLOR_256: 			imp = NewImage.createByteImage("", nx, ny, slices, NewImage.FILL_BLACK);			nbPlanes = 1;			break;		default:			throw new ArrayStoreException("Unexpected image type.");	}	stack = imp.createEmptyStack();		this.imp = imp;	this.nx = nx;	this.ny = ny;	this.slices = slices;				// Create one ImageAccess if it is B&W or three if it is color 	ia   = new ImageAccess[nbPlanes];}			/*** Get the ImagePlus.*/public int getNumberOfPlanes(){	return 	nbPlanes;}/*** Get the ImagePlus.*/public ImagePlus getImagePlus(){	return imp;}/*** Get the ImagePlus.*/public ImageStack getImageStack(){	return stack;}/*** Create a new ImageAccess fill up with an ImageProcessor or by the index * plane of the ImagePlus. The default type is FLOAT.*/public ImageAccess createImageAccess(ImageProcessor ip, int plane) {	return createImageAccess(ip, plane, ImageAccess.FLOAT);}/*** Create a new ImageAccess fill up with an ImageProcessor or by the index * plane of the ImagePlus. The type is specified.*/public ImageAccess createImageAccess(ImageProcessor ip, int plane, int type){	ImageAccess iaSource; 	ia[plane] = new ImageAccess(nx, ny, type);	if (ip != null) {		switch(imp.getType()) {				case ImagePlus.GRAY8:				if (imp.getStack().isRGB() || imp.getStack().isHSB())					ia[0].copy(new ImageAccess(imp.getStack().getProcessor(plane+1))); 				else  					ia[0].copy(new ImageAccess(ip));				break;						case ImagePlus.GRAY16:     				ia[0].copy(new ImageAccess(ip));				break;						case ImagePlus.GRAY32:    	 			ia[0].copy(new ImageAccess(ip));				break;						case ImagePlus.COLOR_RGB:				int[] pixels = (int[])ip.getPixels();				int size = nx*ny;				switch(type) {					case ImageAccess.BYTE: 						byte bytePix[] = (byte [])ia[plane].getPixelsByte();						if (plane == 0)							for ( int i = 0; i < size; i++)								bytePix[i] = (byte)((pixels[i]&0xff0000)>>16);						else if (plane == 1)							for ( int i = 0; i < size; i++)								bytePix[i] = (byte)((pixels[i]&0xff00)>>8);						else if (plane == 2)							for ( int i = 0; i < size; i++)							bytePix[i] = (byte)(pixels[i]&0xff);						break;					case ImageAccess.SHORT:						short shortPix[] = (short [])ia[plane].getPixelsShort();						if (plane == 0)							for ( int i = 0; i < size; i++)								shortPix[i] = (short)((pixels[i]&0xff0000)>>16);						else if (plane == 1)							for ( int i = 0; i < size; i++)								shortPix[i] = (short)((pixels[i]&0xff00)>>8);						else if (plane == 2)							for ( int i = 0; i < size; i++)							shortPix[i] = (short)(pixels[i]&0xff);						break;					case ImageAccess.FLOAT:						float pix[] = (float [])ia[plane].getPixelsFloat();						if (plane == 0)							for ( int i = 0; i < size; i++)								pix[i] = (float)((pixels[i]&0xff0000)>>16);						else if (plane == 1)							for ( int i = 0; i < size; i++)								pix[i] = (float)((pixels[i]&0xff00)>>8);						else if (plane == 2)							for ( int i = 0; i < size; i++)							pix[i] = (float)(pixels[i]&0xff);						break;					case ImageAccess.DOUBLE:						double doublePix[] = (double [])ia[plane].getPixelsDouble();						if (plane == 0)							for ( int i = 0; i < size; i++)								doublePix[i] = (double)((pixels[i]&0xff0000)>>16);						else if (plane == 1)							for ( int i = 0; i < size; i++)								doublePix[i] = (double)((pixels[i]&0xff00)>>8);						else if (plane == 2)							for ( int i = 0; i < size; i++)							doublePix[i] = (double)(pixels[i]&0xff);						break;					default:						throw new ArrayStoreException("Unexpected image type");				}				break;							case ImagePlus.COLOR_256:  				ia[0].copy(new ImageAccess(ip));				break;							default: 				throw new ArrayStoreException("Unexpected image type");		}	}		return ia[plane];}/*** Check if it is the last slice of the stack.*/public boolean isLastSlice(){	if (stack.getSize() >= slices)		return true;	else		return false;}/*** Check if it is the first slice of the stack.*/public boolean isFirstSlice(){	if (stack.getSize() == 0)		return true;	else		return false;}/*** Add an ImageAccess to the stack.*/public void addImageAccess(){		switch(imp.getType()) {			case ImagePlus.GRAY8:			if (imp.getStack().isRGB()) {				String text[] = new String[3];				text[0] = "Red";				text[1] = "Green";				text[2] = "Blue";				for (int i = 0; i <nbPlanes; i++) {					ImageAccess iaByteColor[] = new ImageAccess[nbPlanes];					iaByteColor[i] = new ImageAccess(nx, ny, ImageAccess.BYTE);					iaByteColor[i].copy(ia[i]);					stack.addSlice(text[i%3], iaByteColor[i].getPixelsByte());				}			}			else if (imp.getStack().isHSB()) {				String text1[] = new String[3];				text1[0] = "Hue";				text1[1] = "Saturation";				text1[2] = "Brightness";				for (int i = 0; i <nbPlanes; i++) {					ImageAccess iaByteColor[] = new ImageAccess[nbPlanes];					iaByteColor[i] = new ImageAccess(nx, ny, ImageAccess.BYTE);					iaByteColor[i].copy(ia[i]);					stack.addSlice(text1[i%3], iaByteColor[i].getPixelsByte());				}			}			else {				for (int i = 0; i <nbPlanes; i++) {					ImageAccess iaByte = new ImageAccess(nx, ny, ImageAccess.BYTE);					iaByte.copy(ia[i]);					stack.addSlice("", iaByte.getPixelsByte());				}			}			break;					case ImagePlus.GRAY16:			for (int i = 0; i <nbPlanes; i++) {				if (ia[i].getType() == ImageAccess.SHORT) {					stack.addSlice("", ia[i].getPixelsShort());				}				else {					ImageAccess iaShort = new ImageAccess(nx, ny, ImageAccess.SHORT);					iaShort.copy(ia[i]);					stack.addSlice("", iaShort.getPixelsShort());				}			}			break;					case ImagePlus.GRAY32:			for (int i = 0; i <nbPlanes; i++) {				if (ia[i].getType() == ImageAccess.FLOAT) {					stack.addSlice("", ia[i].getPixelsFloat());				}				else {					ImageAccess iaFloat = new ImageAccess(nx, ny, ImageAccess.FLOAT);					iaFloat.copy(ia[i]);					stack.addSlice("", iaFloat.getPixelsFloat());				}			}			break;					case ImagePlus.COLOR_256:			for (int i = 0; i <nbPlanes; i++) {				ImageAccess iaColor = new ImageAccess(nx, ny, ImageAccess.BYTE);				iaColor.copy(ia[i]);				stack.addSlice("", iaColor.getPixelsByte());			}			break;					case ImagePlus.COLOR_RGB:			ColorProcessor ipc = buildColorProcessor(this.ia);			stack.addSlice("", ipc.getPixels());			break;					default: 			throw new ArrayStoreException("Unexpected image type");	}}/*** Add an ImageAccess to the stack.*/public void appendImageAccess(ImageAccess ianew[]){		int nbPlanes = ianew.length;	switch(imp.getType()) {			case ImagePlus.GRAY8:			if (imp.getStack().isRGB()) {				String text[] = new String[3];				text[0] = "Red";				text[1] = "Green";				text[2] = "Blue";				for (int i = 0; i <nbPlanes; i++) {					ImageAccess iaByteColor[] = new ImageAccess[nbPlanes];					iaByteColor[i] = new ImageAccess(nx, ny, ImageAccess.BYTE);					iaByteColor[i].copy(ianew[i]);					stack.addSlice(text[i%3], iaByteColor[i].getPixelsByte());				}			}			else if (imp.getStack().isHSB()) {				String text1[] = new String[3];				text1[0] = "Hue";				text1[1] = "Saturation";				text1[2] = "Brightness";				for (int i = 0; i <nbPlanes; i++) {					ImageAccess iaByteColor[] = new ImageAccess[nbPlanes];					iaByteColor[i] = new ImageAccess(nx, ny, ImageAccess.BYTE);					iaByteColor[i].copy(ianew[i]);					stack.addSlice(text1[i%3], iaByteColor[i].getPixelsByte());				}			}			else {				for (int i = 0; i <nbPlanes; i++) {					ImageAccess iaByte = new ImageAccess(nx, ny, ImageAccess.BYTE);					iaByte.copy(ianew[i]);					stack.addSlice("", iaByte.getPixelsByte());				}			}			break;					case ImagePlus.GRAY16:			for (int i = 0; i <nbPlanes; i++) {				ImageAccess iaShort = new ImageAccess(nx, ny, ImageAccess.SHORT);				iaShort.copy(ianew[i]);				stack.addSlice("", iaShort.getPixelsShort());			}			break;					case ImagePlus.GRAY32:			for (int i = 0; i <nbPlanes; i++) {				stack.addSlice("", ianew[i].getPixelsFloat());			}			break;					case ImagePlus.COLOR_256:			for (int i = 0; i <nbPlanes; i++) {				ImageAccess iaColor = new ImageAccess(nx, ny, ImageAccess.BYTE);				iaColor.copy(ianew[i]);				stack.addSlice("", iaColor.getPixelsByte());			}			break;					case ImagePlus.COLOR_RGB:			ColorProcessor ipc = buildColorProcessor(ianew);			stack.addSlice("", ipc.getPixels());			break;					default: 			throw new ArrayStoreException("Unexpected image type");	}}/***/private ColorProcessor buildColorProcessor(ImageAccess im[]){			ColorProcessor ipc = new ColorProcessor(nx, ny);			int[] pix = (int[])ipc.getPixels();			int indexRed, indexGreen, indexBlue;			for (int s = 0; s <(nbPlanes+1)/3; s++) {				byte b0 = (byte)0;				byte b1 = (byte)255;				indexRed = s;				indexGreen = ( (s+1>=nbPlanes) ? (nbPlanes-1) : (s+1));				indexBlue  = ( (s+2>=nbPlanes) ? (nbPlanes) : (s+2));				int r, g, b;				switch(im[indexRed].getType()) {					case ImageAccess.BYTE:						byte bR[] = im[indexRed].getPixelsByte();						byte bG[] = im[indexGreen].getPixelsByte();						byte bB[] = im[indexBlue].getPixelsByte();						for (int i=0; i < nx*ny; i++) {							r = ((bR[i]<0)?(b0):((bR[i]>255)?(b1):(bR[i])))&0xff;							g = ((bG[i]<0)?(b0):((bG[i]>255)?(b1):(bG[i])))&0xff;							b = ((bB[i]<0)?(b0):((bB[i]>255)?(b1):(bB[i])))&0xff;							pix[i] = 0xff000000 | (r<<16) | (g<<8) | b;						}						break;					case ImageAccess.SHORT:						short sR[] = im[indexRed].getPixelsShort();						short sG[] = im[indexGreen].getPixelsShort();						short sB[] = im[indexBlue].getPixelsShort();						for (int i=0; i < nx*ny; i++) {							r = ((sR[i]<0)?(b0):((sR[i]>255)?(b1):((byte)sR[i])))&0xff;							g = ((sG[i]<0)?(b0):((sG[i]>255)?(b1):((byte)sG[i])))&0xff;							b = ((sB[i]<0)?(b0):((sB[i]>255)?(b1):((byte)sB[i])))&0xff;							pix[i] = 0xff000000 | (r<<16) | (g<<8) | b;						}						break;					case ImageAccess.FLOAT:						float fR[] = im[indexRed].getPixelsFloat();						float fG[] = im[indexGreen].getPixelsFloat();						float fB[] = im[indexBlue].getPixelsFloat();						for (int i=0; i < nx*ny; i++) {							r = ((fR[i]<0.0)?(b0):((fR[i]>255.0)?(b1):((byte)fR[i])))&0xff;							g = ((fG[i]<0.0)?(b0):((fG[i]>255.0)?(b1):((byte)fG[i])))&0xff;							b = ((fB[i]<0.0)?(b0):((fB[i]>255.0)?(b1):((byte)fB[i])))&0xff;							pix[i] = 0xff000000 | (r<<16) | (g<<8) | b;						}						break;					case ImageAccess.DOUBLE:						double dR[] = im[indexRed].getPixelsDouble();						double dG[] = im[indexGreen].getPixelsDouble();						double dB[] = im[indexBlue].getPixelsDouble();						for (int i=0; i < nx*ny; i++) {							r = ((dR[i]<0.0)?(b0):((dR[i]>255.0)?(b1):((byte)dR[i])))&0xff;							g = ((dG[i]<0.0)?(b0):((dG[i]>255.0)?(b1):((byte)dG[i])))&0xff;							b = ((dB[i]<0.0)?(b0):((dB[i]>255.0)?(b1):((byte)dB[i])))&0xff;							pix[i] = 0xff000000 | (r<<16) | (g<<8) | b;						}						break;					default:						throw new ArrayStoreException("Unexpected image type");				}			}			return ipc;}} // end of class
/* * B-spline transformation. * * @author 	Swiss Federal Institute of Technology Lausanne *			Biomedical Imaging Group * * @version 1.0 * */package dropsnake;import ij.*;public class BsplineTransform extends Object{static public final int ANTIMIRRORONBOUNDS = 1;static public final int FINITECOEFFICENTSUPPORT = 2;static public final int MIRROROFFBOUNDS = 3;static public final int MIRRORONBOUNDS = 4;static public final int PERIODIC = 5;private int boundary;private double tolerance;/*** Constructor of the class Convolver.** @param boundaryConditions    Boundary Conditions*/public BsplineTransform(int boundary){	this.boundary = boundary;	tolerance = 1e-6;} /*** Set the boundary conditions.** @param boundaryConditions    Boundary Conditions*/public void setBoundaryConditions(int boundary){	this.boundary = boundary;}/*** Get the boundary conditions.*/public int getBoundaryConditions(){	return boundary;}/*** Set the tolerance.** @param tolerance    Tolearance value*/public void setTolerance(double tolerance){	this.tolerance = tolerance;}/**/public void getInterpolationCoefficients (double[] c, int degree) {	double z[] = new double[0];	double lambda = 1.0;	switch (degree) {		case 0:		case 1:			return;		case 2:			z = new double[1];			z[0] = Math.sqrt(8.0) - 3.0;			break;		case 3:			z = new double[1];			z[0] = Math.sqrt(3.0) - 2.0;			break;		case 4:			z = new double[2];			z[0] = Math.sqrt(664.0 - Math.sqrt(438976.0)) + Math.sqrt(304.0) - 19.0;			z[1] = Math.sqrt(664.0 + Math.sqrt(438976.0)) - Math.sqrt(304.0) - 19.0;			break;		case 5:			z = new double[2];			z[0] = Math.sqrt(135.0 / 2.0 - Math.sqrt(17745.0 / 4.0))				+ Math.sqrt(105.0 / 4.0) - 13.0 / 2.0;			z[1] = Math.sqrt(135.0 / 2.0 + Math.sqrt(17745.0 / 4.0))				- Math.sqrt(105.0 / 4.0) - 13.0 / 2.0;			break;		case 6:			z = new double[3];			z[0] = -0.488294589303044755130118038883789062112279161239377608394;			z[1] = -0.081679271076237512597937765737059080653379610398148178525368;			z[2] = -0.00141415180832581775108724397655859252786416905534669851652709;			break;		case 7:			z = new double[3];			z[0] = -0.5352804307964381655424037816816460718339231523426924148812;			z[1] = -0.122554615192326690515272264359357343605486549427295558490763;			z[2] = -0.0091486948096082769285930216516478534156925639545994482648003;			break;		default:			throw new IllegalArgumentException("Invalid spline degree (should be [0..7])");	}	if (c.length == 1) {		return;	}	for (int k = 0; (k < z.length); k++) {		lambda = lambda * (1.0 - z[k]) * (1.0 - 1.0 / z[k]);	}	for (int n = 0; (n < c.length); n++) {		c[n] = c[n] * lambda;	}	for (int k = 0; (k < z.length); k++) {		switch (boundary) {			case 1: // AntiMirrorOnBounds				c[0] = getInitialCausalCoefficientAntiMirrorOnBounds(c, z[k], tolerance);				break;			case 2: // FiniteCoefficientSupport				c[0] = getInitialCausalCoefficientFiniteCoefficientSupport(c, z[k], tolerance);				break;			case 3: // MirrorOffBounds				c[0] = getInitialCausalCoefficientMirrorOffBounds(c, z[k], tolerance);				break;			case 4: // MirrorOnBounds				c[0] = getInitialCausalCoefficientMirrorOnBounds(c, z[k], tolerance);				break;			case 5: // Periodic				c[0] = getInitialCausalCoefficientPeriodic(c, z[k], tolerance);				break;			default:				throw new IllegalArgumentException("Invalid boundary)");		}		for (int n = 1; (n < c.length); n++) {			c[n] = c[n] + z[k] * c[n - 1];		}		switch (boundary) {			case 1: // AntiMirrorOnBounds				c[c.length - 1] = getInitialAntiCausalCoefficientAntiMirrorOnBounds(c, z[k],					tolerance);				break;			case 2: // FiniteCoefficientSupport				c[c.length - 1] = getInitialAntiCausalCoefficientFiniteCoefficientSupport(c, z[k],					tolerance);				break;			case 3: // MirrorOffBounds				c[c.length - 1] = getInitialAntiCausalCoefficientMirrorOffBounds(c, z[k],					tolerance);				break;			case 4: // MirrorOnBounds				c[c.length - 1] = getInitialAntiCausalCoefficientMirrorOnBounds(c, z[k],					tolerance);				break;			case 5: // Periodic				c[c.length - 1] = getInitialAntiCausalCoefficientPeriodic(c, z[k],					tolerance);				break;			default:				throw new IllegalArgumentException("Invalid boundary)");		}	for (int n = c.length - 2; (0 <= n); n--) {			c[n] = z[k] * (c[n+1] - c[n]);		}	}} /* end getInterpolationCoefficients *//*------------------------------------------------------------------*/public void getSamples (double[] c, int degree) {	double h[] = new double[0];	double s[] = new double[c.length];	switch (degree) {		case 0:		case 1:			return;		case 2:			h = new double[2];			h[0] = 3.0 / 4.0;			h[1] = 1.0 / 8.0;			break;		case 3:			h = new double[2];			h[0] = 2.0 / 3.0;			h[1] = 1.0 / 6.0;			break;		case 4:			h = new double[3];			h[0] = 115.0 / 192.0;			h[1] = 19.0 / 96.0;			h[2] = 1.0 / 384.0;			break;		case 5:			h = new double[3];			h[0] = 11.0 / 20.0;			h[1] = 13.0 / 60.0;			h[2] = 1.0 / 120.0;			break;		case 6:			h = new double[4];			h[0] = 5887.0 / 11520.0;			h[1] = 10543.0 / 46080.0;			h[2] = 361.0 / 23040.0;			h[3] = 1.0 / 46080.0;			break;		case 7:			h = new double[4];			h[0] = 151.0 / 315.0;			h[1] = 397.0 / 1680.0;			h[2] = 1.0 / 42.0;			h[3] = 1.0 / 5040.0;			break;		default:			throw new IllegalArgumentException("Invalid spline degree (should be [0..7])");	}	switch (boundary) {		case 1: // AntiMirrorOnBounds			symmetricFirAntiMirrorOnBounds(h, c, s);			break;		case 2: // FiniteCoefficientSupport			symmetricFirFiniteDataSupport(h, c, s);			break;		case 3: // MirrorOffBounds			symmetricFirMirrorOffBounds(h, c, s);			break;		case 4: // MirrorOnBounds			symmetricFirMirrorOnBounds(h, c, s);			break;		case 5: // Periodic			symmetricFirPeriodic(h, c, s);			break;		default:			throw new IllegalArgumentException("Invalid boundary)");	}	System.arraycopy(s, 0, c, 0, s.length);} /* end getSamples *//*------------------------------------------------------------------*/private double getInitialAntiCausalCoefficientAntiMirrorOnBounds (	double[] c,	double z,	double tolerance) {	return((z * c[c.length - 2] - c[c.length - 1]) * z / ((1.0 - z) * (1.0 - z)));} /* end getInitialAntiCausalCoefficientAntiMirrorOnBounds *//*------------------------------------------------------------------*/private double getInitialAntiCausalCoefficientFiniteCoefficientSupport (	double[] c,	double z,	double tolerance) {	return(-z * c[c.length - 1]);} /* end getInitialAntiCausalCoefficientFiniteCoefficientSupport *//*------------------------------------------------------------------*/private double getInitialAntiCausalCoefficientMirrorOffBounds (	double[] c,	double z,	double tolerance) {	return(z * c[c.length - 1] / (z - 1.0));} /* end getInitialAntiCausalCoefficientMirrorOffBounds *//*------------------------------------------------------------------*/private double getInitialAntiCausalCoefficientMirrorOnBounds (	double[] c,	double z,	double tolerance) {	return((z * c[c.length - 2] + c[c.length - 1]) * z / (z * z - 1.0));} /* end getInitialAntiCausalCoefficientMirrorOnBounds *//*------------------------------------------------------------------*/private double getInitialAntiCausalCoefficientPeriodic (	double[] c,	double z,	double tolerance) {	double sum = c[0] + c[c.length - 1] / z, zn = z;	int horizon = c.length;	if (tolerance > 0.0) {		horizon = 2 + (int)(Math.log(tolerance) / Math.log(Math.abs(z)));		horizon = (horizon < c.length) ? (horizon) : (c.length);	}	for (int n = 1; (n < (horizon - 1)); n++) {		sum = sum + zn * c[n];		zn = zn * z;	}	return(z * z * sum / (Math.pow(z, c.length) - 1.0));} /* end getInitialAntiCausalCoefficientPeriodic *//*------------------------------------------------------------------*/private double getInitialCausalCoefficientAntiMirrorOnBounds (	double[] c,	double z,	double tolerance) {	double z1 = z, zn = Math.pow(z, c.length - 1);	double sum = (c[0] - zn * c[c.length - 1]) * (1.0 + z) / (1.0 - z);	int horizon = c.length;	if (tolerance > 0.0) {		horizon = 2 + (int)(Math.log(tolerance) / Math.log(Math.abs(z)));		horizon = (horizon < c.length) ? (horizon) : (c.length);	}	zn = zn * zn;	for (int n = 1; (n < (horizon - 1)); n++) {		zn = zn / z;		sum = sum + (zn - z1) * c[n];		z1 = z1 * z;	}	return(sum / (1.0 - Math.pow(z, 2 * c.length - 2)));} /* end getInitialCausalCoefficientAntiMirrorOnBounds *//*------------------------------------------------------------------*/private double getInitialCausalCoefficientFiniteCoefficientSupport (	double[] c,	double z,	double tolerance) {	double z1 = z, zn = Math.pow(z, 2 * c.length);	double sum = 0.0;	int horizon = c.length;	if (tolerance > 0.0) {		horizon = 2 + (int)(Math.log(tolerance) / Math.log(Math.abs(z)));		horizon = (horizon < c.length) ? (horizon) : (c.length);	}	for (int n = 1; (n < horizon); n++) {		zn = zn / z;		sum = sum + (z1 - zn) * c[n];		z1 = z1 * z;	}	z1 = z * z;	return((1.0 - z1) * (c[0] - sum * z1 / (1.0 - z1))		/ (1.0 - Math.pow(z, 2 * c.length + 2)));} /* end getInitialCausalCoefficientFiniteCoefficientSupport *//*------------------------------------------------------------------*/private double getInitialCausalCoefficientMirrorOffBounds (	double[] c,	double z,	double tolerance) {	double z1 = z, zn = Math.pow(z, c.length);	double sum = (1.0 + z) * (c[0] + zn * c[c.length - 1]);	int horizon = c.length;	if (tolerance > 0.0) {		horizon = 2 + (int)(Math.log(tolerance) / Math.log(Math.abs(z)));		horizon = (horizon < c.length) ? (horizon) : (c.length);	}	zn = zn * zn;	for (int n = 1; (n < (horizon - 1)); n++) {		z1 = z1 * z;		zn = zn / z;		sum = sum + (z1 + zn) * c[n];	}	return(sum / (1.0 - Math.pow(z, 2 * c.length)));} /* end getInitialCausalCoefficientMirrorOffBounds *//*------------------------------------------------------------------*/public double getInitialCausalCoefficientMirrorOnBounds (	double[] c,	double z,	double tolerance) {	double z1 = z, zn = Math.pow(z, c.length - 1);	double sum = c[0] + zn * c[c.length - 1];	int horizon = c.length;	if (tolerance > 0.0) {		horizon = 2 + (int)(Math.log(tolerance) / Math.log(Math.abs(z)));		horizon = (horizon < c.length) ? (horizon) : (c.length);	}	zn = zn * zn;	for (int n = 1; (n < (horizon - 1)); n++) {		zn = zn / z;		sum = sum + (z1 + zn) * c[n];		z1 = z1 * z;	}	return(sum / (1.0 - Math.pow(z, 2 * c.length - 2)));} /* end getInitialCausalCoefficientMirrorOnBounds *//*------------------------------------------------------------------*/private double getInitialCausalCoefficientPeriodic (	double c[],	double z,	double tolerance) {	double sum = c[0], zn = z;	int horizon = c.length;	if (tolerance > 0.0) {		horizon = 1 + (int)(Math.log(tolerance) / Math.log(Math.abs(z)));		horizon = (horizon < c.length) ? (horizon) : (c.length);	}	for (int n = 1; (n < horizon); n++) {		sum = sum + zn * c[c.length - n];		zn = zn * z;	}	return(sum / (1.0 - Math.pow(z, c.length)));} /* end getInitialCausalCoefficientPeriodic *//*------------------------------------------------------------------*/private void symmetricFirAntiMirrorOnBounds (	double[] h,	double[] c,	double[] s) {	if (c.length != s.length) {		throw new IndexOutOfBoundsException("Incompatible size");	}	switch (h.length) {		case 2:			if (2 <= c.length) {				s[0] = (h[0] + 2.0 * h[1]) * c[0];				for (int i = 1; (i < (c.length - 1)); i++) {					s[i] = h[0] * c[i] + h[1] * (c[i - 1] + c[i + 1]);				}				s[s.length - 1] = (h[0] + 2.0 * h[1]) * c[s.length - 1];			}			else {				switch (c.length) {					case 1:						s[0] = (h[0] + 2.0 * h[1]) * c[0];						break;					default:						throw new NegativeArraySizeException("Invalid length of data");				}			}			break;		case 3:			if (4 <= c.length) {				s[0] = (h[0] + 2.0 * (h[1] + h[2])) * c[0];				s[1] = h[0] * c[1] + h[1] * (c[0] + c[2]) + h[2] * (2.0 * c[0] - c[1] + c[3]);				for (int i = 2; (i < (c.length - 2)); i++) {					s[i] = h[0] * c[i] + h[1] * (c[i - 1] + c[i + 1])						+ h[2] * (c[i - 2] + c[i + 2]);				}				s[s.length - 2] = h[0] * c[c.length - 2]					+ h[1] * (c[c.length - 3] + c[c.length - 1])					+ h[2] * (c[c.length - 4] + 2.0 * c[c.length - 1] - c[c.length - 2]);				s[s.length - 1] = (h[0] + 2.0 * (h[1] + h[2])) * c[s.length - 1];			}			else {				switch (c.length) {					case 3:						s[0] = (h[0] + 2.0 * (h[1] + h[2])) * c[0];						s[1] = h[0] * c[1] + h[1] * (c[0] + c[2])							+ 2.0 * h[2] * (c[0] - c[1] + c[2]);						s[2] = (h[0] + 2.0 * (h[1] + h[2])) * c[2];						break;					case 2:						s[0] = (h[0] + 2.0 * (h[1] + h[2])) * c[0];						s[1] = (h[0] + 2.0 * (h[1] + h[2])) * c[1];						break;					case 1:						s[0] = (h[0] + 2.0 * (h[1] + h[2])) * c[0];						break;					default:						throw new NegativeArraySizeException("Invalid length of data");				}			}			break;		case 4:			if (6 <= c.length) {				s[0] = (h[0] + 2.0 * (h[1] + h[2] + h[3])) * c[0];				s[1] = h[0] * c[1] + h[1] * (c[0] + c[2]) + h[2] * (2.0 * c[0] - c[1] + c[3])					+ h[3] * (2.0 * c[0] - c[2] + c[4]);				s[2] = h[0] * c[2] + h[1] * (c[1] + c[3]) + h[2] * (c[0] + c[4])					+ h[3] * (2.0 * c[0] - c[1] + c[5]);				for (int i = 3; (i < (c.length - 3)); i++) {					s[i] = h[0] * c[i] + h[1] * (c[i - 1] + c[i + 1])						+ h[2] * (c[i - 2] + c[i + 2]) + h[3] * (c[i - 3] + c[i + 3]);				}				s[s.length - 3] = h[0] * c[c.length - 3]					+ h[1] * (c[c.length - 4] + c[c.length - 2])					+ h[2] * (c[c.length - 5] + c[c.length - 1])					+ h[3] * (c[c.length - 6] + 2.0 * c[c.length - 1] - c[c.length - 2]);				s[s.length - 2] = h[0] * c[c.length - 2]					+ h[1] * (c[c.length - 3] + c[c.length - 1])					+ h[2] * (c[c.length - 4] + 2.0 * c[c.length - 1] - c[c.length - 2])					+ h[3] * (c[c.length - 5] + 2.0 * c[c.length - 1] - c[c.length - 3]);				s[s.length - 1] = (h[0] + 2.0 * (h[1] + h[2] + h[3])) * c[s.length - 1];			}			else {				switch (c.length) {					case 5:						s[0] = (h[0] + 2.0 * (h[1] + h[2] + h[3])) * c[0];						s[1] = h[0] * c[1] + h[1] * (c[0] + c[2])							+ h[2] * (2.0 * c[0] - c[1] + c[3])							+ h[3] * (2.0 * c[0] - c[2] + c[4]);						s[2] = h[0] * c[2] + h[1] * (c[1] + c[3]) + h[2] * (c[0] + c[4])							+ h[3] * (2.0 * (c[0] + c[4]) - c[1] - c[3]);						s[3] = h[0] * c[3] + h[1] * (c[2] + c[4])							+ h[2] * (c[1] + 2.0 * c[4] - c[3])							+ h[3] * (c[0] + 2.0 * c[4] - c[2]);						s[4] = (h[0] + 2.0 * (h[1] + h[2] + h[3])) * c[4];						break;					case 4:						s[0] = (h[0] + 2.0 * (h[1] + h[2] + h[3])) * c[0];						s[1] = h[0] * c[1] + h[1] * (c[0] + c[2])							+ h[2] * (2.0 * c[0] - c[1] + c[3])							+ 2.0 * h[3] * (c[0] - c[2] + c[3]);						s[2] = h[0] * c[2] + h[1] * (c[1] + c[3])							+ h[2] * (c[0] + 2.0 * c[3] - c[2])							+ 2.0 * h[3] * (c[0] - c[1] + c[3]);						s[3] = (h[0] + 2.0 * (h[1] + h[2] + h[3])) * c[3];						break;					case 3:						s[0] = (h[0] + 2.0 * (h[1] + h[2] + h[3])) * c[0];						s[1] = h[0] * c[1] + h[1] * (c[0] + c[2])							+ 2.0 * h[2] * (c[0] - c[1] + c[2]) + h[3] * (c[0] + c[2]);						s[2] = (h[0] + 2.0 * (h[1] + h[2] + h[3])) * c[2];						break;					case 2:						s[0] = (h[0] + 2.0 * (h[1] + h[2] + h[3])) * c[0];						s[1] = (h[0] + 2.0 * (h[1] + h[2] + h[3])) * c[1];						break;					case 1:						s[0] = (h[0] + 2.0 * (h[1] + h[2] + h[3])) * c[0];						break;					default:						throw new NegativeArraySizeException("Invalid length of data");				}			}			break;		default:			throw new IllegalArgumentException(				"Invalid filter half-length (should be [2..4])");	}} /* end symmetricFirAntiMirrorOnBounds *//*------------------------------------------------------------------*/private void symmetricFirFiniteDataSupport (	double[] h,	double[] c,	double[] s) {	if (c.length != s.length) {		throw new IndexOutOfBoundsException("Incompatible size");	}	switch (h.length) {		case 2:			if (2 <= c.length) {				s[0] = h[0] * c[0] + h[1] * c[1];				for (int i = 1; (i < (c.length - 1)); i++) {					s[i] = h[0] * c[i] + h[1] * (c[i - 1] + c[i + 1]);				}				s[s.length - 1] = h[0] * c[c.length - 1] + h[1] * c[c.length - 2];			}			else {				switch (c.length) {					case 1:						s[0] = h[0] * c[0];						break;					default:						throw new NegativeArraySizeException("Invalid length of data");				}			}			break;		case 3:			if (4 <= c.length) {				s[0] = h[0] * c[0] + h[1] * c[1] + h[2] * c[2];				s[1] = h[0] * c[1] + h[1] * (c[0] + c[2]) + h[2] * c[3];				for (int i = 2; (i < (c.length - 2)); i++) {					s[i] = h[0] * c[i] + h[1] * (c[i - 1] + c[i + 1])						+ h[2] * (c[i - 2] + c[i + 2]);				}				s[s.length - 2] = h[0] * c[c.length - 2]					+ h[1] * (c[c.length - 3] + c[c.length - 1]) + h[2] * c[c.length - 4];				s[s.length - 1] = h[0] * c[c.length - 1] + h[1] * c[c.length - 2]					+ h[2] * c[c.length - 3];			}			else {				switch (c.length) {					case 3:						s[0] = h[0] * c[0] + h[1] * c[1] + h[2] * c[2];						s[1] = h[0] * c[1] + h[1] * (c[0] + c[2]);						s[2] = h[0] * c[2] + h[1] * c[1] + h[2] * c[0];						break;					case 2:						s[0] = h[0] * c[0] + h[1] * c[1];						s[1] = h[0] * c[1] + h[1] * c[0];						break;					case 1:						s[0] = h[0] * c[0];						break;					default:						throw new NegativeArraySizeException("Invalid length of data");				}			}			break;		case 4:			if (6 <= c.length) {				s[0] = h[0] * c[0] + h[1] * c[1] + h[2] * c[2] + h[3] * c[3];				s[1] = h[0] * c[1] + h[1] * (c[0] + c[2]) + h[2] * c[3] + h[3] * c[4];				s[2] = h[0] * c[2] + h[1] * (c[1] + c[3]) + h[2] * (c[0] + c[4]) + h[3] * c[5];				for (int i = 3; (i < (c.length - 3)); i++) {					s[i] = h[0] * c[i] + h[1] * (c[i - 1] + c[i + 1])						+ h[2] * (c[i - 2] + c[i + 2]) + h[3] * (c[i - 3] + c[i + 3]);				}				s[s.length - 3] = h[0] * c[c.length - 3]					+ h[1] * (c[c.length - 4] + c[c.length - 2])					+ h[2] * (c[c.length - 5] + c[c.length - 1])					+ h[3] * c[c.length - 6];				s[s.length - 2] = h[0] * c[c.length - 2]					+ h[1] * (c[c.length - 3] + c[c.length - 1]) + h[2] * c[c.length - 4]					+ h[3] * c[c.length - 5];				s[s.length - 1] = h[0] * c[c.length - 1] + h[1] * c[c.length - 2]					+ h[2] * c[c.length - 3] + h[3] * c[c.length - 4];			}			else {				switch (c.length) {					case 5:						s[0] = h[0] * c[0] + h[1] * c[1] + h[2] * c[2] + h[3] * c[3];						s[1] = h[0] * c[1] + h[1] * (c[0] + c[2]) + h[2] * c[3] + h[3] * c[4];						s[2] = h[0] * c[2] + h[1] * (c[1] + c[3]) + h[2] * (c[0] + c[4]);						s[3] = h[0] * c[3] + h[1] * (c[2] + c[4]) + h[2] * c[1] + h[3] * c[0];						s[4] = h[0] * c[4] + h[1] * c[3] + h[2] * c[2] + h[3] * c[1];						break;					case 4:						s[0] = h[0] * c[0] + h[1] * c[1] + h[2] * c[2] + h[3] * c[3];						s[1] = h[0] * c[1] + h[1] * (c[0] + c[2]) + h[2] * c[3];						s[2] = h[0] * c[2] + h[1] * (c[1] + c[3]) + h[2] * c[0];						s[3] = h[0] * c[3] + h[1] * c[2] + h[2] * c[1] + h[3] * c[0];						break;					case 3:						s[0] = h[0] * c[0] + h[1] * c[1] + h[2] * c[2];						s[1] = h[0] * c[1] + h[1] * (c[0] + c[2]);						s[2] = h[0] * c[2] + h[1] * c[1] + h[2] * c[0];						break;					case 2:						s[0] = h[0] * c[0] + h[1] * c[1];						s[1] = h[0] * c[1] + h[1] * c[0];						break;					case 1:						s[0] = h[0] * c[0];						break;					default:						throw new NegativeArraySizeException("Invalid length of data");				}			}			break;		default:			throw new IllegalArgumentException(				"Invalid filter half-length (should be [2..4])");	}} /* end symmetricFirFiniteDataSupport *//*------------------------------------------------------------------*/private void symmetricFirMirrorOffBounds (	double[] h,	double[] c,	double[] s) {	if (c.length != s.length) {		throw new IndexOutOfBoundsException("Incompatible size");	}	switch (h.length) {		case 2:			if (2 <= c.length) {				s[0] = h[0] * c[0] + h[1] * (c[0] + c[1]);				for (int i = 1; (i < (c.length - 1)); i++) {					s[i] = h[0] * c[i] + h[1] * (c[i - 1] + c[i + 1]);				}				s[s.length - 1] = h[0] * c[c.length - 1]					+ h[1] * (c[c.length - 2] + c[c.length - 1]);			}			else {				switch (c.length) {					case 1:						s[0] = (h[0] + 2.0 * h[1]) * c[0];						break;					default:						throw new NegativeArraySizeException("Invalid length of data");				}			}			break;		case 3:			if (4 <= c.length) {				s[0] = h[0] * c[0] + h[1] * (c[0] + c[1]) + h[2] * (c[1] + c[2]);				s[1] = h[0] * c[1] + h[1] * (c[0] + c[2]) + h[2] * (c[0] + c[3]);				for (int i = 2; (i < (c.length - 2)); i++) {					s[i] = h[0] * c[i] + h[1] * (c[i - 1] + c[i + 1])						+ h[2] * (c[i - 2] + c[i + 2]);				}				s[s.length - 2] = h[0] * c[c.length - 2]					+ h[1] * (c[c.length - 3] + c[c.length - 1])					+ h[2] * (c[c.length - 4] + c[c.length - 1]);				s[s.length - 1] = h[0] * c[c.length - 1]					+ h[1] * (c[c.length - 2] + c[c.length - 1])					+ h[2] * (c[c.length - 3] + c[c.length - 2]);			}			else {				switch (c.length) {					case 3:						s[0] = h[0] * c[0] + h[1] * (c[0] + c[1]) + h[2] * (c[1] + c[2]);						s[1] = h[0] * c[1] + (h[1] + h[2]) * (c[0] + c[2]);						s[2] = h[0] * c[2] + h[1] * (c[1] + c[2]) + h[2] * (c[0] + c[1]);						break;					case 2:						s[0] = h[0] * c[0] + h[1] * (c[0] + c[1]) + 2.0 * h[2] * c[1];						s[1] = h[0] * c[1] + h[1] * (c[0] + c[1]) + 2.0 * h[2] * c[0];						break;					case 1:						s[0] = (h[0] + 2.0 * (h[1] + h[2])) * c[0];						break;					default:						throw new NegativeArraySizeException("Invalid length of data");				}			}			break;		case 4:			if (6 <= c.length) {				s[0] = h[0] * c[0] + h[1] * (c[0] + c[1]) + h[2] * (c[1] + c[2])					+ h[3] * (c[2] + c[3]);				s[1] = h[0] * c[1] + h[1] * (c[0] + c[2]) + h[2] * (c[0] + c[3])					+ h[3] * (c[1] + c[4]);				s[2] = h[0] * c[2] + h[1] * (c[1] + c[3]) + h[2] * (c[0] + c[4])					+ h[3] * (c[0] + c[5]);				for (int i = 3; (i < (c.length - 3)); i++) {					s[i] = h[0] * c[i] + h[1] * (c[i - 1] + c[i + 1])						+ h[2] * (c[i - 2] + c[i + 2]) + h[3] * (c[i - 3] + c[i + 3]);				}				s[s.length - 3] = h[0] * c[c.length - 3]					+ h[1] * (c[c.length - 4] + c[c.length - 2])					+ h[2] * (c[c.length - 5] + c[c.length - 1])					+ h[3] * (c[c.length - 6] + c[c.length - 1]);				s[s.length - 2] = h[0] * c[c.length - 2]					+ h[1] * (c[c.length - 3] + c[c.length - 1])					+ h[2] * (c[c.length - 4] + c[c.length - 1])					+ h[3] * (c[c.length - 5] + c[c.length - 2]);				s[s.length - 1] = h[0] * c[c.length - 1]					+ h[1] * (c[c.length - 2] + c[c.length - 1])					+ h[2] * (c[c.length - 3] + c[c.length - 2])					+ h[3] * (c[c.length - 4] + c[c.length - 3]);			}			else {				switch (c.length) {					case 5:						s[0] = h[0] * c[0] + h[1] * (c[0] + c[1]) + h[2] * (c[1] + c[2])							+ h[3] * (c[2] + c[3]);						s[1] = h[0] * c[1] + h[1] * (c[0] + c[2]) + h[2] * (c[0] + c[3])							+ h[3] * (c[1] + c[4]);						s[2] = h[0] * c[2] + h[1] * (c[1] + c[3])							+ (h[2] + h[3]) * (c[0] + c[4]);						s[3] = h[0] * c[3] + h[1] * (c[2] + c[4]) + h[2] * (c[1] + c[4])							+ h[3] * (c[0] + c[3]);						s[4] = h[0] * c[4] + h[1] * (c[3] + c[4]) + h[2] * (c[2] + c[3])							+ h[3] * (c[1] + c[2]);						break;					case 4:						s[0] = h[0] * c[0] + h[1] * (c[0] + c[1]) + h[2] * (c[1] + c[2])							+ h[3] * (c[2] + c[3]);						s[1] = h[0] * c[1] + h[1] * (c[0] + c[2]) + h[2] * (c[0] + c[3])							+ h[3] * (c[1] + c[3]);						s[2] = h[0] * c[2] + h[1] * (c[1] + c[3]) + h[2] * (c[0] + c[3])							+ h[3] * (c[0] + c[2]);						s[3] = h[0] * c[3] + h[1] * (c[2] + c[3]) + h[2] * (c[1] + c[2])							+ h[3] * (c[0] + c[1]);						break;					case 3:						s[0] = h[0] * c[0] + h[1] * (c[0] + c[1]) + h[2] * (c[1] + c[2])							+ 2.0 * h[3] * c[2];						s[1] = h[0] * c[1] + (h[1] + h[2]) * (c[0] + c[2])							+ 2.0 * h[3] * c[1];						s[2] = h[0] * c[2] + h[1] * (c[1] + c[2]) + h[2] * (c[0] + c[1])							+ 2.0 * h[3] * c[0];						break;					case 2:						s[0] = (h[0] + h[1] + h[3]) * c[0] + (h[1] + 2.0 * h[2] + h[3]) * c[1];						s[1] = (h[0] + h[1] + h[3]) * c[1] + (h[1] + 2.0 * h[2] + h[3]) * c[0];						break;					case 1:						s[0] = (h[0] + 2.0 * (h[1] + h[2] + h[3])) * c[0];						break;					default:						throw new NegativeArraySizeException("Invalid length of data");				}			}			break;		default:			throw new IllegalArgumentException(				"Invalid filter half-length (should be [2..4])");	}} /* end symmetricFirMirrorOffBounds *//*------------------------------------------------------------------*/private void symmetricFirMirrorOnBounds (	double[] h,	double[] c,	double[] s) {	if (c.length != s.length) {		throw new IndexOutOfBoundsException("Incompatible size");	}	switch (h.length) {		case 2:			if (2 <= c.length) {				s[0] = h[0] * c[0] + 2.0 * h[1] * c[1];				for (int i = 1; (i < (c.length - 1)); i++) {					s[i] = h[0] * c[i] + h[1] * (c[i - 1] + c[i + 1]);				}				s[s.length - 1] = h[0] * c[c.length - 1]					+ 2.0 * h[1] * c[c.length - 2];			}			else {				switch (c.length) {					case 1:						s[0] = (h[0] + 2.0 * h[1]) * c[0];						break;					default:						throw new NegativeArraySizeException("Invalid length of data");				}			}			break;		case 3:			if (4 <= c.length) {				s[0] = h[0] * c[0] + 2.0 * h[1] * c[1] + 2.0 * h[2] * c[2];				s[1] = h[0] * c[1] + h[1] * (c[0] + c[2]) + h[2] * (c[1] + c[3]);				for (int i = 2; (i < (c.length - 2)); i++) {					s[i] = h[0] * c[i] + h[1] * (c[i - 1] + c[i + 1])						+ h[2] * (c[i - 2] + c[i + 2]);				}				s[s.length - 2] = h[0] * c[c.length - 2]					+ h[1] * (c[c.length - 3] + c[c.length - 1])					+ h[2] * (c[c.length - 4] + c[c.length - 2]);				s[s.length - 1] = h[0] * c[c.length - 1]					+ 2.0 * h[1] * c[c.length - 2] + 2.0 * h[2] * c[c.length - 3];			}			else {				switch (c.length) {					case 3:						s[0] = h[0] * c[0] + 2.0 * h[1] * c[1] + 2.0 * h[2] * c[2];						s[1] = h[0] * c[1] + h[1] * (c[0] + c[2]) + 2.0 * h[2] * c[1];						s[2] = h[0] * c[2] + 2.0 * h[1] * c[1] + 2.0 * h[2] * c[0];						break;					case 2:						s[0] = (h[0] + 2.0 * h[2]) * c[0] + 2.0 * h[1] * c[1];						s[1] = (h[0] + 2.0 * h[2]) * c[1] + 2.0 * h[1] * c[0];						break;					case 1:						s[0] = (h[0] + 2.0 * (h[1] + h[2])) * c[0];						break;					default:						throw new NegativeArraySizeException("Invalid length of data");				}			}			break;		case 4:			if (6 <= c.length) {				s[0] = h[0] * c[0] + 2.0 * h[1] * c[1] + 2.0 * h[2] * c[2]					+ 2.0 * h[3] * c[3];				s[1] = h[0] * c[1] + h[1] * (c[0] + c[2]) + h[2] * (c[1] + c[3])					+ h[3] * (c[2] + c[4]);				s[2] = h[0] * c[2] + h[1] * (c[1] + c[3]) + h[2] * (c[0] + c[4])					+ h[3] * (c[1] + c[5]);				for (int i = 3; (i < (c.length - 3)); i++) {					s[i] = h[0] * c[i] + h[1] * (c[i - 1] + c[i + 1])						+ h[2] * (c[i - 2] + c[i + 2]) + h[3] * (c[i - 3] + c[i + 3]);				}				s[s.length - 3] = h[0] * c[c.length - 3]					+ h[1] * (c[c.length - 4] + c[c.length - 2])					+ h[2] * (c[c.length - 5] + c[c.length - 1])					+ h[3] * (c[c.length - 6] + c[c.length - 2]);				s[s.length - 2] = h[0] * c[c.length - 2]					+ h[1] * (c[c.length - 3] + c[c.length - 1])					+ h[2] * (c[c.length - 4] + c[c.length - 2])					+ h[3] * (c[c.length - 5] + c[c.length - 3]);				s[s.length - 1] = h[0] * c[c.length - 1] + 2.0 * h[1] * c[c.length - 2]					+ 2.0 * h[2] * c[c.length - 3] + 2.0 * h[3] * c[c.length - 4];			}			else {				switch (c.length) {					case 5:						s[0] = h[0] * c[0] + 2.0 * h[1] * c[1] + 2.0 * h[2] * c[2]							+ 2.0 * h[3] * c[3];						s[1] = h[0] * c[1] + h[1] * (c[0] + c[2]) + h[2] * (c[1] + c[3])							+ h[3] * (c[2] + c[4]);						s[2] = h[0] * c[2] + (h[1] + h[3]) * (c[1] + c[3])							+ h[2] * (c[0] + c[4]);						s[3] = h[0] * c[3] + h[1] * (c[2] + c[4]) + h[2] * (c[1] + c[3])							+ h[3] * (c[0] + c[2]);						s[4] = h[0] * c[4] + 2.0 * h[1] * c[3] + 2.0 * h[2] * c[2]							+ 2.0 * h[3] * c[1];						break;					case 4:						s[0] = h[0] * c[0] + 2.0 * h[1] * c[1] + 2.0 * h[2] * c[2]							+ 2.0 * h[3] * c[3];						s[1] = h[0] * c[1] + h[1] * (c[0] + c[2]) + h[2] * (c[1] + c[3])							+ 2.0 * h[3] * c[2];						s[2] = h[0] * c[2] + h[1] * (c[1] + c[3]) + h[2] * (c[0] + c[2])							+ 2.0 * h[3] * c[1];						s[3] = h[0] * c[3] + 2.0 * h[1] * c[2] + 2.0 * h[2] * c[1]							+ 2.0 * h[3] * c[0];						break;					case 3:						s[0] = h[0] * c[0] + 2.0 * (h[1] + h[3]) * c[1] + 2.0 * h[2] * c[2];						s[1] = h[0] * c[1] + (h[1] + h[3]) * (c[0] + c[2]) + 2.0 * h[2] * c[1];						s[2] = h[0] * c[2] + 2.0 * (h[1] + h[3]) * c[1] + 2.0 * h[2] * c[0];						break;					case 2:						s[0] = (h[0] + 2.0 * h[2]) * c[0] + 2.0 * (h[1] + h[3]) * c[1];						s[1] = (h[0] + 2.0 * h[2]) * c[1] + 2.0 * (h[1] + h[3]) * c[0];						break;					case 1:						s[0] = (h[0] + 2.0 * (h[1] + h[2] + h[3])) * c[0];						break;					default:						throw new NegativeArraySizeException("Invalid length of data");				}			}			break;		default:			throw new IllegalArgumentException(				"Invalid filter half-length (should be [2..4])");	}} /* end symmetricFirMirrorOnBounds *//*------------------------------------------------------------------*/private void symmetricFirPeriodic (	double[] h,	double[] c,	double[] s) {	if (c.length != s.length) {		throw new IndexOutOfBoundsException("Incompatible size");	}	switch (h.length) {		case 2:			if (2 <= c.length) {				s[0] = h[0] * c[0] + h[1] * (c[c.length - 1] + c[1]);				for (int i = 1; (i < (c.length - 1)); i++) {					s[i] = h[0] * c[i] + h[1] * (c[i - 1] + c[i + 1]);				}				s[s.length - 1] = h[0] * c[c.length - 1]					+ h[1] * (c[c.length - 2] + c[0]);			}			else {				switch (c.length) {					case 1:						s[0] = (h[0] + 2.0 * h[1]) * c[0];						break;					default:						throw new NegativeArraySizeException("Invalid length of data");				}			}			break;		case 3:			if (4 <= c.length) {				s[0] = h[0] * c[0] + h[1] * (c[c.length - 1] + c[1])					+ h[2] * (c[c.length - 2] + c[2]);				s[1] = h[0] * c[1] + h[1] * (c[0] + c[2])					+ h[2] * (c[c.length - 1] + c[3]);				for (int i = 2; (i < (c.length - 2)); i++) {					s[i] = h[0] * c[i] + h[1] * (c[i - 1] + c[i + 1])						+ h[2] * (c[i - 2] + c[i + 2]);				}				s[s.length - 2] = h[0] * c[c.length - 2]					+ h[1] * (c[c.length - 3] + c[c.length - 1])					+ h[2] * (c[c.length - 4] + c[0]);				s[s.length - 1] = h[0] * c[c.length - 1]					+ h[1] * (c[c.length - 2] + c[0])					+ h[2] * (c[c.length - 3] + c[1]);			}			else {				switch (c.length) {					case 3:						s[0] = h[0] * c[0] + (h[1] + h[2]) * (c[2] + c[1]);						s[1] = h[0] * c[1] + (h[1] + h[2]) * (c[0] + c[2]);						s[2] = h[0] * c[2] + (h[1] + h[2]) * (c[1] + c[0]);						break;					case 2:						s[0] = (h[0] + 2.0 * h[2]) * c[0] + 2.0 * h[1] * c[1];						s[1] = (h[0] + 2.0 * h[2]) * c[1] + 2.0 * h[1] * c[0];						break;					case 1:						s[0] = (h[0] + 2.0 * (h[1] + h[2])) * c[0];						break;					default:						throw new NegativeArraySizeException("Invalid length of data");				}			}			break;		case 4:			if (6 <= c.length) {				s[0] = h[0] * c[0] + h[1] * (c[c.length - 1] + c[1])					+ h[2] * (c[c.length - 2] + c[2])					+ h[3] * (c[c.length - 3] + c[3]);				s[1] = h[0] * c[1] + h[1] * (c[0] + c[2])					+ h[2] * (c[c.length - 1] + c[3])					+ h[3] * (c[c.length - 2] + c[4]);				s[2] = h[0] * c[2] + h[1] * (c[1] + c[3])					+ h[2] * (c[0] + c[4])					+ h[3] * (c[c.length - 1] + c[5]);				for (int i = 3; (i < (c.length - 3)); i++) {					s[i] = h[0] * c[i] + h[1] * (c[i - 1] + c[i + 1])						+ h[2] * (c[i - 2] + c[i + 2]) + h[3] * (c[i - 3] + c[i + 3]);				}				s[s.length - 3] = h[0] * c[c.length - 3]					+ h[1] * (c[c.length - 4] + c[c.length - 2])					+ h[2] * (c[c.length - 5] + c[c.length - 1])					+ h[3] * (c[c.length - 6] + c[0]);				s[s.length - 2] = h[0] * c[c.length - 2]					+ h[1] * (c[c.length - 3] + c[c.length - 1])					+ h[2] * (c[c.length - 4] + c[0])					+ h[3] * (c[c.length - 5] + c[1]);				s[s.length - 1] = h[0] * c[c.length - 1]					+ h[1] * (c[c.length - 2] + c[0])					+ h[2] * (c[c.length - 3] + c[1])					+ h[3] * (c[c.length - 4] + c[2]);			}			else {				switch (c.length) {					case 5:						s[0] = h[0] * c[0] + h[1] * (c[4] + c[1])							+ (h[2] + h[3]) * (c[3] + c[2]);						s[1] = h[0] * c[1] + h[1] * (c[0] + c[2])							+ (h[2] + h[3]) * (c[4] + c[3]);						s[2] = h[0] * c[2] + h[1] * (c[1] + c[3])							+ (h[2] + h[3]) * (c[0] + c[4]);						s[3] = h[0] * c[3] + h[1] * (c[2] + c[4])							+ (h[2] + h[3]) * (c[1] + c[0]);						s[4] = h[0] * c[4] + h[1] * (c[3] + c[0])							+ (h[2] + h[3]) * (c[2] + c[1]);						break;					case 4:						s[0] = h[0] * c[0] + (h[1] + h[3]) * (c[3] + c[1])							+ 2.0 * h[2] * c[2];						s[1] = h[0] * c[1] + (h[1] + h[3]) * (c[0] + c[2])							+ 2.0 * h[2] * c[3];						s[2] = h[0] * c[2] + (h[1] + h[3]) * (c[1] + c[3])							+ 2.0 * h[2] * c[0];						s[3] = h[0] * c[3] + (h[1] + h[3]) * (c[2] + c[0])							+ 2.0 * h[2] * c[1];						break;					case 3:						s[0] = h[0] * c[0] + (h[1] + h[2]) * (c[2] + c[1])							+ 2.0 * h[3] * c[0];						s[1] = h[0] * c[1] + (h[1] + h[2]) * (c[0] + c[2])							+ 2.0 * h[3] * c[1];						s[2] = h[0] * c[2] + (h[1] + h[2]) * (c[1] + c[0])							+ 2.0 * h[3] * c[2];						break;					case 2:						s[0] = (h[0] + 2.0 * h[2]) * c[0] + 2.0 * (h[1] + h[3]) * c[1];						s[1] = (h[0] + 2.0 * h[2]) * c[1] + 2.0 * (h[1] + h[3]) * c[0];						break;					case 1:						s[0] = (h[0] + 2.0 * (h[1] + h[2] + h[3])) * c[0];						break;					default:						throw new NegativeArraySizeException("Invalid length of data");				}			}			break;		default:			throw new IllegalArgumentException(				"Invalid filter half-length (should be [2..4])");	}} /* end symmetricFirPeriodic */} /* end class BsplineTransform_ */
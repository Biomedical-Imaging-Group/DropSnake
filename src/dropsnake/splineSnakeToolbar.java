/*====================================================================| DropSnake Version: March 22, 2005\===================================================================*//*====================================================================| EPFL/STI/IOA/BIG| Aurï¿½lien Stalder| aurelien.stalder@gmail.com|\===================================================================*/// Based on the plugin SplineSnake by Mathews Jacob; Version: March 1, 2003package dropsnake;import ij.gui.GUI;import ij.gui.ImageCanvas;import ij.gui.Roi;import ij.gui.Toolbar;import ij.IJ;import ij.ImagePlus;import ij.measure.Calibration;import ij.plugin.PlugIn;import ij.WindowManager;import java.awt.Button;import java.awt.Canvas;import java.awt.CheckboxGroup;import java.awt.Color;import java.awt.Component;import java.awt.Container;import java.awt.Dialog;import java.awt.Event;import java.awt.FileDialog;import java.awt.Font;import java.awt.Frame;import java.awt.Graphics;import java.awt.GridLayout;import java.awt.Insets;import java.awt.Label;import java.awt.Point;import java.awt.Polygon;import java.awt.event.ActionEvent;import java.awt.event.ActionListener;import java.awt.event.KeyEvent;import java.awt.event.KeyListener;import java.awt.event.MouseEvent;import java.awt.event.MouseListener;import java.awt.event.MouseMotionListener;import java.io.BufferedReader;import java.io.FileNotFoundException;import java.io.FileReader;import java.io.FileWriter;import java.io.IOException;import java.util.Vector;import ij.gui.*;import java.awt.*;import ij.plugin.*;import java.awt.Font;/*====================================================================|	splineSnakeToolbar\===================================================================*//********************************************************************* * This class deals with the toolbar that gets substituted to that of * ImageJ. ********************************************************************/public class splineSnakeToolbar	extends		Canvas	implements		MouseListener,		MouseMotionListener{ /* begin class splineSnakeToolbar *//*....................................................................	Private variables....................................................................*/public static final int NUM_TOOLS = 19;public static final int SIZE = 22;private static final int OFFSET = 3;private static final Color gray = Color.lightGray;private static final Color brighter = gray.brighter();private static final Color darker = gray.darker();private static final Color evenDarker = darker.darker();private final boolean[] down = new boolean[NUM_TOOLS];private Graphics g;private ImagePlus imp;private Toolbar previousInstance;private splineSnakeHandler ph;private splineSnakeToolbar instance;public int currentTool = splineSnakeAction.MAGNIFIER;private int x;private int y;private int xOffset;private int yOffset;public Snake contour;public boolean toolBaractive = false;private long	mouseDownTime = System.currentTimeMillis();public boolean computing = false;private SaveParameters saveParam;private About about_inst=new About();private int previousTool;	/*....................................................................	Public methods....................................................................*//********************************************************************* * Return the index of the tool that is currently activated. ********************************************************************/public int getCurrentTool () {	return(currentTool);} /* getCurrentTool *//********************************************************************* * Listen to <code>mouseClicked</code> events. * * @param e Ignored. ********************************************************************/public void mouseClicked (	final MouseEvent e) {} /* end mouseClicked *//********************************************************************* * Listen to <code>mouseEntered</code> events. * * @param e Ignored. ********************************************************************/public void mouseEntered (	final MouseEvent e) {} /* end mouseEntered *//********************************************************************* * Listen to <code>mouseExited</code> events. * * @param e Ignored. ********************************************************************/public void mouseExited (	final MouseEvent e) {} /* end mouseExited *//********************************************************************* * Listen to <code>mouseDragged</code> events. * * @param e Ignored. ********************************************************************/public void mouseDragged (	final MouseEvent e) {} /* end mouseDragged *//********************************************************************* * Listen to <code>mouseMoved</code> events. * * @param e Ignored. ********************************************************************/public void mouseMoved (	final MouseEvent e) {				if(toolBaractive)	{		final int x = e.getX();		final int y = e.getY();				int newTool = 0;		for (int i = 0; (i < NUM_TOOLS); i++) {			if (((i * SIZE) < x) && (x < (i * SIZE + SIZE))) {				newTool = i;			}		}		showMessage(newTool);	}		} /* end mouseDragged *//********************************************************************* * Listen to <code>mousePressed</code> events. Test for single or double * clicks and perform the relevant action. * * @param e Event. ********************************************************************/public void mousePressed (	final MouseEvent e	) {			if(toolBaractive)	{			final int x = e.getX();		final int y = e.getY();		previousTool = currentTool;		int newTool = 0;		for (int i = 0; (i < NUM_TOOLS); i++) {			if (((i * SIZE) < x) && (x < (i * SIZE + SIZE))) {				newTool = i;			}		}				if(newTool != splineSnakeAction.SNAKE_CURVE)			setTool(newTool);				final boolean doubleClick = ((System.currentTimeMillis() - mouseDownTime) <= 500L);		mouseDownTime = System.currentTimeMillis();				if(!computing) {			saveParam = new SaveParameters(ph.preferences);		}		//IJ.write("time save params : " +(System.currentTimeMillis()-mouseDownTime));									switch (newTool) {					case splineSnakeAction.FILE:				if(!computing)						{							splineFlowFile fileDialog								= new splineFlowFile(IJ.getInstance(), ph, imp);							GUI.center(fileDialog);							fileDialog.setVisible(true);							setTool(previousTool);							fileDialog.dispose();						}				 else						setTool(splineSnakeAction.SNAKE_CURVE);				break;																	case splineSnakeAction.REMOVE_ALL:				if(!computing)						{							if(ph.listKnots.size() == 0)								IJ.error("Please create before you destroy ");							else if(previousTool == splineSnakeAction.SNAKE_CURVE)								IJ.error("Please stop the computation before you remove all ");							else								{									splineFlowClearAll clearAllDialog										= new splineFlowClearAll(IJ.getInstance(), ph, true);									GUI.center(clearAllDialog);									clearAllDialog.setVisible(true);									clearAllDialog.dispose();								}							setTool(splineSnakeAction.ADD_CROSS);						}					else						setTool(splineSnakeAction.SNAKE_CURVE);				break;								case splineSnakeAction.ACCEPT:				if(!computing)					{						if(ph.curveComputed ) 							{								/*selectCurrentCurve ccurve = new selectCurrentCurve(IJ.getInstance());								GUI.center(ccurve);								ccurve.setVisible(true);								if (ccurve.cancel) 									setTool(previousTool);								else								{									ph.listKnots.removeAllElements();									double[] xpoints = new double[ph.FinalClosedCurve.npoints-2];									double[] ypoints = new double[ph.FinalClosedCurve.npoints-2];										int k=0;									for(int i=0;i<=ph.FinalClosedCurve.ncurvepts; i+=ph.FinalClosedCurve.Nsamples)										{																						xpoints[k] = (ph.FinalClosedCurve.CurveX[i]);											ypoints[k] = (ph.FinalClosedCurve.CurveY[i]);																						int x1 = (int)(ph.FinalClosedCurve.CurveX[i]+0.5);											int y1 = (int)(ph.FinalClosedCurve.CurveY[i]+0.5);											final Point p = new Point(x1,y1);											ph.listKnots.addElement(p);											k++;										}									//ph.InitialClosedCurve = ph.FinalClosedCurve;									ph.InitialClosedCurve = new Curve(ph.listKnots.size(),ph.preferences.Nresample, xpoints, ypoints, 3, true);									ph.curveComputed = false;									ph.imp.draw();																	}*/																									acceptCurve();															}						else							{								IJ.error("I can accept the final snake only after it is computed");							}						setTool(previousTool);					}				else					setTool(splineSnakeAction.SNAKE_CURVE);									break;									case splineSnakeAction.SNAKE_CURVE:				if(computing)				{					contour.stop();						resetTool();				   	progressBarVolume pb = new progressBarVolume();				   	pb.setProgressBarVolume("Aborted snaking", 1, 1);					pb.showCompleted();					ph.imp.draw();					//setTool(splineSnakeAction.ADD_CROSS);				}				else				{					if(ph.curveClosed) 						{							// compute the snake														computing = true;							double[] xpoints = new double[ph.listKnots.size()];							double[] ypoints = new double[ph.listKnots.size()];							int minx = 10000;							int miny = 10000;							int maxx = 0;							int maxy = 0;														for (int k = 0; k < ph.listKnots.size(); k++) 								{										Point p = (Point)ph.listKnots.elementAt(k);									xpoints[k] = (double)p.x;									ypoints[k] = (double)p.y;									minx = (minx>p.x)? p.x: minx;									miny = (miny>p.y)? p.y: miny;																		maxx = (maxx<p.x)? p.x: maxx;									maxy = (maxy<p.y)? p.y: maxy;								}															if(ph.preferences.gradmag)								{									ph.FinalClosedCurve = new Curve(ph.listKnots.size(),ph.preferences.Nresample, xpoints, ypoints, 3, false);									evolveCurveDisplay ec = new evolveCurveDisplay();									ec.evolveCurveClosed(ph.imp, ph.FinalClosedCurve,ph.imageD,ph.preferences.SnakeGamma, ph.preferences.SnakeMaxIter,true);									ph.curveComputed = true;									IJ.write("Done");									computing = false;									ph.imp.draw();									setTool(splineSnakeAction.ADD_CROSS);								}							else								{									ph.FinalClosedCurve = new Curve(ph.listKnots.size(),ph.preferences.Nresample, xpoints, ypoints, 3, true);									ph.FinalClosedCurve.resample(ph.preferences.knotsDistance,ph.preferences.gamma);																		if( ph.preferences.springs)										contour = new Snake(ph.imp, ph.FinalClosedCurve, ph.preferences, ph.listConstraints, ph);									else										{											Vector junk = new Vector(0, 16);											contour = new Snake(ph.imp, ph.FinalClosedCurve, ph.preferences, junk, ph);										}									ph.curveComputed = true;									computing = true;									contour.start();									setTool(splineSnakeAction.SNAKE_CURVE);																	}						}					else						{							IJ.error("Please close the curve by clicking on the red point");							setTool(splineSnakeAction.ADD_CROSS);						}				}				break;							case splineSnakeAction.PREF:				if(!computing)					{						double oldsigma = ph.preferences.GUISigma;						ph.preferences.doDialog(); 												if(ph.preferences.GUISigma != oldsigma)							ph.imageD = new ImageDisplay(ph.imp,ph.preferences.GUISigma);													ph.imp.draw();						setTool(previousTool); 					}				else					setTool(splineSnakeAction.SNAKE_CURVE);			break;											case splineSnakeAction.ADD_CROSS:				if(computing)					setTool(splineSnakeAction.SNAKE_CURVE);			break;								case splineSnakeAction.REMOVE_CROSS:				if(computing)					setTool(splineSnakeAction.SNAKE_CURVE);			break;						case splineSnakeAction.MAGNIFIER:				if(computing)					setTool(splineSnakeAction.SNAKE_CURVE);			break;						case splineSnakeAction.DROP:				if(computing)				{					contour.stop();						resetTool();				   	progressBarVolume pb = new progressBarVolume();				   	pb.setProgressBarVolume("Aborted snaking", 1, 1);					pb.showCompleted();					ph.imp.draw();					setTool(splineSnakeAction.ADD_CROSS);				}				else				{						// compute the snake														computing = true;																					ph.preferences.initialization=true;							ph.preferences.EnergySurfaces=true;							ph.preferences.eRatio=0.5;							ph.preferences.knotsRatio=1.0;							ph.preferences.gamma=0.0;							ph.preferences.interpolate=false;							ph.preferences.Psample=5.0;							ph.preferences.SnakeThreshold=0.10;							ph.preferences.SnakeSigma=10.0;							ph.preferences.SnakeGamma=5.0;														int nx=ph.imp.getWidth();							int ny=ph.imp.getHeight();																												int nknots=7;							double[] xpoints = new double[nknots];							double[] ypoints = new double[nknots];																					xpoints[0]=0.1*nx;							ypoints[0]=0.5*ny;								xpoints[3]=0.5*nx;							ypoints[3]=0.1*ny;														xpoints[6]=0.9*nx;							ypoints[6]=0.5*ny;														xpoints[1]=0.7*xpoints[0]+0.3*xpoints[3];							ypoints[1]=0.7*ypoints[0]+0.3*ypoints[3];							xpoints[2]=0.3*xpoints[0]+0.7*xpoints[3];							ypoints[2]=0.3*ypoints[0]+0.7*ypoints[3];														xpoints[4]=0.3*xpoints[6]+0.7*xpoints[3];							ypoints[4]=0.3*ypoints[6]+0.7*ypoints[3];							xpoints[5]=0.7*xpoints[6]+0.3*xpoints[3];							ypoints[5]=0.7*ypoints[6]+0.3*ypoints[3];														/*int nknots=5;							double[] xpoints = new double[nknots];							double[] ypoints = new double[nknots];																					xpoints[0]=0.1*nx;							ypoints[0]=0.5*ny;								xpoints[2]=0.5*nx;							ypoints[2]=0.1*ny;														xpoints[4]=0.9*nx;							ypoints[4]=0.5*ny;														xpoints[1]=0.5*(xpoints[0]+xpoints[2]);							ypoints[1]=0.5*(ypoints[0]+ypoints[2]);							xpoints[3]=0.5*(xpoints[4]+xpoints[2]);							ypoints[3]=0.5*(ypoints[4]+ypoints[2]);							*/														ph.InitialClosedCurve = new Curve(nknots,ph.preferences.Nresample, xpoints, ypoints, 3,true);							ph.FinalClosedCurve = new Curve(nknots,ph.preferences.Nresample, xpoints, ypoints, 3,true);														ph.curveClosed=true;														ph.listKnots.removeAllElements();							int k=0;							for(int i=0;i<=ph.FinalClosedCurve.ncurvepts; i+=ph.FinalClosedCurve.Nsamples)								{																		int x1 = (int)(ph.FinalClosedCurve.CurveX[i]+0.5);									int y1 = (int)(ph.FinalClosedCurve.CurveY[i]+0.5);									final Point p = new Point(x1,y1);									ph.listKnots.addElement(p);									k++;								}							ph.listBuffer.removeAllElements();							ph.listConstraints.removeAllElements();																	//ph.FinalClosedCurve = new Curve(ph.InitialClosedCurve.npoints,ph.preferences.Nresample, ph.InitialClosedCurve.CoeffXtemp, ph.InitialClosedCurve.CoeffYtemp, 3, true);														Vector junk = new Vector(0, 16);							contour = new Snake(ph.imp, ph.FinalClosedCurve, ph.preferences, junk, ph);							ph.curveComputed = true;							computing = true;							contour.start();							setTool(splineSnakeAction.SNAKE_CURVE);																							}				break;								case splineSnakeAction.DROP2:				if(computing)				{					contour.stop();						resetTool();				   	progressBarVolume pb = new progressBarVolume();				   	pb.setProgressBarVolume("Aborted snaking", 1, 1);					pb.showCompleted();					ph.imp.draw();					setTool(splineSnakeAction.ADD_CROSS);				}				else				{					if(ph.curveClosed) 						{							// compute the snake														computing = true;							ph.preferences.initialization=true;							ph.preferences.EnergySurfaces=true;							ph.preferences.eRatio=0.5;							ph.preferences.knotsRatio=1.0;							ph.preferences.gamma=0.0;							ph.preferences.interpolate=false;							ph.preferences.Psample=5.0;							ph.preferences.SnakeThreshold=0.10;							ph.preferences.SnakeSigma=10.0;							ph.preferences.SnakeGamma=5.0;														double[] xpoints = new double[ph.listKnots.size()];							double[] ypoints = new double[ph.listKnots.size()];							int minx = 10000;							int miny = 10000;							int maxx = 0;							int maxy = 0;														for (int k = 0; k < ph.listKnots.size(); k++) 								{										Point p = (Point)ph.listKnots.elementAt(k);									xpoints[k] = (double)p.x;									ypoints[k] = (double)p.y;									minx = (minx>p.x)? p.x: minx;									miny = (miny>p.y)? p.y: miny;																		maxx = (maxx<p.x)? p.x: maxx;									maxy = (maxy<p.y)? p.y: maxy;								}								if( ((maxx-minx) < (2*ph.preferences.KnotInerval)) |((maxy-miny) < (2*ph.preferences.KnotInerval)) );								//IJ.error("      Knot spacing too large\n Snake may not capture the details");														if(ph.preferences.gradmag)								{									ph.FinalClosedCurve = new Curve(ph.listKnots.size(),ph.preferences.Nresample, xpoints, ypoints, 3, false);									evolveCurveDisplay ec = new evolveCurveDisplay();									ec.evolveCurveClosed(ph.imp, ph.FinalClosedCurve,ph.imageD,ph.preferences.SnakeGamma, ph.preferences.SnakeMaxIter,true);									ph.curveComputed = true;									IJ.write("Done");									computing = false;									ph.imp.draw();									setTool(splineSnakeAction.ADD_CROSS);								}							else								{									ph.FinalClosedCurve = new Curve(ph.listKnots.size(),ph.preferences.Nresample, xpoints, ypoints, 3, true);									//ph.FinalClosedCurve = new Curve(ph.InitialClosedCurve.npoints,ph.preferences.Nresample, ph.InitialClosedCurve.CoeffX, ph.InitialClosedCurve.CoeffYtemp, 3, false);									//ph.FinalClosedCurve = new Curve(ph.listKnots.size(),ph.preferences.Nresample, xpoints, ypoints, 3, false);									if( ph.preferences.springs)										contour = new Snake(ph.imp, ph.FinalClosedCurve, ph.preferences, ph.listConstraints, ph);									else										{											Vector junk = new Vector(0, 16);											contour = new Snake(ph.imp, ph.FinalClosedCurve, ph.preferences, junk, ph);										}									ph.curveComputed = true;									computing = true;									contour.start();									setTool(splineSnakeAction.SNAKE_CURVE);								}						}					else						{							IJ.error("Please close the curve by clicking on the red point");							setTool(splineSnakeAction.ADD_CROSS);						}				}				break;				/*if(computing)				{					contour.stop();						resetTool();				   	progressBarVolume pb = new progressBarVolume();				   	pb.setProgressBarVolume("Aborted snaking", 1, 1);					pb.showCompleted();					ph.imp.draw();					setTool(splineSnakeAction.ADD_CROSS);				}				else				{						// compute the snake														computing = true;														Initialization init = new Initialization();							init.getKnots(ph.imp);														ph.InitialClosedCurve = new Curve(init.size,ph.preferences.Nresample, init.xpoints, init.ypoints, 3,false);							//ph.InitialClosedCurve.npoints=init.size;							ph.curveClosed=true;														ph.listKnots.removeAllElements();							for (int k = 0; k < ph.InitialClosedCurve.npoints; k++)		//only Npoints, because only points from the top part can be moved 								{										int xp = (int)(ph.InitialClosedCurve.CoeffXtemp[k]+0.5);									int yp = (int)(ph.InitialClosedCurve.CoeffYtemp[k]+0.5);									final Point p = new Point(xp, yp);									ph.listKnots.addElement(p);								}							ph.listBuffer.removeAllElements();							ph.listConstraints.removeAllElements();																	ph.FinalClosedCurve = new Curve(ph.InitialClosedCurve.npoints,ph.preferences.Nresample, ph.InitialClosedCurve.CoeffXtemp, ph.InitialClosedCurve.CoeffYtemp, 3, false);														Vector junk = new Vector(0, 16);							contour = new Snake(ph.imp, ph.FinalClosedCurve, ph.preferences, junk, ph);							ph.curveComputed = true;							computing = true;							contour.start();							setTool(splineSnakeAction.SNAKE_CURVE);										}				break;			*/									case splineSnakeAction.STACK:				int firstSlice=ph.imp.getCurrentSlice();				int totalSlices=ph.imp.getStackSize();												int lastSlice=Integer.parseInt(IJ.getString("last slice",java.lang.String.valueOf(ph.imp.getStackSize())));							if(lastSlice>totalSlices) lastSlice=totalSlices;								if(computing)				{					contour.stop();						resetTool();				   	progressBarVolume pb = new progressBarVolume();				   	pb.setProgressBarVolume("Aborted snaking", 1, 1);					pb.showCompleted();					ph.imp.draw();					//setTool(splineSnakeAction.ADD_CROSS);				}				else				{					if(ph.curveClosed) 						{							// compute the snake							ph.preferences.stack=true;														//for(int i=ph.imp.getCurrentSlice(); i<ph.imp.getCurrentSlice()+10; i++){								//ph.imp.setSlice(i);								computing = true;								double[] xpoints = new double[ph.listKnots.size()];								double[] ypoints = new double[ph.listKnots.size()];								int minx = 10000;								int miny = 10000;								int maxx = 0;								int maxy = 0;																for (int k = 0; k < ph.listKnots.size(); k++) 									{											Point p = (Point)ph.listKnots.elementAt(k);										xpoints[k] = (double)p.x;										ypoints[k] = (double)p.y;										minx = (minx>p.x)? p.x: minx;										miny = (miny>p.y)? p.y: miny;																				maxx = (maxx<p.x)? p.x: maxx;										maxy = (maxy<p.y)? p.y: maxy;									}																	if(ph.preferences.gradmag)									{										ph.FinalClosedCurve = new Curve(ph.listKnots.size(),ph.preferences.Nresample, xpoints, ypoints, 3, false);										evolveCurveDisplay ec = new evolveCurveDisplay();										ec.evolveCurveClosed(ph.imp, ph.FinalClosedCurve,ph.imageD,ph.preferences.SnakeGamma, ph.preferences.SnakeMaxIter,true);										ph.curveComputed = true;										IJ.write("Done");										computing = false;										ph.imp.draw();										setTool(splineSnakeAction.ADD_CROSS);									}								else									{										ph.FinalClosedCurve = new Curve(ph.listKnots.size(),ph.preferences.Nresample, xpoints, ypoints, 3, true);										//ph.FinalClosedCurve.resample(ph.preferences.knotsDistance,ph.preferences.gamma);																				if( ph.preferences.springs)											contour = new Snake(ph.imp, ph.FinalClosedCurve, ph.preferences, ph.listConstraints, ph);										else											{												Vector junk = new Vector(0, 16);												//IJ.write("CA" +ph.FinalClosedCurve.CA[0] +" " +ph.FinalClosedCurve.CA[1]);												contour = new Snake(ph.imp, ph.FinalClosedCurve, ph.preferences, junk, ph);											}										ph.curveComputed = true;										computing = true;										contour.start();										setTool(splineSnakeAction.SNAKE_CURVE);										while(computing);																			}								//}																for(int i=firstSlice+1; i<=lastSlice; i++){									ph.imp.setSlice(i);									Vector junk = new Vector(0, 16);																		//IJ.write("CA" +ph.FinalClosedCurve.CA[0] +" " +ph.FinalClosedCurve.CA[1]);																		contour = new Snake(ph.imp, ph.FinalClosedCurve, ph.preferences, junk, ph);									ph.curveComputed = true;									computing = true;									contour.start();									setTool(splineSnakeAction.SNAKE_CURVE);									while(computing);																											}																																					}					else						{							IJ.error("Please close the curve by clicking on the red point");							setTool(splineSnakeAction.ADD_CROSS);						}				}				break;							case splineSnakeAction.ABOUT:								about_inst.doDialog();													break;							case splineSnakeAction.TERMINATE:				splineFlowTerminate terminateDialog					= new splineFlowTerminate(IJ.getInstance());				GUI.center(terminateDialog);				terminateDialog.setVisible(true);				if (terminateDialog.choseCancel()) {					setTool(previousTool);				}					else {							if(ph.curveComputed)								contour.stop();																					//DropSnake_.running = false;							if(ph.curveComputed)							contour.stop();								progressBarVolume pb1 = new progressBarVolume();							pb1.setProgressBarVolume("Aborted snaking", 1, 1);							pb1.showCompleted();							ph.cleanUp();							restorePreviousToolbar();							Toolbar.getInstance().repaint();														if(ph.curveComputed)								{									int[] x1 = new int[ph.FinalClosedCurve.NCurvepts];									int[] y1 = new int[ph.FinalClosedCurve.NCurvepts];									for (int i=0; i<ph.FinalClosedCurve.NCurvepts; i++) {										x1[i] = (int)ph.FinalClosedCurve.CurveX[i];										y1[i] = (int)ph.FinalClosedCurve.CurveY[i];									}									Roi roi = new PolygonRoi(x1, y1, ph.FinalClosedCurve.NCurvepts, null, Roi.POLYGON);									Rectangle r = roi.getBoundingRect();									ph.imp.setRoi(roi);								}							else if(ph.curveClosed)								{									int[] x1 = new int[ph.InitialClosedCurve.NCurvepts];									int[] y1 = new int[ph.InitialClosedCurve.NCurvepts];									for (int i=0; i<ph.InitialClosedCurve.NCurvepts; i++) {										x1[i] = (int)ph.InitialClosedCurve.CurveX[i];										y1[i] = (int)ph.InitialClosedCurve.CurveY[i];									}									Roi roi = new PolygonRoi(x1, y1, ph.InitialClosedCurve.NCurvepts, null, Roi.POLYGON);									Rectangle r = roi.getBoundingRect();									ph.imp.setRoi(roi);								}							ph.curveClosed = false;							ph.curveComputed = false;													}																		terminateDialog.dispose();				break;		}		}	} /* mousePressed */	private void acceptCurve () {				selectCurrentCurve ccurve = new selectCurrentCurve(IJ.getInstance());		GUI.center(ccurve);		ccurve.setVisible(true);//		IJ.write("ccurve.cancel " +ccurve.cancel);		if (ccurve.cancel) 			setTool(previousTool);		else		{			ph.listKnots.removeAllElements();			double[] xpoints = new double[ph.FinalClosedCurve.npoints-2];			double[] ypoints = new double[ph.FinalClosedCurve.npoints-2];				int k=0;			for(int i=0;i<=ph.FinalClosedCurve.ncurvepts; i+=ph.FinalClosedCurve.Nsamples)				{										xpoints[k] = (ph.FinalClosedCurve.CurveX[i]);					ypoints[k] = (ph.FinalClosedCurve.CurveY[i]);										int x1 = (int)(ph.FinalClosedCurve.CurveX[i]+0.5);					int y1 = (int)(ph.FinalClosedCurve.CurveY[i]+0.5);					final Point p = new Point(x1,y1);					ph.listKnots.addElement(p);					k++;				}			//ph.InitialClosedCurve = ph.FinalClosedCurve;			ph.InitialClosedCurve = new Curve(ph.listKnots.size(),ph.preferences.Nresample, xpoints, ypoints, 3, true);			ph.curveComputed = false;			ph.imp.draw();		}		//IJ.write("ccurve.cancel after " +ccurve.cancel);			}	/*********************************************************************	 * Listen to <code>mouseReleased</code> events.	 *	 * @param e Ignored.	 ********************************************************************/	public void mouseReleased (		final MouseEvent e	) {	} /* end mouseReleased */	/*********************************************************************	 * Draw the tools of the toolbar.	 *	 * @param g Graphics environment.	 ********************************************************************/	public void paint (		final Graphics g	) {		for (int i = 0; (i < NUM_TOOLS); i++) {			drawButton(g, i);		}	} /* paint */	/*********************************************************************	 * This constructor substitutes ImageJ's toolbar by that of PointPicker_.	 *	 * @param previousToolbar ImageJ's toolbar.	 ********************************************************************/	public splineSnakeToolbar (		final Toolbar previousToolbar	) {		previousInstance = previousToolbar;		instance = this;		final Container container = previousToolbar.getParent();		final Component component[] = container.getComponents();		for (int i = 0; (i < component.length); i++) {			if (component[i] == previousToolbar) {				container.remove(previousToolbar);				container.add(this, i);				break;			}		}		resetButtons();		down[currentTool] = true;		setTool(currentTool);		IJ.showStatus("Initializing. Please wait");		setForeground(evenDarker);		setBackground(gray);		addMouseListener(this);		addMouseMotionListener(this);				container.validate();	} /* end splineSnakeToolbar */	/*********************************************************************	 * Setup the point handler.	 *	 * @param ph2 <code>splineSnakeHandler<code> object that handles operations.	 * @param imp <code>ImagePlus<code> object where points are being picked.	 ********************************************************************/	public void setWindow (		final splineSnakeHandler ph2,		final ImagePlus imp	) {		this.ph = ph2;		this.imp = imp;	} /* end setWindow */	/*********************************************************************	 * Setup the current tool. The selection of non-functional tools is	 * honored but leads to a no-op action.	 *	 * @param tool Admissible tools belong to [<code>0</code>,	 * <code>NUM_TOOLS - 1</code>]	 ********************************************************************/	public void setTool (		final int tool	) {		if (tool == currentTool) {			return;		}		down[tool] = true;		down[currentTool] = false;		final Graphics g = this.getGraphics();		drawButton(g, currentTool);		drawButton(g, tool);		g.dispose();		showMessage(tool);		currentTool = tool;	} /* end setTool */				/*********************************************************************	 * resetTool	 ********************************************************************/	public void resetTool (	) {			computing = false;			setTool(splineSnakeAction.ADD_CROSS);			if(ph.preferences.initialization) {				previousTool = splineSnakeAction.ADD_CROSS;				//acceptCurve();			}			saveParam.restoreParameters(ph.preferences);	} /* end resetTool */	/*....................................................................		Private methods	....................................................................*/	 /*------------------------------------------------------------------*/	private void d (		int x,		int y	) {		x += xOffset;		y += yOffset;		g.drawLine(this.x, this.y, x, y);		this.x = x;		this.y = y;	} /* end d */	/*------------------------------------------------------------------*/	private void drawButton (		final Graphics g,		final int tool	) {				int x,y;		if(tool!=splineSnakeAction.SNAKE_CURVE)			{				fill3DRect(g, tool * SIZE + 1, 1, SIZE, SIZE - 1, !down[tool]);			g.setColor(Color.black);			x = tool * SIZE + OFFSET;			y = OFFSET;			if (down[tool]) 				{					x++;					y++;				}			}		else			{				fill3DRect(g, tool * SIZE + 1, 1, SIZE, SIZE - 1, true);				g.setColor(Color.black);				x = tool * SIZE + OFFSET;				y = OFFSET;								}							this.g = g;		switch (tool) {						case splineSnakeAction.ADD_CROSS:				g.setColor(Color.blue);				xOffset = x;				yOffset = y;				m(7, 0);				d(7, 1);				m(6, 2);				d(6, 3);				m(8, 2);				d(8, 3);				m(5, 4);				d(5, 5);				m(9, 4);				d(9, 5);				m(4, 6);				d(4, 8);				m(10, 6);				d(10, 8);				m(5, 9);				d(5, 14);				m(9, 9);				d(9, 14);				m(7, 4);				d(7, 6);				m(7, 8);				d(7, 8);				m(4, 11);				d(10, 11);				g.fillRect(x + 6, y + 12, 3, 3);				m(11, 13);				d(15, 13);				m(13, 11);				d(13, 15);				break;					case splineSnakeAction.REMOVE_CROSS:				g.setColor(Color.red);				xOffset = x;				yOffset = y;				m(7, 0);				d(7, 1);				m(6, 2);				d(6, 3);				m(8, 2);				d(8, 3);				m(5, 4);				d(5, 5);				m(9, 4);				d(9, 5);				m(4, 6);				d(4, 8);				m(10, 6);				d(10, 8);				m(5, 9);				d(5, 14);				m(9, 9);				d(9, 14);				m(7, 4);				d(7, 6);				m(7, 8);				d(7, 8);				m(4, 11);				d(10, 11);				g.fillRect(x + 6, y + 12, 3, 3);				m(11, 13);				d(15, 13);				break;			/*			case splineSnakeAction.ADD_CONSTRAINT:				g.setColor(Color.blue);				g.drawArc(x-8,y-3,15,15,45,-135);				g.setColor(Color.red);				g.fillOval(x+10,y+7,3,3);				xOffset = x;				yOffset = y;				m(10,7);				d(6,6);				g.setColor(Color.blue);				m(11, 13);				d(15, 13);				m(13, 11);				d(13, 15);												break;				case splineSnakeAction.REMOVE_CONSTRAINT:				g.setColor(Color.blue);				g.drawArc(x-8,y-3,15,15,45,-135);				g.setColor(Color.red);				g.fillOval(x+10,y+7,3,3);				xOffset = x;				yOffset = y;				m(10,7);				d(6,6);				g.setColor(Color.red);				m(11, 13);				d(15, 13);				break;			*/			case splineSnakeAction.REMOVE_ALL:			g.setColor(Color.red);				xOffset = x-3;				yOffset = y;				m(7, 0);				d(7, 1);				m(6, 2);				d(6, 3);				m(8, 2);				d(8, 3);				m(5, 4);				d(5, 5);				m(9, 4);				d(9, 5);				m(4, 6);				d(4, 8);				m(10, 6);				d(10, 8);				m(5, 9);				d(5, 14);				m(9, 9);				d(9, 14);				m(7, 4);				d(7, 6);				m(7, 8);				d(7, 8);				m(4, 11);				d(10, 11);				g.fillRect(x + 3, y + 12, 3, 3);				m(12, 13);				d(14, 13);								m(17, 13);				d(19, 13);			break;						case splineSnakeAction.FILE:				xOffset = x;				yOffset = y;				m(3, 1);				d(9, 1);				d(9, 4);				d(12, 4);				d(12, 14);				d(3, 14);				d(3, 1);				m(10, 2);				d(11, 3);				m(5, 4);				d(7, 4);				m(5, 6);				d(10, 6);				m(5, 8);				d(10, 8);				m(5, 10);				d(10, 10);				m(5, 12);				d(10, 12);				break;							case splineSnakeAction.ACCEPT:					g.setColor(Color.green);				    xOffset = x+2; yOffset = y+1;		           int[] xpoly5 = new int[4];				   int[] ypoly5 = new int[4];				   xpoly5[0] = x+4; xpoly5[1] = x+14; xpoly5[2] = x+4; xpoly5[3] = x+4; 				   ypoly5[0] = y+2; ypoly5[1] = y+8; ypoly5[2] = y+14; ypoly5[3] = y+2; 				   Polygon poly5 = new Polygon(xpoly5,ypoly5,4);				   g.fillPolygon(poly5);				   g.setColor(Color.black);				   g.drawPolygon(poly5);			break;						case splineSnakeAction.SNAKE_CURVE:						if(!computing)			{					xOffset = x;				yOffset = y;				g.setColor(Color.red);				m(0,2);				d(1,3);				d(3,3);				d(0,4);				g.setColor(Color.green);				m(5,2);				d(7,2);				m(5,4);				d(7,4);				m(4,3);				d(13,3);				d(13,4);				d(14,4);				d(14,7);				d(13,7);				d(13,8);				d(5,8);				d(5,9);				d(4,9);				d(4,12);				d(5,12);				d(5,13);				d(13,13);				g.setColor(Color.black);				m(3,3);				d(5,1);				d(7,1);				d(8,2);				d(13,2);				d(15,4);				d(15,7);				d(13,9);				d(6,9);				d(5,10);				d(5,11);				d(6,12);				d(13,12);				d(15,13);				d(13,14);				d(5,14);				d(3,12);				d(3,9);				d(5,7);				d(12,7);				d(13,6);				d(13,5);				d(12,4);				d(8,4);				d(7,5);				d(5,5);				d(3,3);			}		else					{					 xOffset = x+1; yOffset = y+1;		           int[] xpoly4 = new int[4];				   int[] ypoly4 = new int[4];				  				   xpoly4[0] = xOffset; xpoly4[1] = xOffset+4; xpoly4[2] = xOffset+14; xpoly4[3] = xOffset+10;						   ypoly4[0] = yOffset; ypoly4[1] = yOffset+0; ypoly4[2] = yOffset+14; ypoly4[3] = yOffset+14;   					   Polygon poly4 = new Polygon(xpoly4,ypoly4,4);				   g.setColor(Color.red);			       g.fillPolygon(poly4);			        g.setColor(Color.black);				   g.drawPolygon(poly4);			    					   xpoly4[0] = xOffset+10; xpoly4[1] = xOffset+14; xpoly4[2] = xOffset+4; xpoly4[3] = xOffset;						   ypoly4[0] = yOffset; ypoly4[1] = yOffset; ypoly4[2] = yOffset+14; ypoly4[3] = yOffset+14;   					   poly4 = new Polygon(xpoly4,ypoly4,4);				   g.setColor(Color.red);			       g.fillPolygon(poly4);			        g.setColor(Color.black);				   g.drawPolygon(poly4);									}				break;					/*	case splineSnakeAction.GO:				xOffset = x;				yOffset = y;				int x0=11;				int y0=-2;				for(int i=0;i<3;i++)					drawfilledRect(x0-=3,y0+=3,8,8,Color.black,Color.white);				break;			*/					            	       case splineSnakeAction.PREF:								 xOffset = x+1; yOffset = y+2;		          		          int[]	xpoly2 = new int[13];		          int[]	ypoly2 = new int[13];		          				   xpoly2[0] = xOffset+3; xpoly2[1] = xOffset+5; xpoly2[2] = xOffset+8; xpoly2[3] = xOffset+11;						   ypoly2[0] = yOffset+0; ypoly2[1] = yOffset+0; ypoly2[2] = yOffset+4; ypoly2[3] = yOffset+0;   					  				   xpoly2[4] = xOffset+13; xpoly2[5] = xOffset+15; xpoly2[6] = xOffset+15; xpoly2[7] = xOffset+14;  xpoly2[8] = xOffset+8; 				   ypoly2[4] = yOffset+0;  ypoly2[5] = yOffset+2;  ypoly2[6] = yOffset+4;  ypoly2[7] = yOffset+7;  ypoly2[8] = yOffset+13; 				   				   xpoly2[9] = xOffset+2;  xpoly2[10] = xOffset+1;  xpoly2[11] = xOffset+1;  xpoly2[12] = xOffset+3; 				   ypoly2[9] = yOffset+7;  ypoly2[10] = yOffset+4;  ypoly2[11] = yOffset+2;  ypoly2[12] = yOffset+0; 				 				  Polygon poly2 = new Polygon(xpoly2,ypoly2,13);				    g.setColor(Color.red);			    	g.fillPolygon(poly2);				   g.setColor(Color.black);				   g.drawPolygon(poly2);	            break;								case splineSnakeAction.TERMINATE:					xOffset = x;					yOffset = y;					m(5, 0);					d(5, 8);					m(4, 5);					d(4, 7);					m(3, 6);					d(3, 7);					m(2, 7);					d(2, 9);					m(1, 8);					d(1, 9);					m(2, 10);					d(6, 10);					m(3, 11);					d(3, 13);					m(1, 14);					d(6, 14);					m(0, 15);					d(7, 15);					m(2, 13);					d(2, 13);					m(5, 13);					d(5, 13);					g.setColor(Color.red);					m(7, 8);					d(14, 8);					m(8, 7);					d(15, 7);					m(8, 9);					d(13, 9);					m(9, 6);					d(9, 10);					m(15, 4);					d(15, 6);					d(14, 6);					break;			case splineSnakeAction.MAGNIFIER:				xOffset = x + 2;				yOffset = y + 2;				m(3, 0);				d(3, 0);				d(5, 0);				d(8, 3);				d(8, 5);				d(7, 6);				d(7, 7);				d(6, 7);				d(5, 8);				d(3, 8);				d(0, 5);				d(0, 3);				d(3, 0);				m(8, 8);				d(9, 8);				d(13, 12);				d(13, 13);				d(12, 13);				d(8, 9);				d(8, 8);				break;			//AS			case splineSnakeAction.DROP:				g.setColor(Color.blue);				    xOffset = x+4; yOffset = y+4;		           /*int[] xpoly5 = new int[4];				   int[] ypoly5 = new int[4];				   xpoly5[0] = x+4; xpoly5[1] = x+14; xpoly5[2] = x+4; xpoly5[3] = x+4; 				   ypoly5[0] = y+2; ypoly5[1] = y+8; ypoly5[2] = y+14; ypoly5[3] = y+2; 				   Polygon poly5 = new Polygon(xpoly5,ypoly5,4);				   g.fillPolygon(poly5);				   g.setColor(Color.black);				   g.drawPolygon(poly5);				   */				//g.fillOval(xOffset,yOffset,12,6);				g.fillOval(xOffset,yOffset,7,6);				g.fillOval(xOffset,yOffset+6,7,6);								g.setColor(Color.blue);				xOffset = x+13; yOffset = y+5;				g.setFont(new Font("fast", Font.BOLD, 7));				g.drawString("F",xOffset,yOffset);								break;			case splineSnakeAction.DROP2:				xOffset = x;				yOffset = y+2;				g.setColor(Color.red);				m(0,2);				d(1,3);				d(3,3);				d(0,4);				g.setColor(Color.blue);				m(5,2);				d(7,2);				m(5,4);				d(7,4);				m(4,3);				d(13,3);				d(13,4);				d(14,4);				d(14,7);				d(13,7);				d(13,8);				d(5,8);				d(5,9);				d(4,9);				d(4,12);				d(5,12);				d(5,13);				d(13,13);				/*g.setColor(Color.black);				m(3,3);				d(5,1);				d(7,1);				d(8,2);				d(13,2);				d(15,4);				d(15,7);				d(13,9);				d(6,9);				d(5,10);				d(5,11);				d(6,12);				d(13,12);				d(15,13);				d(13,14);				d(5,14);				d(3,12);				d(3,9);				d(5,7);				d(12,7);				d(13,6);				d(13,5);				d(12,4);				d(8,4);				d(7,5);				d(5,5);				d(3,3);				*/				g.setColor(Color.blue);				xOffset = x+13; yOffset = y+5;							//	Font fastFont = new Font("fast", Font.BOLD, 7);				g.setFont(new Font("fast", Font.BOLD, 7));				g.drawString("F",xOffset,yOffset);								break;									case splineSnakeAction.STACK:				xOffset = x;				yOffset = y;				g.setColor(Color.red);				m(0,2);				d(1,3);				d(3,3);				d(0,4);				g.setColor(Color.green);				m(5,2);				d(7,2);				m(5,4);				d(7,4);				m(4,3);				d(13,3);				d(13,4);				d(14,4);				d(14,7);				d(13,7);				d(13,8);				d(5,8);				d(5,9);				d(4,9);				d(4,12);				d(5,12);				d(5,13);				d(13,13);				/*g.setColor(Color.black);				m(3,3);				d(5,1);				d(7,1);				d(8,2);				d(13,2);				d(15,4);				d(15,7);				d(13,9);				d(6,9);				d(5,10);				d(5,11);				d(6,12);				d(13,12);				d(15,13);				d(13,14);				d(5,14);				d(3,12);				d(3,9);				d(5,7);				d(12,7);				d(13,6);				d(13,5);				d(12,4);				d(8,4);				d(7,5);				d(5,5);				d(3,3);				*/				g.setColor(Color.black);				xOffset = x+2; yOffset = y+16;							//	Font fastFont = new Font("fast", Font.BOLD, 7);				g.setFont(new Font("fast", Font.BOLD, 8));				g.drawString("SEQ",xOffset,yOffset);								break;			case splineSnakeAction.ABOUT:				g.setColor(Color.black);				xOffset = x+2; yOffset = y+15;								g.setFont(new Font("about", Font.BOLD, 20));				g.drawString("?",xOffset,yOffset);								break;		}	} /* end drawButton */	/*------------------------------------------------------------------*/	private void fill3DRect (		final Graphics g,		final int x,		final int y,		final int width,		final int height,		final boolean raised	) {		if (raised) {			g.setColor(gray);		}		else {			g.setColor(darker);		}		g.fillRect(x + 1, y + 1, width - 2, height - 2);		g.setColor((raised) ? (brighter) : (evenDarker));		g.drawLine(x, y, x, y + height - 1);		g.drawLine(x + 1, y, x + width - 2, y);		g.setColor((raised) ? (evenDarker) : (brighter));		g.drawLine(x + 1, y + height - 1, x + width - 1, y + height - 1);		g.drawLine(x + width - 1, y, x + width - 1, y + height - 2);	} /* end fill3DRect */	/*------------------------------------------------------------------*/	private void m (		final int x,		final int y	) {		this.x = xOffset + x;		this.y = yOffset + y;	} /* end m */	/*------------------------------------------------------------------*/	private void resetButtons (	) {		for (int i = 0; (i < NUM_TOOLS); i++) {			down[i] = false;		}	} /* end resetButtons */	/*------------------------------------------------------------------*/	private void restorePreviousToolbar (	) {		final Container container = instance.getParent();		final Component component[] = container.getComponents();		for (int i = 0; (i < component.length); i++) {			if (component[i] == instance) {				container.remove(instance);				container.add(previousInstance, i);				container.validate();				break;			}		}	} /* end restorePreviousToolbar */	/*------------------------------------------------------------------*/	public void showMessage (		final int tool	) {		switch (tool) {			case splineSnakeAction.ADD_CROSS:				IJ.showStatus("Enter/Move knots");				return;			case splineSnakeAction.REMOVE_CROSS:				IJ.showStatus("Remove knots");				return;			/*case splineSnakeAction.ADD_CONSTRAINT:				IJ.showStatus("Enter/Move constraint points");				return;			case splineSnakeAction.REMOVE_CONSTRAINT:				IJ.showStatus("Remove constraint points");				return;*/			case splineSnakeAction.REMOVE_ALL:				IJ.showStatus("Remove all");				return;			case splineSnakeAction.PREF:				IJ.showStatus("Preferences");				return;			case splineSnakeAction.FILE:				IJ.showStatus("Export/Import list of points");				return;			case splineSnakeAction.ACCEPT:				IJ.showStatus("Accept red snake");				return;			case splineSnakeAction.TERMINATE:				IJ.showStatus("Exit DropSnake");				return;			case splineSnakeAction.MAGNIFIER:				IJ.showStatus("Magnifying glass");				return;			//AS					case splineSnakeAction.DROP:				IJ.showStatus("Create a 7 knots curve and Fast snake it");				return;			case splineSnakeAction.DROP2:				IJ.showStatus("Fast snake actual curve");				return;			case splineSnakeAction.STACK:				IJ.showStatus("Snake sequence from actual curve");				return;					case splineSnakeAction.ABOUT:				IJ.showStatus("About DropSnake");				return;					case splineSnakeAction.SNAKE_CURVE:				if(!down[tool])					IJ.showStatus("Snake the Curve");				else					IJ.showStatus("Abort Snaking");				return;			/*case splineSnakeAction.GO:				IJ.showStatus("Reserved for stacks");				return;*/			default:				IJ.showStatus("");				return;		}	} /* end showMessage */	private void drawfilledRect (		int x0,		int y0,		int width,		int height,		Color border,		Color inside)	{				m(x0,y0);		g.setColor(border);		d(x0,y0+height);		d(x0+width,y0+height);		d(x0+width,y0);		d(x0,y0);		m(x0,y0);		g.setColor(inside);		g.fillRect(xOffset+x0+1,yOffset+y0+1,width-1,height-1);		g.setColor(Color.black);	} /* end drawFilledRect */} /* end class splineSnakeToolbar *//*====================================================================|	selectCurrentCurve\===================================================================*//********************************************************************* * This class creates a dialog to return to ImageJ. ********************************************************************/class selectCurrentCurve	extends		Dialog	implements		ActionListener{ /* begin class splineFlowTerminate *//*....................................................................	Private variables....................................................................*/public boolean cancel = false;public void actionPerformed (	final ActionEvent ae) {	this.setVisible(false);//	IJ.write(ae.getActionCommand());	if (ae.getActionCommand().equals("Select")) {	//	IJ.write("doneselected");		}	else if (ae.getActionCommand().equals("Cancel")) {		cancel = true;//				IJ.write("cancel selected");	}} /* end actionPerformed *//********************************************************************* * Return some additional margin to the dialog, for aesthetic purposes. * Necessary for the current MacOS X Java version, lest the first item * disappears from the frame. ********************************************************************/public Insets getInsets () {	return(new Insets(0, 40, 20, 40));} /* end getInsets *//********************************************************************* * This constructor prepares the layout of the dialog. * * @param parentWindow Parent window. ********************************************************************/selectCurrentCurve (	final Frame parentWindow) {	super(parentWindow, "Accept Red Curve", true);	setLayout(new GridLayout(0, 1));	final Button doneButton = new Button("Select");	final Button cancelButton = new Button("Cancel");	doneButton.addActionListener(this);	cancelButton.addActionListener(this);	final Label separation1 = new Label("");	final Label separation2 = new Label("");	add(separation1);	add(doneButton);	add(separation2);	add(cancelButton);	pack();  }} /* end selectCurrentCurve*/class SaveParameters {	boolean EnergySurfaces ;	boolean interpolate;		double eRatio ;	double knotsRatio;	double gamma;	double Psample;	double SnakeThreshold;	double SnakeSigma;	double SnakeGamma;	SaveParameters(SplineSnakePreferences param){		EnergySurfaces = param.EnergySurfaces;		interpolate = param.interpolate;				eRatio = param.eRatio;		knotsRatio= param.knotsRatio;		gamma= param.gamma;		Psample= param.Psample;		SnakeThreshold= param.SnakeThreshold;		SnakeSigma= param.SnakeSigma;		SnakeGamma= param.SnakeGamma;	}		public void restoreParameters(SplineSnakePreferences param) {			param.initialization=false;			param.EnergySurfaces=EnergySurfaces;			param.eRatio=eRatio;			param.knotsRatio=knotsRatio;			param.gamma=gamma;			param.interpolate=interpolate;			param.Psample=Psample;			param.SnakeThreshold=SnakeThreshold;			param.SnakeSigma=SnakeSigma;			param.SnakeGamma=SnakeGamma;	}				}
/*====================================================================| DropSnake Version: March 22, 2005\===================================================================*//*====================================================================| EPFL/STI/IOA/BIG| Aurélien Stalder| aurelien.stalder@gmail.com|\===================================================================*/// Based on the plugin SplineSnake by Mathews Jacob; Version: March 1, 2003package dropsnake;import ij.plugin.PlugIn;import ij.process.*;import java.awt.*;import java.awt.event.*;import java.io.*;import java.util.*;import java.lang.*;import ij.*;import ij.gui.*;public class Iterutil extends Object{											// Iteration parameters								//----------------------	private double exitlimit = 0.01;	private int Maxiniter = 100;									// Private Variables								//-------------------	private double Gamma_local;	//private double SnakeGamma;	private double Delta;			private double  LineX[];	private double  LineY[];	private double  PrevXvalues[];	private double  PrevYvalues[];	private double  PointListX[];	private double  PointListY[];	private ImagePlus imageplus;	private SplineSnakePreferences parameter;//	private CreateMovie movie;		private double[] kernel = {0 ,-1.3888889e-03 ,-7.7777778e-02 ,-3.4027778e-01  ,1.1102230e-16 , 3.4027778e-01 ,  7.7777778e-02  , 1.3888889e-03  , 0};	private	int origin = 4;	private double length = 0;	private double weight2 = 1;		public DirDerrivative snake_dir_der;		private boolean CAconverged;	private int CAconvergenceCounter=0;	private double[] CAp=new double[2];		static private double TOL_CA=0.01;	double errordistknot;	//---------------// Constructor//---------------	public Iterutil(ImagePlus imp, Curve curve, Vector listConstraints, SplineSnakePreferences param) 		{			imageplus = imp;			parameter = param;			snake_dir_der = new DirDerrivative(imp, curve, listConstraints,  param, param.curveConstraint);				LineX = new double[curve.npoints];			LineY = new double[curve.npoints];			//movie = new CreateMovie(imp,curve);		}//--------------------------------------------------// update the coefficients using steepest descend//--------------------------------------------------	public void updateCoeffs_Steepest()		{					double[] CX = new double[snake_dir_der.curve.npoints];			double[] CY = new double[snake_dir_der.curve.npoints];						double[] prevDC = new double[snake_dir_der.curve.npoints];			double[] prevDD = new double[snake_dir_der.curve.npoints];			double[] prevCX = new double[snake_dir_der.curve.npoints];			double[] prevCY = new double[snake_dir_der.curve.npoints];						double test,temp;			int loopcounter=201;			int slackcounter=201;			int looprecovery = 50;			int slackrecovery = 5;			int nloops = 0;									double area = snake_dir_der.curve.ComputeArea();			double norm = 100000;			double Gamma_local = Math.abs(parameter.SnakeGamma * area/(snake_dir_der.Imagepreprocessed.totArea));			//double SnakeGamma = Gamma_local*parameter.SnakeThreshold;			progressBarVolume pb = new progressBarVolume();			pb.setProgressBarVolume("Snaking...", 10.0/parameter.SnakeMaxIter, 1);						int i = 0;			while(i< parameter.SnakeMaxIter  && (/*Gamma_local>SnakeGamma ||*/ !CAconverged) )					{					i++;					loopcounter++;					slackcounter++;										if((i%10 == 0 && loopcounter>looprecovery)| i==0)						length = snake_dir_der.curve.Length;											if(i%10==0)						pb.stepProgressBar();											if(i%50 == 0 && i!=0 && i!= parameter.SnakeMaxIter && parameter.EnergySurfaces && !parameter.initialization && !parameter.stack)						{							//if(parameter.Nresample*parameter.Nresample*(snake_dir_der.curve.npoints+1) <  snake_dir_der.curve.Length*snake_dir_der.curve.npoints)							//if((snake_dir_der.curve.npoints+1) <  parameter.knotsNumber)								//errordistknot = parameter.knotsDistance - snake_dir_der.curve.distInterface;							//if(errordistknot<0.0) {								//if(errordistknot < -snake_dir_der.curve.distInterface/(2*(snake_dir_der.curve.npoints+1)))							if(snake_dir_der.curve.lengthNormal* (1.0-parameter.gamma) > (snake_dir_der.curve.npoints-3+1)*parameter.Nresample)									{									snake_dir_der.addKnot();									CX = new double[snake_dir_der.curve.npoints];									CY = new double[snake_dir_der.curve.npoints];									prevDC = new double[snake_dir_der.curve.npoints];									prevDD = new double[snake_dir_der.curve.npoints];									prevCX = new double[snake_dir_der.curve.npoints];									prevCY = new double[snake_dir_der.curve.npoints];								}							//}							// else if(parameter.Nresample*parameter.Nresample*(snake_dir_der.curve.npoints-1) >  snake_dir_der.curve.Length*snake_dir_der.curve.npoints)						 	//else if((snake_dir_der.curve.npoints-1) >  parameter.knotsNumber)							 	//else {								//if(errordistknot > snake_dir_der.curve.distInterface/(2*(snake_dir_der.curve.npoints-1)))						 	else if(snake_dir_der.curve.lengthNormal* (1.0-parameter.gamma) < (snake_dir_der.curve.npoints-3-1)*parameter.Nresample)						 		{							 		if(snake_dir_der.curve.npoints>5)							 			{											snake_dir_der.deleteKnot();											CX = new double[snake_dir_der.curve.npoints];											CY = new double[snake_dir_der.curve.npoints];											prevDC = new double[snake_dir_der.curve.npoints];											prevDD = new double[snake_dir_der.curve.npoints];											prevCX = new double[snake_dir_der.curve.npoints];											prevCY = new double[snake_dir_der.curve.npoints];										}							 								 	}							 //}							//int newsamplingrate = (int)(snake_dir_der.curve.lengthNormal/(snake_dir_der.curve.npoints-3));							int newsamplingrate = (int)(parameter.Nresample/parameter.Psample + 0.5);							newsamplingrate = (newsamplingrate<3)? 3:newsamplingrate;							if(newsamplingrate != snake_dir_der.curve.Nsamples)								{									snake_dir_der.curve.setNsamples(newsamplingrate);									snake_dir_der.Acoeff_inst.computeBuffer();									snake_dir_der.Bcoeff_inst=new Bcoeffs(snake_dir_der.curve);								}						}											if(i%600 == 0 && i!=0 && parameter.SnakeWeight != 0.0)						{							if(nloops<200)						 	snake_dir_der.Imagepreprocessed.giveUpdatedimage(snake_dir_der.curve);						}											if(snake_dir_der.curve.Check_for_Curve_looping()) 						{							norm = snake_dir_der.getDD(0,true);							loopcounter = 0;							nloops++;						}					else if(loopcounter<looprecovery)						{							norm = snake_dir_der.getDD(0,true);						}					else if(slackcounter<slackrecovery )						{							norm = snake_dir_der.getDD(1,true);						}					else						norm = snake_dir_der.getDD(1,false);											test = 0.0;						//ph.evolving=true;										for(int j=0;j<snake_dir_der.curve.npoints;j++)						{							temp = CX[j];							CX[j] = snake_dir_der.curve.CoeffX[j]-Gamma_local *snake_dir_der.DC_final[j];							temp -=CX[j]; test += temp*temp;							temp = CY[j];							CY[j] = snake_dir_der.curve.CoeffY[j]-Gamma_local *snake_dir_der.DD_final[j];							temp -=CY[j]; test += temp*temp;						}					snake_dir_der.curve.updateCurve(CX, CY);					//ph.evolving=false;										if(i%10 == 0 && loopcounter > looprecovery)						{							norm = 0;							for(int j=0;j<snake_dir_der.curve.npoints;j++)								{									temp = CX[j] - prevCX[j];									norm += temp*temp;									temp = CY[j] - prevCY[j];									norm += temp*temp;									prevCX[j] = CX[j];									prevCY[j] = CY[j];								}								if(norm<snake_dir_der.curve.npoints*parameter.SnakeThreshold)									{										Gamma_local *= 0.75;										slackcounter = 0;									}								CAconverged=checkCAconvergence();						}															for(int j=0;j<snake_dir_der.curve.npoints;j++)						{							prevDC[j] = snake_dir_der.DC_final[j];							prevDD[j] = snake_dir_der.DD_final[j];						}									}						pb.showCompleted();			return;		}						//--------------------------------------------------// update the coefficients using steepest descend// handles the animation mode// slower as it displays the snake at every iteration//--------------------------------------------------			public void updateCoeffs_SteepestDemo(splineSnakeHandler ph)		{									double[] CX = new double[snake_dir_der.curve.npoints];			double[] CY = new double[snake_dir_der.curve.npoints];						double[] prevDC = new double[snake_dir_der.curve.npoints];			double[] prevDD = new double[snake_dir_der.curve.npoints];			double[] prevCX = new double[snake_dir_der.curve.npoints];			double[] prevCY = new double[snake_dir_der.curve.npoints];						double test,temp;						int loopcounter=201;			int slackcounter=201;			int looprecovery = 50;			int slackrecovery = 5;			int nloops = 0;									double area = snake_dir_der.curve.ComputeArea();			double norm = 100000;			double Gamma_local = Math.abs(parameter.SnakeGamma * area/(snake_dir_der.Imagepreprocessed.totArea));		//	double SnakeGamma = Gamma_local*parameter.SnakeThreshold;			progressBarVolume pb = new progressBarVolume();			pb.setProgressBarVolume("Snaking...", 10.0/parameter.SnakeMaxIter, 1);						int i = 0;			while(i< parameter.SnakeMaxIter  && (/*Gamma_local>SnakeGamma ||*/ !CAconverged) )					{					//IJ.error("debut iteration 1");					i++;					loopcounter++;					slackcounter++;										if((i%10 == 0 && loopcounter>looprecovery)| i==0)						length = snake_dir_der.curve.Length;											if(i%10==0)						pb.stepProgressBar();											if(i%50 == 0 && i!=0 && i!= parameter.SnakeMaxIter && parameter.EnergySurfaces && !parameter.initialization && !parameter.stack)	////MODIFIED!						{							//AS was +2								//if(parameter.Nresample*parameter.Nresample*(snake_dir_der.curve.npoints+1) <  snake_dir_der.curve.Length*snake_dir_der.curve.npoints)							//if((snake_dir_der.curve.npoints+1) <  parameter.knotsNumber)														//errordistknot = parameter.knotsDistance - snake_dir_der.curve.distInterface;							//if(errordistknot<0.0) {								//if(errordistknot < -snake_dir_der.curve.distInterface/(2*(snake_dir_der.curve.npoints+1)))							if(snake_dir_der.curve.lengthNormal * (1.0-parameter.gamma) > (snake_dir_der.curve.npoints-3+1)*parameter.Nresample)								{									//IJ.wait(500);									snake_dir_der.addKnot();									//IJ.wait(500);									//IJ.write("Added a knot "+snake_dir_der.curve.npoints);									CX = new double[snake_dir_der.curve.npoints];									CY = new double[snake_dir_der.curve.npoints];									prevDC = new double[snake_dir_der.curve.npoints];									prevDD = new double[snake_dir_der.curve.npoints];									prevCX = new double[snake_dir_der.curve.npoints];									prevCY = new double[snake_dir_der.curve.npoints];																}							//}							//AS was -2								//else if(parameter.Nresample*parameter.Nresample*(snake_dir_der.curve.npoints-1) >  snake_dir_der.curve.Length*snake_dir_der.curve.npoints)							//else if((snake_dir_der.curve.npoints-1) >  parameter.knotsNumber)													//	else {							//	if(errordistknot > snake_dir_der.curve.distInterface/(2*(snake_dir_der.curve.npoints-1)))							else if(snake_dir_der.curve.lengthNormal * (1.0-parameter.gamma) < (snake_dir_der.curve.npoints-3-1)*parameter.Nresample)							 	{							 		if(snake_dir_der.curve.npoints>5)							 			{											snake_dir_der.deleteKnot();											//IJ.write("Deleted a knot "+snake_dir_der.curve.npoints);											CX = new double[snake_dir_der.curve.npoints];											CY = new double[snake_dir_der.curve.npoints];											prevDC = new double[snake_dir_der.curve.npoints];											prevDD = new double[snake_dir_der.curve.npoints];											prevCX = new double[snake_dir_der.curve.npoints];											prevCY = new double[snake_dir_der.curve.npoints];										}							 								 	}							 //}							//int newsamplingrate = (int)(snake_dir_der.curve.lengthNormal* (1.0-parameter.gamma)/(snake_dir_der.curve.npoints-3));							int newsamplingrate = (int)(parameter.Nresample/parameter.Psample + 0.5);							newsamplingrate = (newsamplingrate<3)? 3:newsamplingrate;							if(newsamplingrate != snake_dir_der.curve.Nsamples)								{									snake_dir_der.curve.setNsamples(newsamplingrate);									snake_dir_der.Acoeff_inst.computeBuffer();									snake_dir_der.Bcoeff_inst=new Bcoeffs(snake_dir_der.curve);																		//IJ.write("setting the sampling rate to "+newsamplingrate);								}						}											//recalculate preprocessed image only if energy is not gradient 100%					if(i%600 == 0 && i!=0 && parameter.SnakeWeight != 0.0)						{							if(nloops<200)						 	snake_dir_der.Imagepreprocessed.giveUpdatedimage(snake_dir_der.curve);						}											if(snake_dir_der.curve.Check_for_Curve_looping()) 					//if(false) //disable looping test						{							//IJ.write("Curve is Looping at step "+i);							norm = snake_dir_der.getDD(0,true);							loopcounter = 0;							nloops++;						}					else if(loopcounter<looprecovery)						{							norm = snake_dir_der.getDD(0,true);							//IJ.write("Still recovering from loops "+i);						}					else if(slackcounter<slackrecovery )						{							norm = snake_dir_der.getDD(1,true);							//IJ.write("Checking with length reduction"+i);						}					else						norm = snake_dir_der.getDD(1,false);											test = 0.0;											//ph.evolving=true;					ph.curveComputed=false;					for(int j=0;j<snake_dir_der.curve.npoints;j++)						{							temp = CX[j];							CX[j] = snake_dir_der.curve.CoeffX[j]-Gamma_local *snake_dir_der.DC_final[j];							temp -=CX[j]; test += temp*temp;							temp = CY[j];							CY[j] = snake_dir_der.curve.CoeffY[j]-Gamma_local *snake_dir_der.DD_final[j];							temp -=CY[j]; test += temp*temp;						}					snake_dir_der.curve.updateCurve(CX, CY);										//ph.evolving=false;					ph.curveComputed=true;										if(i%10 == 0 && loopcounter > looprecovery)						{							norm = 0;							for(int j=0;j<snake_dir_der.curve.npoints;j++)								{									temp = CX[j] - prevCX[j];									norm += temp*temp;									temp = CY[j] - prevCY[j];									norm += temp*temp;									prevCX[j] = CX[j];									prevCY[j] = CY[j];								}														if(norm<snake_dir_der.curve.npoints*parameter.SnakeThreshold)								{									Gamma_local *= 0.75;									//IJ.write("Reducing SnakeGamma by 0.75");									slackcounter = 0;								}							CAconverged=checkCAconvergence();						}															for(int j=0;j<snake_dir_der.curve.npoints;j++)						{							prevDC[j] = snake_dir_der.DC_final[j];							prevDD[j] = snake_dir_der.DD_final[j];						}					imageplus.draw();				}						//movie.addSlice();			//movie.showMovie();			//IJ.write("end of steepest");						pb.showCompleted();			if(nloops>50)				IJ.write("Curve was looping in "+(int)(100*(double)nloops/(double)i)+"% of iterations\nYou may want to reinitialize the curve");			return;		}					private boolean checkCAconvergence() {		double[] CA=snake_dir_der.curve.CA;			if(Math.abs(CA[0]-CAp[0])<parameter.SnakeThreshold) {		if(Math.abs(CA[1]-CAp[1])<parameter.SnakeThreshold) CAconvergenceCounter++;	}	else CAconvergenceCounter=0;	CAp[0]=CA[0];	CAp[1]=CA[1];		if(CAconvergenceCounter<20) return false;	else return true;		}}